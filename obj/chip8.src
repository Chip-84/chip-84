; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\CHIP8.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME1"
.TYPE 104
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME7"
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME8",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME10"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME10",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME10"
.BEGREC "__stdio_file",1
.DEFINE "slot"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "__stdio_file"
	SEGMENT DATA
_opcode:
	DW	0
.DEFINE "opcode"
.ALIAS "_opcode"
.CLASS 69
.VALUE _opcode
.TYPE 13
.ENDEF
	SEGMENT BSS
_memory:
	DS	4096
.DEFINE "memory"
.ALIAS "_memory"
.CLASS 83
.VALUE _memory
.DIM 4096
.TYPE 108
.ENDEF
_V:
	DS	16
.DEFINE "V"
.ALIAS "_V"
.CLASS 83
.VALUE _V
.DIM 16
.TYPE 108
.ENDEF
	SEGMENT DATA
_I:
	DW	0
.DEFINE "I"
.ALIAS "_I"
.CLASS 69
.VALUE _I
.TYPE 13
.ENDEF
_pc:
	DW	0
.DEFINE "pc"
.ALIAS "_pc"
.CLASS 69
.VALUE _pc
.TYPE 13
.ENDEF
_delay_timer:
	DW	0
.DEFINE "delay_timer"
.ALIAS "_delay_timer"
.CLASS 69
.VALUE _delay_timer
.TYPE 3
.ENDEF
_sound_timer:
	DW	0
.DEFINE "sound_timer"
.ALIAS "_sound_timer"
.CLASS 69
.VALUE _sound_timer
.TYPE 3
.ENDEF
	SEGMENT BSS
_stack:
	DS	32
.DEFINE "stack"
.ALIAS "_stack"
.CLASS 83
.VALUE _stack
.DIM 16
.TYPE 109
.ENDEF
	SEGMENT DATA
_sp:
	DB	0
.DEFINE "sp"
.ALIAS "_sp"
.CLASS 69
.VALUE _sp
.TYPE 12
.ENDEF
_keys:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
.DEFINE "keys"
.ALIAS "_keys"
.CLASS 69
.VALUE _keys
.DIM 16
.TYPE 108
.ENDEF
_drawFlag:
	DB	0
.DEFINE "drawFlag"
.ALIAS "_drawFlag"
.CLASS 69
.VALUE _drawFlag
.TYPE 12
.ENDEF
_paused:
	DB	0
.DEFINE "paused"
.ALIAS "_paused"
.CLASS 69
.VALUE _paused
.TYPE 12
.ENDEF
_playing:
	DB	0
.DEFINE "playing"
.ALIAS "_playing"
.CLASS 69
.VALUE _playing
.TYPE 12
.ENDEF
	SEGMENT BSS
_game_data:
	DS	3584
.DEFINE "game_data"
.ALIAS "_game_data"
.CLASS 83
.VALUE _game_data
.DIM 3584
.TYPE 108
.ENDEF
_keypad:
	DS	16
.DEFINE "keypad"
.ALIAS "_keypad"
.CLASS 83
.VALUE _keypad
.DIM 16
.TYPE 108
.ENDEF
_controlMap:
	DS	16
.DEFINE "controlMap"
.ALIAS "_controlMap"
.CLASS 83
.VALUE _controlMap
.DIM 16
.TYPE 108
.ENDEF
_file:
	DS	1
.DEFINE "file"
.ALIAS "_file"
.CLASS 83
.VALUE _file
.TYPE 12
.ENDEF
	SEGMENT DATA
_fontset:
	DB	240
	DB	144
	DB	144
	DB	144
	DB	240
	DB	32
	DB	96
	DB	32
	DB	32
	DB	112
	DB	240
	DB	16
	DB	240
	DB	128
	DB	240
	DB	240
	DB	16
	DB	240
	DB	16
	DB	240
	DB	144
	DB	144
	DB	240
	DB	16
	DB	16
	DB	240
	DB	128
	DB	240
	DB	16
	DB	240
	DB	240
	DB	128
	DB	240
	DB	144
	DB	240
	DB	240
	DB	16
	DB	32
	DB	64
	DB	64
	DB	240
	DB	144
	DB	240
	DB	144
	DB	240
	DB	240
	DB	144
	DB	240
	DB	16
	DB	240
	DB	240
	DB	144
	DB	240
	DB	144
	DB	144
	DB	224
	DB	144
	DB	224
	DB	144
	DB	224
	DB	240
	DB	128
	DB	128
	DB	128
	DB	240
	DB	224
	DB	144
	DB	144
	DB	144
	DB	224
	DB	240
	DB	128
	DB	240
	DB	128
	DB	240
	DB	240
	DB	128
	DB	240
	DB	128
	DB	128
.DEFINE "fontset"
.ALIAS "_fontset"
.CLASS 69
.VALUE _fontset
.DIM 80
.TYPE 108
.ENDEF
	SEGMENT BSS
_step:
	DS	1
.DEFINE "step"
.ALIAS "_step"
.CLASS 83
.VALUE _step
.TYPE 12
.ENDEF
_pixel:
	DS	1
.DEFINE "pixel"
.ALIAS "_pixel"
.CLASS 83
.VALUE _pixel
.TYPE 12
.ENDEF
_index:
	DS	2*1
.DEFINE "index"
.ALIAS "_index"
.CLASS 83
.VALUE _index
.TYPE 13
.ENDEF
__y:
	DS	1
.DEFINE "_y"
.ALIAS "__y"
.CLASS 83
.VALUE __y
.TYPE 12
.ENDEF
__x:
	DS	1
.DEFINE "_x"
.ALIAS "__x"
.CLASS 83
.VALUE __x
.TYPE 12
.ENDEF
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <debug.h>
;    6	
;    7	#include <math.h>
;    8	#include <stdio.h>
;    9	#include <stdlib.h>
;   10	#include <string.h>
;   11	
;   12	#include <fileioc.h>
;   13	#include <keypadc.h>
;   14	
;   15	#include "chip8.h"
;   16	#include "sprites_gfx.h"
;   17	
;   18	uint16_t opcode = 0;
;   19	uint8_t memory[4096];
;   20	uint8_t V[16];
;   21	uint16_t I = 0;
;   22	uint16_t pc = 0;
;   23	int16_t delay_timer = 0;
;   24	int16_t sound_timer = 0;
;   25	uint16_t stack[16];
;   26	uint8_t sp = 0;
;   27	uint8_t keys[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;   28	bool drawFlag = false;
;   29	
;   30	bool paused = false;
;   31	bool playing = false;
;   32	
;   33	uint8_t game_data[3584];
;   34	uint8_t keypad[16];
;   35	uint8_t controlMap[16];
;   36	
;   37	ti_var_t file;
;   38	
;   39	unsigned char fontset[80] = {
;   40	    0xF0, 0x90, 0x90, 0x90, 0xF0, //0
;   41	    0x20, 0x60, 0x20, 0x20, 0x70, //1
;   42	    0xF0, 0x10, 0xF0, 0x80, 0xF0, //2
;   43	    0xF0, 0x10, 0xF0, 0x10, 0xF0, //3
;   44	    0x90, 0x90, 0xF0, 0x10, 0x10, //4
;   45	    0xF0, 0x80, 0xF0, 0x10, 0xF0, //5
;   46	    0xF0, 0x80, 0xF0, 0x90, 0xF0, //6
;   47	    0xF0, 0x10, 0x20, 0x40, 0x40, //7
;   48	    0xF0, 0x90, 0xF0, 0x90, 0xF0, //8
;   49	    0xF0, 0x90, 0xF0, 0x10, 0xF0, //9
;   50	    0xF0, 0x90, 0xF0, 0x90, 0x90, //A
;   51	    0xE0, 0x90, 0xE0, 0x90, 0xE0, //B
;   52	    0xF0, 0x80, 0x80, 0x80, 0xF0, //C
;   53	    0xE0, 0x90, 0x90, 0x90, 0xE0, //D
;   54	    0xF0, 0x80, 0xF0, 0x80, 0xF0, //E
;   55	    0xF0, 0x80, 0xF0, 0x80, 0x80  //F
;   56	};
;   57	
;   58	uint8_t step;
;   59	uint8_t pixel;
;   60	uint16_t index;
;   61	
;   62	uint8_t _y;
;   63	uint8_t _x;
	SEGMENT CODE
;   64	
;   65	void initialize() {
_initialize:
.DEFINE "_initialize"

.VALUE _initialize

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initialize",65,"_initialize"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   66		
;   67		opcode = I = sp = delay_timer = sound_timer = 0;
.LINE 67

	LD	HL,_sound_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_delay_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	XOR	A,A
	LD	(_sp),A
	LD	HL,_I
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_opcode
	LD	(HL),0
	INC	HL
	LD	(HL),0
;   68		pc = 0x200;
.LINE 68

	LD	HL,_pc
	LD	(HL),0
	INC	HL
	LD	(HL),2
;   69		
;   70		canvas_data[0] = 64;
.LINE 70

	LD	A,64
	LD	(_canvas_data),A
;   71		canvas_data[1] = 32;
.LINE 71

	LD	HL,_canvas_data
	INC	HL
	LD	(HL),32
;   72		memset(canvas_data + 2, 0, 2048);
.LINE 72

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;   73		memset(keys, 0, 16);
.LINE 73

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_keys
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;   74		memset(stack, 0, 16);
.LINE 74

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_stack
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;   75		memset(V, 0, 16);
.LINE 75

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_V
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;   76		memset(memory, 0, 4096);
.LINE 76

	LD	BC,4096
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;   77		
;   78		memcpy(memory, fontset, 80);
.LINE 78

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;   79		
;   80		srand(rtc_Time());
.LINE 80

	LD	BC,(15925316)
	PUSH	BC
	CALL	_srand
	POP	BC
;   81	}
.LINE 81

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initialize ***************************
;Name                         Addr/Register   Size   Type
;_srand                              IMPORT  -----   function
;_fontset                            STATIC     80   variable
;_memcpy                             IMPORT  -----   function
;_memory                             STATIC   4096   variable
;_V                                  STATIC     16   variable
;_stack                              STATIC     32   variable
;_keys                               STATIC     16   variable
;_memset                             IMPORT  -----   function
;_canvas_data                        IMPORT   2050   variable
;_pc                                 STATIC      2   variable
;_opcode                             STATIC      2   variable
;_I                                  STATIC      2   variable
;_sp                                 STATIC      1   variable
;_delay_timer                        STATIC      2   variable
;_sound_timer                        STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initialize",81,"_initialize"
;   82	
;   83	void loadProgram(char *fileName) {
_loadProgram:
.DEFINE "_loadProgram"

.VALUE _loadProgram

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "loadProgram",83,"_loadProgram"

.LINE 83

.DEFINE "fileName"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "romSize"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;   84		int i;
;   85		uint16_t romSize;
;   86		
;   87		playing = true;
.LINE 87

	LD	A,1
	LD	(_playing),A
;   88		paused = false;
.LINE 88

	XOR	A,A
	LD	(_paused),A
;   89		
;   90		ti_CloseAll();
.LINE 90

	CALL	_ti_CloseAll
;   91		file = ti_Open(fileName, "r");
.LINE 91

	LD	BC,L__1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(_file),A
;   92		ti_Read(&game_data, ti_GetSize(file), 1, file);
.LINE 92

	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	PUSH	HL
	LD	BC,_game_data
	PUSH	BC
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   93		
;   94		romSize = ti_GetSize(file)-(16+6);
.LINE 94

	LD	A,(_file)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	IY,HL
	LEA	HL,IY+-22
	LD	(IX+-5),L
	LD	(IX+-4),H
;   95		dbg_sprintf(dbgout, "%d ", romSize);
.LINE 95

	LD	BC,(IX+-5)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__2
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;   96		
;   97		initialize();
.LINE 97

	CALL	_initialize
;   98		
;   99		if((4096-512) > romSize) {
.LINE 99

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,3584
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_9
;  100			for(i = 0; i < romSize; ++i) {
.LINE 100

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
;  101				memory[i + 512] = (uint8_t)game_data[i+16+6];
.LINE 101

	LD	IY,(IX+-3)
	LEA	HL,IY+22
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,512
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  102			}
L_3:
.LINE 102

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
;  103		}
L_9:
.LINE 103

;  104		for(i = 0; i < 16; i++) {
.LINE 104

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_8
L_6:
;  105			controlMap[i] = (uint8_t)game_data[i+6];
.LINE 105

	LD	IY,(IX+-3)
	LEA	HL,IY+6
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_controlMap
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  106		}
L_8:
.LINE 106

	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_6
;  107	}
.LINE 107

	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadProgram ***************************
;Name                         Addr/Register   Size   Type
;_controlMap                         STATIC     16   variable
;_memory                             STATIC   4096   variable
;_initialize                         IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_game_data                          STATIC   3584   variable
;_ti_GetSize                         IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_file                               STATIC      1   variable
;_ti_Open                            IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_paused                             STATIC      1   variable
;_playing                            STATIC      1   variable
;romSize                               IX-5      2   variable
;i                                     IX-3      3   variable
;fileName                              IX+6      3   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "loadProgram",107,"_loadProgram"
	SEGMENT STRSECT
L__1:
	DB	"r"
	DB	0
L__2:
	DB	"%d "
	DB	0
	SEGMENT CODE
;  108	
;  109	void setKeys() {
_setKeys:
.DEFINE "_setKeys"

.VALUE _setKeys

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setKeys",109,"_setKeys"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  110		keypad[0x0] = kb_Data[4] & kb_DecPnt;
.LINE 110

	LD	A,(16056344)
	AND	A,1
	LD	(_keypad),A
;  111		keypad[0x1] = kb_Data[3] & kb_7;
.LINE 111

	LD	A,(16056342)
	AND	A,8
	LD	HL,_keypad
	INC	HL
	LD	(HL),A
;  112		keypad[0x2] = kb_Data[4] & kb_8;
.LINE 112

	LD	A,(16056344)
	AND	A,8
	LD	IY,_keypad
	LEA	HL,IY+2
	LD	(HL),A
;  113		keypad[0x3] = kb_Data[5] & kb_9;
.LINE 113

	LD	A,(16056346)
	AND	A,8
	LEA	HL,IY+3
	LD	(HL),A
;  114		keypad[0x4] = kb_Data[3] & kb_4;
.LINE 114

	LD	A,(16056342)
	AND	A,4
	LEA	HL,IY+4
	LD	(HL),A
;  115		keypad[0x5] = kb_Data[4] & kb_5;
.LINE 115

	LD	A,(16056344)
	AND	A,4
	LEA	HL,IY+5
	LD	(HL),A
;  116		keypad[0x6] = kb_Data[5] & kb_6;
.LINE 116

	LD	A,(16056346)
	AND	A,4
	LEA	HL,IY+6
	LD	(HL),A
;  117		keypad[0x7] = kb_Data[3] & kb_1;
.LINE 117

	LD	A,(16056342)
	AND	A,2
	LEA	HL,IY+7
	LD	(HL),A
;  118		keypad[0x8] = kb_Data[4] & kb_2;
.LINE 118

	LD	A,(16056344)
	AND	A,2
	LEA	HL,IY+8
	LD	(HL),A
;  119		keypad[0x9] = kb_Data[5] & kb_3;
.LINE 119

	LD	A,(16056346)
	AND	A,2
	LEA	HL,IY+9
	LD	(HL),A
;  120		keypad[0xA] = kb_Data[3] & kb_0;
.LINE 120

	LD	A,(16056342)
	AND	A,1
	LEA	HL,IY+10
	LD	(HL),A
;  121		keypad[0xB] = kb_Data[5] & kb_Chs;
.LINE 121

	LD	A,(16056346)
	AND	A,1
	LEA	HL,IY+11
	LD	(HL),A
;  122		keypad[0xC] = kb_Data[6] & kb_Mul;
.LINE 122

	LD	A,(16056348)
	AND	A,8
	LEA	HL,IY+12
	LD	(HL),A
;  123		keypad[0xD] = kb_Data[6] & kb_Sub;
.LINE 123

	LD	A,(16056348)
	AND	A,4
	LEA	HL,IY+13
	LD	(HL),A
;  124		keypad[0xE] = kb_Data[6] & kb_Add;
.LINE 124

	LD	A,(16056348)
	AND	A,2
	LEA	HL,IY+14
	LD	(HL),A
;  125		keypad[0xF] = kb_Data[6] & kb_Enter;
.LINE 125

	LD	A,(16056348)
	AND	A,1
	LD	HL,_keypad+15
	LD	(HL),A
;  126		
;  127		keys[0x0] = keypad[controlMap[0x0]];
.LINE 127

	LD	A,(_controlMap)
	UEXT	HL
	LD	L,A
	LD	BC,_keypad
	ADD	HL,BC
	LD	A,(HL)
	LD	(_keys),A
;  128		keys[0x1] = keypad[controlMap[0x1]];
.LINE 128

	LD	HL,_controlMap
	INC	HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,_keys
	LD	A,(HL)
	LD	(IY+1),A
;  129		keys[0x2] = keypad[controlMap[0x2]];
.LINE 129

	LD	HL,_controlMap+2
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+2),A
;  130		keys[0x3] = keypad[controlMap[0x3]];
.LINE 130

	LD	HL,_controlMap+3
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+3),A
;  131		                              
;  132		keys[0x4] = keypad[controlMap[0x4]];
.LINE 132

	LD	HL,_controlMap+4
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+4),A
;  133		keys[0x5] = keypad[controlMap[0x5]];
.LINE 133

	LD	HL,_controlMap+5
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+5),A
;  134		keys[0x6] = keypad[controlMap[0x6]];
.LINE 134

	LD	HL,_controlMap+6
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+6),A
;  135		keys[0x7] = keypad[controlMap[0x7]];
.LINE 135

	LD	HL,_controlMap+7
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+7),A
;  136		                              
;  137		keys[0x8] = keypad[controlMap[0x8]];
.LINE 137

	LD	HL,_controlMap+8
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+8),A
;  138		keys[0x9] = keypad[controlMap[0x9]];
.LINE 138

	LD	HL,_controlMap+9
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+9),A
;  139		keys[0xA] = keypad[controlMap[0xA]];
.LINE 139

	LD	HL,_controlMap+10
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+10),A
;  140		keys[0xB] = keypad[controlMap[0xB]];
.LINE 140

	LD	HL,_controlMap+11
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+11),A
;  141		                              
;  142		keys[0xC] = keypad[controlMap[0xC]];
.LINE 142

	LD	HL,_controlMap+12
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+12),A
;  143		keys[0xD] = keypad[controlMap[0xD]];
.LINE 143

	LD	HL,_controlMap+13
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+13),A
;  144		keys[0xE] = keypad[controlMap[0xE]];
.LINE 144

	LD	HL,_controlMap+14
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+14),A
;  145		keys[0xF] = keypad[controlMap[0xF]];
.LINE 145

	LD	HL,_controlMap+15
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+15),A
;  146		
;  147		if(kb_Data[1] & kb_2nd) {
.LINE 147

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_11
	JR	L_15
;  148			while(kb_Data[1] & kb_2nd) {
L_12:
.LINE 148

;  149				kb_Scan();
.LINE 149

	CALL	_kb_Scan
;  150			}
L_11:
.LINE 150

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_12
;  151			paused = 1;
.LINE 151

	LD	A,1
	LD	(_paused),A
;  152		}
;  153	}
L_15:
.LINE 153

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setKeys ***************************
;Name                         Addr/Register   Size   Type
;_paused                             STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_keys                               STATIC     16   variable
;_controlMap                         STATIC     16   variable
;_keypad                             STATIC     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setKeys",153,"_setKeys"
;  154	
;  155	void emulateCycle(uint8_t steps) {
_emulateCycle:
.DEFINE "_emulateCycle"

.VALUE _emulateCycle

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emulateCycle",155,"_emulateCycle"

.LINE 155

.DEFINE "steps"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "key_pressed"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -11

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -12

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -13

.TYPE 12

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE -14

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -15

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -16

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -17

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -18

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -19

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-71
	LD	SP,HL
;  156		
;  157		kb_Scan();
.LINE 157

	CALL	_kb_Scan
;  158		setKeys();
.LINE 158

	CALL	_setKeys
;  159		
;  160		for(step = 0; step < steps; ++step) {
.LINE 160

	XOR	A,A
	LD	(_step),A
	JR	L_104
L_102:
;  161			int i;
;  162			opcode = (memory[pc] << 8) | memory[pc+1];
.LINE 162

	LD	BC,(_pc)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	H,L
	LD	L,0
	LD	DE,HL
	LD	BC,(_pc)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,DE
	CALL	__sor
	LD	BC,HL
	LD	HL,_opcode
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  163			
;  164			pc += 2;
.LINE 164

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  165			
;  166			switch(opcode & 0xf000) {
.LINE 166

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	BC,61440
	CALL	__iand
	CALL	__case16D
	JP	(HL)
L__10:
	DW	16
	DW	0
	DW24	L_16	

	DW	4096
	DW24	L_21	

	DW	8192
	DW24	L_22	

	DW	12288
	DW24	L_24	

	DW	16384
	DW24	L_27	

	DW	20480
	DW24	L_30	

	DW	24576
	DW24	L_34	

	DW	28672
	DW24	L_35	

	DW	32768
	DW24	L_36	

	DW	36864
	DW24	L_46	

	DW	40960
	DW24	L_51	

	DW	45056
	DW24	L_52	

	DW	49152
	DW24	L_53	

	DW	53248
	DW24	L_54	

	DW	57344
	DW24	L_63	

	DW	61440
	DW24	L_71	

	DW24	L_99	

;  167				case 0x0000: {
L_16:
.LINE 167

;  168					switch(opcode & 0x000f) {
.LINE 168

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__11:
	DW	2
	DB	0
	DW24	L_17	

	DB	14
	DW24	L_18	

	DW24	L_19	

;  169						case 0x0000:
L_17:
.LINE 169

;  170							memset(canvas_data + 2, 0, 2048);
.LINE 170

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  171							drawFlag = true;
.LINE 171

	LD	A,1
	LD	(_drawFlag),A
;  172							break;
.LINE 172

	JR	L_99
;  173						case 0x000e:
L_18:
.LINE 173

;  174							pc = stack[(--sp)&0xf];
.LINE 174

	LD	A,(_sp)
	DEC	A
	LD	(_sp),A
	AND	A,15
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	BC,(HL)
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  175							break;
.LINE 175

	JR	L_99
;  176						default:
L_19:
.LINE 176

;  177							pc = (pc & 0x0fff);
.LINE 177

	LD	HL,(_pc)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  178							break;
.LINE 178

	JR	L_99
;  179					}
;  180					break;
;  181				}
;  182				case 0x1000: {
L_21:
.LINE 182

;  183					pc = (opcode & 0x0fff);
.LINE 183

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  184					break;
.LINE 184

	JR	L_99
;  185				}
;  186				case 0x2000: {
L_22:
.LINE 186

;  187					stack[sp++] = pc;
.LINE 187

	LD	A,(_sp)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	A,(_pc)
	LD	(HL),A
	INC	HL
	LD	A,(_pc+1)
	LD	(HL),A
	LD	A,(_sp)
	INC	A
	LD	(_sp),A
;  188					pc = (opcode & 0x0fff);
.LINE 188

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  189					break;
.LINE 189

	JR	L_99
;  190				}
;  191				case 0x3000: {
L_24:
.LINE 191

;  192					if(V[(opcode & 0x0f00) >> 8] == (opcode & 0x00ff))
.LINE 192

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_99
;  193						pc += 2;
.LINE 193

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  194					break;
.LINE 194

	JR	L_99
;  195				}
;  196				case 0x4000: {
L_27:
.LINE 196

;  197					if(V[(opcode & 0x0f00) >> 8] != (opcode & 0x00ff))
.LINE 197

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	Z,L_99
;  198						pc += 2;
.LINE 198

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  199					break;
.LINE 199

	JR	L_99
;  200				}
;  201				case 0x5000: {
L_30:
.LINE 201

;  202					if(V[(opcode & 0x0f00) >> 8] == V[(opcode & 0x00f0) >> 4] && (opcode & 0x000f) == 0)
.LINE 202

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	NZ,L_99
	LD	A,(_opcode)
	AND	A,15
	LD	C,A
	LD	B,0
	LD	HL,BC
	CALL	__scmpzero
	JR	NZ,L_99
;  203						pc += 2;
.LINE 203

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  204					break;
.LINE 204

	JR	L_99
;  205				}
;  206				case 0x6000: {
L_34:
.LINE 206

;  207					V[(opcode & 0x0f00) >> 8] = (opcode & 0x00ff);
.LINE 207

	LD	A,(_opcode)
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  208					break;
.LINE 208

	JR	L_99
;  209				}
;  210				case 0x7000: {
L_35:
.LINE 210

;  211					V[(opcode & 0x0f00) >> 8] += (opcode & 0x00ff);
.LINE 211

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-22),HL
	LD	A,(_opcode)
	LD	HL,(IX+-22)
	LD	IY,(IX+-22)
	ADD	A,(HL)
	LD	(IY),A
;  212					break;
.LINE 212

	JR	L_99
;  213				}
;  214				case 0x8000: {
L_36:
.LINE 214

;  215					switch(opcode & 0x000f) {
.LINE 215

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__16:
	DW	9
	DB	0
	DW24	L_37	

	DB	1
	DW24	L_38	

	DB	2
	DW24	L_39	

	DB	3
	DW24	L_40	

	DB	4
	DW24	L_41	

	DB	5
	DW24	L_42	

	DB	6
	DW24	L_43	

	DB	7
	DW24	L_44	

	DB	14
	DW24	L_45	

	DW24	L_50	

;  216						case 0x0000: {
L_37:
.LINE 216

;  217							V[(opcode & 0x0f00) >> 8]  = V[(opcode & 0x00f0) >> 4];
.LINE 217

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
;  218							break;
.LINE 218

	JR	L_50
;  219						}
;  220						case 0x0001: {
L_38:
.LINE 220

;  221							V[(opcode & 0x0f00) >> 8] |= V[(opcode & 0x00f0) >> 4];
.LINE 221

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-25),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-25)
	LD	A,(HL)
	OR	A,(IY)
	LD	HL,(IX+-25)
	LD	(HL),A
;  222							break;
.LINE 222

	JR	L_50
;  223						}
;  224						case 0x0002: {
L_39:
.LINE 224

;  225							V[(opcode & 0x0f00) >> 8] &= V[(opcode & 0x00f0) >> 4];
.LINE 225

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-28),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-28)
	LD	A,(HL)
	AND	A,(IY)
	LD	HL,(IX+-28)
	LD	(HL),A
;  226							break;
.LINE 226

	JR	L_50
;  227						}
;  228						case 0x0003: {
L_40:
.LINE 228

;  229							V[(opcode & 0x0f00) >> 8] ^= V[(opcode & 0x00f0) >> 4];
.LINE 229

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-31),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-31)
	LD	A,(HL)
	XOR	A,(IY)
	LD	HL,(IX+-31)
	LD	(HL),A
;  230							break;
.LINE 230

	JR	L_50
;  231						}
;  232						case 0x0004: {
L_41:
.LINE 232

;  233							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 233

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-15),A
;  234							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 234

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-4),A
;  235							V[0xf] = (V[x] + V[y] > 0xff);
.LINE 235

	LD	A,(IX+-15)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-34),HL
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-34)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,HL
	LD	HL,255
	OR	A,A
	SBC	HL,BC
	JP	P,L__18
	LD	A,1
	JR	L__19
L__18:
	XOR	A,A
L__19:
	LD	HL,_V+15
	LD	(HL),A
;  236							V[x] += V[y];
.LINE 236

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-34)
	LD	(IX+-58),HL	; spill
	LD	HL,(IX+-34)
	LD	(IX+-67),HL	; spill
	LD	HL,(IX+-58)	; unspill
	LD	A,(HL)
	ADD	A,(IY)
	LD	HL,(IX+-67)	; unspill
	LD	(HL),A
;  237							break;
.LINE 237

	JR	L_50
;  238						}
;  239						case 0x0005: {
L_42:
.LINE 239

;  240							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 240

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-10),A
;  241							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 241

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-5),A
;  242							V[0xf] = V[x] > V[y];
.LINE 242

	LD	A,(IX+-10)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-37),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-37)
	LD	A,(HL)
	CP	A,(IY)
	JR	NC,L__21
	LD	A,1
	JR	L__22
L__21:
	XOR	A,A
L__22:
	LD	HL,_V+15
	LD	(HL),A
;  243							V[x] -= V[y];
.LINE 243

	LD	IY,(IX+-37)
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(IX+-58),HL	; spill
	LD	HL,(IX+-37)
	LD	(IX+-64),HL	; spill
	LD	HL,(IX+-58)	; unspill
	LD	A,(IY)
	SUB	A,(HL)
	LD	HL,(IX+-64)	; unspill
	LD	(HL),A
;  244							break;
.LINE 244

	JR	L_50
;  245						}
;  246						case 0x0006: {
L_43:
.LINE 246

;  247							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 247

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-8),A
;  248							const uint8_t y = (opcode & 0x00f0) >> 4;
;  249							V[0xf] = V[x] & 1;
.LINE 249

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-40),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,_V+15
	LD	(HL),A
;  250							V[x] >>= 1;
.LINE 250

	LD	HL,(IX+-40)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,1
	CALL	__ishrs_b
	LD	IY,(IX+-40)
	LD	(IY),L
;  251							break;
.LINE 251

	JR	L_50
;  252						}
;  253						case 0x0007: {
L_44:
.LINE 253

;  254							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 254

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-9),A
;  255							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 255

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-6),A
;  256							V[0xf] = V[y] > V[x];
.LINE 256

	LD	A,(IX+-9)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-43),HL
	LD	A,(IX+-6)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-43)
	LD	A,(IY)
	CP	A,(HL)
	JR	NC,L__24
	LD	A,1
	JR	L__25
L__24:
	XOR	A,A
L__25:
	LD	HL,_V+15
	LD	(HL),A
;  257							V[x] = V[y] - V[x];
.LINE 257

	LD	A,(IX+-6)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-43)
	LD	(IX+-58),HL	; spill
	LD	HL,(IX+-43)
	LD	(IX+-61),HL	; spill
	LD	HL,(IX+-58)	; unspill
	LD	A,(HL)
	SUB	A,(IY)
	LD	HL,(IX+-61)	; unspill
	LD	(HL),A
;  258							break;
.LINE 258

	JR	L_50
;  259						}
;  260						case 0x000E: {
L_45:
.LINE 260

;  261							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 261

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-11),A
;  262							const uint8_t y = (opcode & 0x00f0) >> 4;
;  263							V[0xf] = V[x] >> 7;
.LINE 263

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-46),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,7
	CALL	__ishrs_b
	LD	IY,_V
	LD	(IY+15),L
;  264							V[x] <<= 1;
.LINE 264

	LD	HL,(IX+-46)
	LD	A,(HL)
	ADD	A,A
	LD	HL,(IX+-46)
	LD	(HL),A
;  265							break;
.LINE 265

;  266						}
;  267						break;
;  268					}
;  269				}
L_50:
.LINE 269

;  270				case 0x9000: {
L_46:
.LINE 270

;  271					if(V[(opcode & 0x0f00) >> 8] != V[(opcode & 0x00f0) >> 4] && (opcode & 0x000f) == 0)
.LINE 271

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_99
	LD	A,(_opcode)
	AND	A,15
	LD	C,A
	LD	B,0
	LD	HL,BC
	CALL	__scmpzero
	JR	NZ,L_99
;  272						pc += 2;
.LINE 272

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  273					break;
.LINE 273

	JR	L_99
;  274				}
;  275				case 0xa000: {
L_51:
.LINE 275

;  276					I = (opcode & 0x0fff);
.LINE 276

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  277					break;
.LINE 277

	JR	L_99
;  278				}
;  279				case 0xb000: {
L_52:
.LINE 279

;  280					pc = V[0] + (opcode & 0x0fff);
.LINE 280

	LD	A,(_V)
	LD	C,A
	LD	B,0
	LD	DE,BC
	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  281					break;
.LINE 281

	JR	L_99
;  282				}
;  283				case 0xc000: {
L_53:
.LINE 283

;  284					V[(opcode & 0x0f00) >> 8] = (rand() % 256) & (opcode & 0x00FF);
.LINE 284

	LD	A,(_opcode)
	LD	D,A
	LD	(IX+-70),DE
	LD	(IX+-71),D
	CALL	_rand
	LD	DE,(IX+-70)
	LD	D,(IX+-71)
	LD	BC,256
	CALL	__irems
	LD	A,D
	AND	A,L
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  285					break;
.LINE 285

	JR	L_99
;  286				}
;  287				case 0xd000: {
L_54:
.LINE 287

;  288					const uint8_t x = V[(opcode & 0x0f00) >> 8];
.LINE 288

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-12),A
;  289					const uint8_t y = V[(opcode & 0x00f0) >> 4];
.LINE 289

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-13),A
;  290					const uint8_t height = (opcode & 0x000f);
.LINE 290

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-14),A
;  291					
;  292					V[0xf] = 0;
.LINE 292

	LD	HL,_V+15
	LD	(HL),0
;  293					
;  294					for(_y = 0; _y < height; ++_y) {
.LINE 294

	XOR	A,A
	LD	(__y),A
	JR	L_61
L_59:
;  295						pixel = memory[I + _y];
.LINE 295

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,HL
	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(HL)
	LD	(_pixel),A
;  296						for(_x = 0; _x < 8; ++_x) {
.LINE 296

	XOR	A,A
	LD	(__x),A
	JR	L_58
L_56:
;  297							if((pixel & (0x80 >> _x)) != 0) {
.LINE 297

	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,128
	CALL	__ishrs
	LD	BC,(_pixel)
	LD	A,L
	AND	A,C
	JR	Z,L_57
;  298								index = (((x + _x) + ((y + _y) << 6)) % 2048) + 2;
.LINE 298

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	A,(IX+-13)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-12)
	UEXT	HL
	LD	L,A
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,2048
	CALL	__irems
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  299								V[0xf] |= canvas_data[index] & 1;
.LINE 299

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-52),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(IX+-49),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-52)
	OR	A,(HL)
	LD	HL,(IX+-52)
	LD	(HL),A
;  300								canvas_data[index] = ~canvas_data[index];
.LINE 300

	LD	HL,(IX+-49)
	LD	A,(HL)
	CPL	
	LD	HL,(IX+-49)
	LD	(HL),A
;  301							}
;  302						}
L_57:
.LINE 302

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_58:
	LD	A,(__x)
	CP	A,8
	JR	C,L_56
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  303					}
L_61:
.LINE 303

	LD	A,(__y)
	CP	A,(IX+-14)
	JR	C,L_59
;  304					
;  305					drawFlag = true;
.LINE 305

	LD	A,1
	LD	(_drawFlag),A
;  306					
;  307					break;
.LINE 307

	JR	L_99
;  308				}
;  309				case 0xe000: {
L_63:
.LINE 309

;  310					switch(opcode & 0x00ff) {
.LINE 310

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__31:
	DW	2
	DB	158
	DW24	L_64	

	DB	161
	DW24	L_67	

	DW24	L_99	

;  311						case 0x009e: {
L_64:
.LINE 311

;  312							if(keys[V[(opcode & 0x0f00) >> 8]])
.LINE 312

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_99
;  313								pc += 2;
.LINE 313

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  314							break;
.LINE 314

	JR	L_99
;  315						}
;  316						case 0x00a1: {
L_67:
.LINE 316

;  317							if(!keys[V[(opcode & 0x0f00) >> 8]])
.LINE 317

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_99
;  318								pc += 2;
.LINE 318

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  319							break;
.LINE 319

	JR	L_99
;  320						}
;  321					}
;  322					break;
;  323				}
;  324				case 0xf000: {
L_71:
.LINE 324

;  325					switch(opcode & 0x00ff) {
.LINE 325

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__34:
	DW	9
	DB	7
	DW24	L_72	

	DB	10
	DW24	L_73	

	DB	21
	DW24	L_80	

	DB	24
	DW24	L_82	

	DB	30
	DW24	L_83	

	DB	41
	DW24	L_84	

	DB	51
	DW24	L_85	

	DB	85
	DW24	L_86	

	DB	101
	DW24	L_91	

	DW24	L_99	

;  326						case 0x0007: {
L_72:
.LINE 326

;  327							V[(opcode & 0x0f00) >> 8] = delay_timer;
.LINE 327

	LD	A,(_delay_timer)
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  328							break;
.LINE 328

	JR	L_99
;  329						}
;  330						case 0x000A: {
L_73:
.LINE 330

;  331							bool key_pressed = false;
.LINE 331

	LD	(IX+-7),0
;  332							pc -= 2;
.LINE 332

	LD	IY,(_pc)
	LEA	BC,IY+-2
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  333							
;  334							for(i = 0; i < 16; ++i) {
.LINE 334

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_77
L_75:
;  335								if(keys[i]) {
.LINE 335

	LD	BC,_keys
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_76
;  336									V[(opcode & 0x0f00) >> 8] = i;
.LINE 336

	LD	D,(IX+-3)
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  337									pc += 2;
.LINE 337

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  338									key_pressed = true;
.LINE 338

	LD	(IX+-7),1
;  339									break;
.LINE 339

	JR	L_79
;  340								}
;  341							}
L_76:
.LINE 341

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_77:
	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_75
L_79:
;  342							
;  343							if(!key_pressed)
.LINE 343

	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_105
;  344								return;
.LINE 344

;  345						}
.LINE 345

;  346						case 0x0015: {
L_80:
.LINE 346

;  347							delay_timer = V[(opcode & 0x0f00) >> 8];
.LINE 347

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  348							break;
.LINE 348

	JR	L_99
;  349						}
;  350						case 0x0018: {
L_82:
.LINE 350

;  351							sound_timer = V[(opcode & 0x0f00) >> 8];
.LINE 351

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  352							break;
.LINE 352

	JR	L_99
;  353						}
;  354						case 0x001E: {
L_83:
.LINE 354

;  355							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 355

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-16),A
;  356							//V[0xf] = (I > 0xfff - V[x]);
;  357							I += V[x];
.LINE 357

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	DE,(_I)
	LD	HL,BC
	ADD.SIS	HL,DE
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  358							break;
.LINE 358

	JR	L_99
;  359						}
;  360						case 0x0029: {
L_84:
.LINE 360

;  361							I = V[(opcode & 0x0f00) >> 8] * 5;
.LINE 361

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD.LIS	HL,5
	CALL	__smulu
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  362							break;
.LINE 362

	JR	L_99
;  363						}
;  364						case 0x0033: {
L_85:
.LINE 364

;  365							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 365

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-17),A
;  366							memory[ I ] =  V[x] / 100;
.LINE 366

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-55),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,100
	CALL	__idivs
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  367							memory[I+1] = (V[x] / 10) % 10;
.LINE 367

	LD	HL,(IX+-55)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  368							memory[I+2] = V[x] % 10;
.LINE 368

	LD	HL,(IX+-55)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  369							break;
.LINE 369

	JR	L_99
;  370						}
;  371						case 0x0055: {
L_86:
.LINE 371

;  372							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 372

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-18),A
;  373							for(i = 0; i <= x; ++i) {
.LINE 373

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_89
L_87:
;  374								memory[I + i] = V[i];
.LINE 374

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  375							}
L_89:
.LINE 375

	LD	A,(IX+-18)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	P,L_87
;  376							//I += x + 1;
;  377							break;
.LINE 377

	JR	L_99
;  378						}
;  379						case 0x0065: {
L_91:
.LINE 379

;  380							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 380

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-19),A
;  381							for(i = 0; i <= x; ++i) {
.LINE 381

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_94
L_92:
;  382								V[i] = memory[I + i];
.LINE 382

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  383							}
L_94:
.LINE 383

	LD	A,(IX+-19)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_92
;  384							//I += x + 1;
;  385							break;
;  386						}
;  387					}
;  388					break;
;  389				}
;  390				default:
;  391					break;
;  392			}
L_99:
.LINE 392

;  393			if(sound_timer > 0) {
.LINE 393

	LD	BC,(_sound_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_101
;  394				--sound_timer;
.LINE 394

	LD	BC,(_sound_timer)
	DEC	BC
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  395			}
L_101:
.LINE 395

;  396			if(delay_timer > 0) {
.LINE 396

	LD	BC,(_delay_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_103
;  397				--delay_timer;
.LINE 397

	LD	BC,(_delay_timer)
	DEC	BC
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  398			}
;  399		}
L_103:
.LINE 399

	LD	A,(_step)
	INC	A
	LD	(_step),A
L_104:
	LD	A,(_step)
	CP	A,(IX+6)
	JR	C,L_102
;  400	}
L_105:
.LINE 400

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emulateCycle ***************************
;Name                         Addr/Register   Size   Type
;_sound_timer                        STATIC      2   variable
;_delay_timer                        STATIC      2   variable
;_keys                               STATIC     16   variable
;_index                              STATIC      2   variable
;__x                                 STATIC      1   variable
;_pixel                              STATIC      1   variable
;__y                                 STATIC      1   variable
;_rand                               IMPORT  -----   function
;_I                                  STATIC      2   variable
;_V                                  STATIC     16   variable
;_stack                              STATIC     32   variable
;_sp                                 STATIC      1   variable
;_drawFlag                           STATIC      1   variable
;_canvas_data                        IMPORT   2050   variable
;_memset                             IMPORT  -----   function
;_opcode                             STATIC      2   variable
;_pc                                 STATIC      2   variable
;_memory                             STATIC   4096   variable
;_step                               STATIC      1   variable
;_setKeys                            IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;x                                    IX-19      1   variable
;x                                    IX-18      1   variable
;x                                    IX-17      1   variable
;x                                    IX-16      1   variable
;x                                    IX-15      1   variable
;height                               IX-14      1   variable
;y                                    IX-13      1   variable
;x                                    IX-12      1   variable
;x                                    IX-11      1   variable
;x                                    IX-10      1   variable
;x                                     IX-9      1   variable
;x                                     IX-8      1   variable
;key_pressed                           IX-7      1   variable
;y                                     IX-6      1   variable
;y                                     IX-5      1   variable
;y                                     IX-4      1   variable
;i                                     IX-3      3   variable
;steps                                 IX+6      1   parameter


; Stack Frame Size: 80 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emulateCycle",400,"_emulateCycle"
	XREF _canvas_data:ROM
	XREF _kb_Scan:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _sprintf:ROM
	XREF _ti_GetSize:ROM
	XREF _ti_Read:ROM
	XREF _ti_Open:ROM
	XREF _ti_CloseAll:ROM
	XREF _rand:ROM
	XREF _srand:ROM
	XREF __idivs:ROM
	XREF __sor:ROM
	XREF __sand:ROM
	XREF __iand:ROM
	XREF __smulu:ROM
	XREF __irems:ROM
	XREF __ishrs:ROM
	XREF __stoiu:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __case8D:ROM
	XREF __case16D:ROM
	XREF __ishrs_b:ROM
	XREF __sshru_b:ROM
	XDEF _emulateCycle
	XDEF _setKeys
	XDEF _loadProgram
	XDEF _initialize
	XDEF __x
	XDEF __y
	XDEF _index
	XDEF _pixel
	XDEF _step
	XDEF _fontset
	XDEF _file
	XDEF _controlMap
	XDEF _keypad
	XDEF _game_data
	XDEF _playing
	XDEF _paused
	XDEF _drawFlag
	XDEF _keys
	XDEF _sp
	XDEF _stack
	XDEF _sound_timer
	XDEF _delay_timer
	XDEF _pc
	XDEF _I
	XDEF _V
	XDEF _memory
	XDEF _opcode
	END
