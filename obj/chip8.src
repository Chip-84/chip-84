; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\CHIP8.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME1"
.TYPE 104
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME7"
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME8",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME10"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME10",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME10"
.BEGREC "__stdio_file",1
.DEFINE "slot"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "__stdio_file"
	SEGMENT DATA
_opcode:
	DW	0
.DEFINE "opcode"
.ALIAS "_opcode"
.CLASS 69
.VALUE _opcode
.TYPE 13
.ENDEF
	SEGMENT BSS
_memory:
	DS	4096
.DEFINE "memory"
.ALIAS "_memory"
.CLASS 83
.VALUE _memory
.DIM 4096
.TYPE 108
.ENDEF
_SV:
	DS	8
.DEFINE "SV"
.ALIAS "_SV"
.CLASS 83
.VALUE _SV
.DIM 8
.TYPE 108
.ENDEF
_V:
	DS	16
.DEFINE "V"
.ALIAS "_V"
.CLASS 83
.VALUE _V
.DIM 16
.TYPE 108
.ENDEF
	SEGMENT DATA
_I:
	DW	0
.DEFINE "I"
.ALIAS "_I"
.CLASS 69
.VALUE _I
.TYPE 13
.ENDEF
_pc:
	DW	0
.DEFINE "pc"
.ALIAS "_pc"
.CLASS 69
.VALUE _pc
.TYPE 13
.ENDEF
_delay_timer:
	DW	0
.DEFINE "delay_timer"
.ALIAS "_delay_timer"
.CLASS 69
.VALUE _delay_timer
.TYPE 3
.ENDEF
_sound_timer:
	DW	0
.DEFINE "sound_timer"
.ALIAS "_sound_timer"
.CLASS 69
.VALUE _sound_timer
.TYPE 3
.ENDEF
	SEGMENT BSS
_stack:
	DS	32
.DEFINE "stack"
.ALIAS "_stack"
.CLASS 83
.VALUE _stack
.DIM 16
.TYPE 109
.ENDEF
	SEGMENT DATA
_sp:
	DB	0
.DEFINE "sp"
.ALIAS "_sp"
.CLASS 69
.VALUE _sp
.TYPE 12
.ENDEF
_keys:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
.DEFINE "keys"
.ALIAS "_keys"
.CLASS 69
.VALUE _keys
.DIM 16
.TYPE 108
.ENDEF
_drawFlag:
	DB	0
.DEFINE "drawFlag"
.ALIAS "_drawFlag"
.CLASS 69
.VALUE _drawFlag
.TYPE 12
.ENDEF
_paused:
	DB	0
.DEFINE "paused"
.ALIAS "_paused"
.CLASS 69
.VALUE _paused
.TYPE 12
.ENDEF
_playing:
	DB	0
.DEFINE "playing"
.ALIAS "_playing"
.CLASS 69
.VALUE _playing
.TYPE 12
.ENDEF
_extendedScreen:
	DB	0
.DEFINE "extendedScreen"
.ALIAS "_extendedScreen"
.CLASS 69
.VALUE _extendedScreen
.TYPE 12
.ENDEF
	SEGMENT BSS
_game_data:
	DS	3584
.DEFINE "game_data"
.ALIAS "_game_data"
.CLASS 83
.VALUE _game_data
.DIM 3584
.TYPE 108
.ENDEF
_keypad:
	DS	16
.DEFINE "keypad"
.ALIAS "_keypad"
.CLASS 83
.VALUE _keypad
.DIM 16
.TYPE 108
.ENDEF
_controlMap:
	DS	16
.DEFINE "controlMap"
.ALIAS "_controlMap"
.CLASS 83
.VALUE _controlMap
.DIM 16
.TYPE 108
.ENDEF
_file:
	DS	1
.DEFINE "file"
.ALIAS "_file"
.CLASS 83
.VALUE _file
.TYPE 12
.ENDEF
	SEGMENT DATA
_fontset:
	DB	240
	DB	144
	DB	144
	DB	144
	DB	240
	DB	32
	DB	96
	DB	32
	DB	32
	DB	112
	DB	240
	DB	16
	DB	240
	DB	128
	DB	240
	DB	240
	DB	16
	DB	240
	DB	16
	DB	240
	DB	144
	DB	144
	DB	240
	DB	16
	DB	16
	DB	240
	DB	128
	DB	240
	DB	16
	DB	240
	DB	240
	DB	128
	DB	240
	DB	144
	DB	240
	DB	240
	DB	16
	DB	32
	DB	64
	DB	64
	DB	240
	DB	144
	DB	240
	DB	144
	DB	240
	DB	240
	DB	144
	DB	240
	DB	16
	DB	240
	DB	240
	DB	144
	DB	240
	DB	144
	DB	144
	DB	224
	DB	144
	DB	224
	DB	144
	DB	224
	DB	240
	DB	128
	DB	128
	DB	128
	DB	240
	DB	224
	DB	144
	DB	144
	DB	144
	DB	224
	DB	240
	DB	128
	DB	240
	DB	128
	DB	240
	DB	240
	DB	128
	DB	240
	DB	128
	DB	128
.DEFINE "fontset"
.ALIAS "_fontset"
.CLASS 69
.VALUE _fontset
.DIM 80
.TYPE 108
.ENDEF
_fontset_ten:
	DW	50812
	DW	57038
	DW	63190
	DW	50918
	DW	124
	DW	12304
	DW	12528
	DW	12336
	DW	12336
	DW	252
	DW	52344
	DW	3276
	DW	12312
	DW	52320
	DW	252
	DW	52344
	DW	3084
	DW	3128
	DW	52236
	DW	120
	DW	7180
	DW	27708
	DW	65228
	DW	3084
	DW	30
	DW	49404
	DW	49344
	DW	3320
	DW	52236
	DW	120
	DW	24632
	DW	49344
	DW	52472
	DW	52428
	DW	120
	DW	50942
	DW	1734
	DW	6156
	DW	12336
	DW	48
	DW	52344
	DW	60620
	DW	56440
	DW	52428
	DW	120
	DW	50812
	DW	50886
	DW	3198
	DW	12312
	DW	112
	DW	30768
	DW	52428
	DW	64716
	DW	52428
	DW	204
	DW	26364
	DW	26214
	DW	26236
	DW	26214
	DW	252
	DW	26172
	DW	49350
	DW	49344
	DW	26310
	DW	60
	DW	27896
	DW	26214
	DW	26214
	DW	27750
	DW	248
	DW	25342
	DW	25696
	DW	25724
	DW	25184
	DW	254
	DW	26366
	DW	25698
	DW	25724
	DW	24672
	DW	240
.DEFINE "fontset_ten"
.ALIAS "_fontset_ten"
.CLASS 69
.VALUE _fontset_ten
.DIM 80
.TYPE 109
.ENDEF
	SEGMENT BSS
_step:
	DS	1
.DEFINE "step"
.ALIAS "_step"
.CLASS 83
.VALUE _step
.TYPE 12
.ENDEF
_pixel:
	DS	2*1
.DEFINE "pixel"
.ALIAS "_pixel"
.CLASS 83
.VALUE _pixel
.TYPE 13
.ENDEF
_index:
	DS	2*1
.DEFINE "index"
.ALIAS "_index"
.CLASS 83
.VALUE _index
.TYPE 13
.ENDEF
__y:
	DS	1
.DEFINE "_y"
.ALIAS "__y"
.CLASS 83
.VALUE __y
.TYPE 12
.ENDEF
__x:
	DS	1
.DEFINE "_x"
.ALIAS "__x"
.CLASS 83
.VALUE __x
.TYPE 12
.ENDEF
_screen_width:
	DS	1
.DEFINE "screen_width"
.ALIAS "_screen_width"
.CLASS 83
.VALUE _screen_width
.TYPE 12
.ENDEF
_screen_height:
	DS	1
.DEFINE "screen_height"
.ALIAS "_screen_height"
.CLASS 83
.VALUE _screen_height
.TYPE 12
.ENDEF
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <debug.h>
;    6	
;    7	#include <math.h>
;    8	#include <stdio.h>
;    9	#include <stdlib.h>
;   10	#include <string.h>
;   11	
;   12	#include <fileioc.h>
;   13	#include <keypadc.h>
;   14	
;   15	#include "chip8.h"
;   16	#include "sprites_gfx.h"
;   17	
;   18	uint16_t opcode = 0;
;   19	uint8_t memory[4096];
;   20	uint8_t SV[8];
;   21	uint8_t V[16];
;   22	uint16_t I = 0;
;   23	uint16_t pc = 0;
;   24	int16_t delay_timer = 0;
;   25	int16_t sound_timer = 0;
;   26	uint16_t stack[16];
;   27	uint8_t sp = 0;
;   28	uint8_t keys[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;   29	bool drawFlag = false;
;   30	
;   31	bool paused = false;
;   32	bool playing = false;
;   33	bool extendedScreen = 0;
;   34	
;   35	uint8_t game_data[3584];
;   36	uint8_t keypad[16];
;   37	uint8_t controlMap[16];
;   38	
;   39	ti_var_t file;
;   40	
;   41	unsigned char fontset[80] = {
;   42	    0xF0, 0x90, 0x90, 0x90, 0xF0, //0
;   43	    0x20, 0x60, 0x20, 0x20, 0x70, //1
;   44	    0xF0, 0x10, 0xF0, 0x80, 0xF0, //2
;   45	    0xF0, 0x10, 0xF0, 0x10, 0xF0, //3
;   46	    0x90, 0x90, 0xF0, 0x10, 0x10, //4
;   47	    0xF0, 0x80, 0xF0, 0x10, 0xF0, //5
;   48	    0xF0, 0x80, 0xF0, 0x90, 0xF0, //6
;   49	    0xF0, 0x10, 0x20, 0x40, 0x40, //7
;   50	    0xF0, 0x90, 0xF0, 0x90, 0xF0, //8
;   51	    0xF0, 0x90, 0xF0, 0x10, 0xF0, //9
;   52	    0xF0, 0x90, 0xF0, 0x90, 0x90, //A
;   53	    0xE0, 0x90, 0xE0, 0x90, 0xE0, //B
;   54	    0xF0, 0x80, 0x80, 0x80, 0xF0, //C
;   55	    0xE0, 0x90, 0x90, 0x90, 0xE0, //D
;   56	    0xF0, 0x80, 0xF0, 0x80, 0xF0, //E
;   57	    0xF0, 0x80, 0xF0, 0x80, 0x80  //F
;   58	};
;   59	uint16_t  fontset_ten[80] = {
;   60		0xC67C, 0xDECE, 0xF6D6, 0xC6E6, 0x007C, // 0
;   61		0x3010, 0x30F0, 0x3030, 0x3030, 0x00FC, // 1
;   62		0xCC78, 0x0CCC, 0x3018, 0xCC60, 0x00FC, // 2
;   63		0xCC78, 0x0C0C, 0x0C38, 0xCC0C, 0x0078, // 3
;   64		0x1C0C, 0x6C3C, 0xFECC, 0x0C0C, 0x001E, // 4
;   65		0xC0FC, 0xC0C0, 0x0CF8, 0xCC0C, 0x0078, // 5
;   66		0x6038, 0xC0C0, 0xCCF8, 0xCCCC, 0x0078, // 6
;   67		0xC6FE, 0x06C6, 0x180C, 0x3030, 0x0030, // 7
;   68		0xCC78, 0xECCC, 0xDC78, 0xCCCC, 0x0078, // 8
;   69		0xC67C, 0xC6C6, 0x0C7E, 0x3018, 0x0070, // 9
;   70		0x7830, 0xCCCC, 0xFCCC, 0xCCCC, 0x00CC, // A
;   71		0x66FC, 0x6666, 0x667C, 0x6666, 0x00FC, // B
;   72		0x663C, 0xC0C6, 0xC0C0, 0x66C6, 0x003C, // C
;   73		0x6CF8, 0x6666, 0x6666, 0x6C66, 0x00F8, // D
;   74		0x62FE, 0x6460, 0x647C, 0x6260, 0x00FE, // E
;   75		0x66FE, 0x6462, 0x647C, 0x6060, 0x00F0  // F
;   76	};
;   77	
;   78	uint8_t step;
;   79	uint16_t pixel;
;   80	uint16_t index;
;   81	
;   82	uint8_t _y;
;   83	uint8_t _x;
;   84	
;   85	uint8_t screen_width;
;   86	uint8_t screen_height;
	SEGMENT CODE
;   87	
;   88	void initialize() {
_initialize:
.DEFINE "_initialize"

.VALUE _initialize

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initialize",88,"_initialize"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   89		
;   90		opcode = I = sp = delay_timer = sound_timer = 0;
.LINE 90

	LD	HL,_sound_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_delay_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	XOR	A,A
	LD	(_sp),A
	LD	HL,_I
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_opcode
	LD	(HL),0
	INC	HL
	LD	(HL),0
;   91		pc = 0x200;
.LINE 91

	LD	HL,_pc
	LD	(HL),0
	INC	HL
	LD	(HL),2
;   92		
;   93		extendedScreen = 0;
.LINE 93

	XOR	A,A
	LD	(_extendedScreen),A
;   94		screen_width = 64;
.LINE 94

	LD	A,64
	LD	(_screen_width),A
;   95		screen_height = 32;
.LINE 95

	LD	A,32
	LD	(_screen_height),A
;   96		
;   97		scanvas_data[0] = 128;
.LINE 97

	LD	A,128
	LD	(_scanvas_data),A
;   98		scanvas_data[1] = 64;
.LINE 98

	LD	HL,_scanvas_data
	INC	HL
	LD	(HL),64
;   99		memset(scanvas_data + 2, 0, 8192);
.LINE 99

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  100	
;  101		canvas_data[0] = 64;
.LINE 101

	LD	A,64
	LD	(_canvas_data),A
;  102		canvas_data[1] = 32;
.LINE 102

	LD	HL,_canvas_data
	INC	HL
	LD	(HL),32
;  103		memset(canvas_data + 2, 0, 2048);
.LINE 103

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  104			
;  105		memset(keys, 0, 16);
.LINE 105

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_keys
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  106		memset(stack, 0, 16);
.LINE 106

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_stack
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  107		memset(V, 0, 16);
.LINE 107

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_V
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  108		memset(SV, 0, 8);
.LINE 108

	LD	BC,8
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_SV
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  109		memset(memory, 0, 4096);
.LINE 109

	LD	BC,4096
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  110		
;  111		memcpy(memory, fontset, 80);
.LINE 111

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  112		memcpy(memory + 80, fontset_ten, 80);
.LINE 112

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset_ten
	PUSH	BC
	LD	BC,_memory+80
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  113		
;  114		srand(rtc_Time());
.LINE 114

	LD	BC,(15925316)
	PUSH	BC
	CALL	_srand
	POP	BC
;  115	}
.LINE 115

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initialize ***************************
;Name                         Addr/Register   Size   Type
;_srand                              IMPORT  -----   function
;_fontset_ten                        STATIC    160   variable
;_fontset                            STATIC     80   variable
;_memcpy                             IMPORT  -----   function
;_memory                             STATIC   4096   variable
;_SV                                 STATIC      8   variable
;_V                                  STATIC     16   variable
;_stack                              STATIC     32   variable
;_keys                               STATIC     16   variable
;_canvas_data                        IMPORT   2050   variable
;_memset                             IMPORT  -----   function
;_scanvas_data                       IMPORT   8194   variable
;_screen_height                      STATIC      1   variable
;_screen_width                       STATIC      1   variable
;_extendedScreen                     STATIC      1   variable
;_pc                                 STATIC      2   variable
;_opcode                             STATIC      2   variable
;_I                                  STATIC      2   variable
;_sp                                 STATIC      1   variable
;_delay_timer                        STATIC      2   variable
;_sound_timer                        STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initialize",115,"_initialize"
;  116	
;  117	void loadProgram(char *fileName) {
_loadProgram:
.DEFINE "_loadProgram"

.VALUE _loadProgram

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "loadProgram",117,"_loadProgram"

.LINE 117

.DEFINE "fileName"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "romSize"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;  118		int i;
;  119		uint16_t romSize;
;  120		
;  121		playing = true;
.LINE 121

	LD	A,1
	LD	(_playing),A
;  122		paused = false;
.LINE 122

	XOR	A,A
	LD	(_paused),A
;  123		
;  124		ti_CloseAll();
.LINE 124

	CALL	_ti_CloseAll
;  125		file = ti_Open(fileName, "r");
.LINE 125

	LD	BC,L__1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(_file),A
;  126		ti_Read(&game_data, ti_GetSize(file), 1, file);
.LINE 126

	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	PUSH	HL
	LD	BC,_game_data
	PUSH	BC
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  127		
;  128		romSize = ti_GetSize(file)-(16+6);
.LINE 128

	LD	A,(_file)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	IY,HL
	LEA	HL,IY+-22
	LD	(IX+-5),L
	LD	(IX+-4),H
;  129		dbg_sprintf(dbgout, "%d ", romSize);
.LINE 129

	LD	BC,(IX+-5)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__2
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  130		
;  131		initialize();
.LINE 131

	CALL	_initialize
;  132		
;  133		if((4096-512) > romSize) {
.LINE 133

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,3584
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_9
;  134			for(i = 0; i < romSize; ++i) {
.LINE 134

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
;  135				memory[i + 512] = (uint8_t)game_data[i+16+6];
.LINE 135

	LD	IY,(IX+-3)
	LEA	HL,IY+22
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,512
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  136			}
L_3:
.LINE 136

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
;  137		}
L_9:
.LINE 137

;  138		for(i = 0; i < 16; i++) {
.LINE 138

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_8
L_6:
;  139			controlMap[i] = (uint8_t)game_data[i+6];
.LINE 139

	LD	IY,(IX+-3)
	LEA	HL,IY+6
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_controlMap
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  140		}
L_8:
.LINE 140

	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_6
;  141	}
.LINE 141

	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadProgram ***************************
;Name                         Addr/Register   Size   Type
;_controlMap                         STATIC     16   variable
;_memory                             STATIC   4096   variable
;_initialize                         IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_game_data                          STATIC   3584   variable
;_ti_GetSize                         IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_file                               STATIC      1   variable
;_ti_Open                            IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_paused                             STATIC      1   variable
;_playing                            STATIC      1   variable
;romSize                               IX-5      2   variable
;i                                     IX-3      3   variable
;fileName                              IX+6      3   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "loadProgram",141,"_loadProgram"
	SEGMENT STRSECT
L__1:
	DB	"r"
	DB	0
L__2:
	DB	"%d "
	DB	0
	SEGMENT CODE
;  142	
;  143	void setKeys() {
_setKeys:
.DEFINE "_setKeys"

.VALUE _setKeys

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setKeys",143,"_setKeys"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  144		keypad[0x0] = kb_Data[4] & kb_DecPnt;
.LINE 144

	LD	A,(16056344)
	AND	A,1
	LD	(_keypad),A
;  145		keypad[0x1] = kb_Data[3] & kb_7;
.LINE 145

	LD	A,(16056342)
	AND	A,8
	LD	HL,_keypad
	INC	HL
	LD	(HL),A
;  146		keypad[0x2] = kb_Data[4] & kb_8;
.LINE 146

	LD	A,(16056344)
	AND	A,8
	LD	IY,_keypad
	LEA	HL,IY+2
	LD	(HL),A
;  147		keypad[0x3] = kb_Data[5] & kb_9;
.LINE 147

	LD	A,(16056346)
	AND	A,8
	LEA	HL,IY+3
	LD	(HL),A
;  148		keypad[0x4] = kb_Data[3] & kb_4;
.LINE 148

	LD	A,(16056342)
	AND	A,4
	LEA	HL,IY+4
	LD	(HL),A
;  149		keypad[0x5] = kb_Data[4] & kb_5;
.LINE 149

	LD	A,(16056344)
	AND	A,4
	LEA	HL,IY+5
	LD	(HL),A
;  150		keypad[0x6] = kb_Data[5] & kb_6;
.LINE 150

	LD	A,(16056346)
	AND	A,4
	LEA	HL,IY+6
	LD	(HL),A
;  151		keypad[0x7] = kb_Data[3] & kb_1;
.LINE 151

	LD	A,(16056342)
	AND	A,2
	LEA	HL,IY+7
	LD	(HL),A
;  152		keypad[0x8] = kb_Data[4] & kb_2;
.LINE 152

	LD	A,(16056344)
	AND	A,2
	LEA	HL,IY+8
	LD	(HL),A
;  153		keypad[0x9] = kb_Data[5] & kb_3;
.LINE 153

	LD	A,(16056346)
	AND	A,2
	LEA	HL,IY+9
	LD	(HL),A
;  154		keypad[0xA] = kb_Data[3] & kb_0;
.LINE 154

	LD	A,(16056342)
	AND	A,1
	LEA	HL,IY+10
	LD	(HL),A
;  155		keypad[0xB] = kb_Data[5] & kb_Chs;
.LINE 155

	LD	A,(16056346)
	AND	A,1
	LEA	HL,IY+11
	LD	(HL),A
;  156		keypad[0xC] = kb_Data[6] & kb_Mul;
.LINE 156

	LD	A,(16056348)
	AND	A,8
	LEA	HL,IY+12
	LD	(HL),A
;  157		keypad[0xD] = kb_Data[6] & kb_Sub;
.LINE 157

	LD	A,(16056348)
	AND	A,4
	LEA	HL,IY+13
	LD	(HL),A
;  158		keypad[0xE] = kb_Data[6] & kb_Add;
.LINE 158

	LD	A,(16056348)
	AND	A,2
	LEA	HL,IY+14
	LD	(HL),A
;  159		keypad[0xF] = kb_Data[6] & kb_Enter;
.LINE 159

	LD	A,(16056348)
	AND	A,1
	LD	HL,_keypad+15
	LD	(HL),A
;  160		
;  161		keys[0x0] = keypad[controlMap[0x0]];
.LINE 161

	LD	A,(_controlMap)
	UEXT	HL
	LD	L,A
	LD	BC,_keypad
	ADD	HL,BC
	LD	A,(HL)
	LD	(_keys),A
;  162		keys[0x1] = keypad[controlMap[0x1]];
.LINE 162

	LD	HL,_controlMap
	INC	HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,_keys
	LD	A,(HL)
	LD	(IY+1),A
;  163		keys[0x2] = keypad[controlMap[0x2]];
.LINE 163

	LD	HL,_controlMap+2
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+2),A
;  164		keys[0x3] = keypad[controlMap[0x3]];
.LINE 164

	LD	HL,_controlMap+3
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+3),A
;  165		                              
;  166		keys[0x4] = keypad[controlMap[0x4]];
.LINE 166

	LD	HL,_controlMap+4
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+4),A
;  167		keys[0x5] = keypad[controlMap[0x5]];
.LINE 167

	LD	HL,_controlMap+5
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+5),A
;  168		keys[0x6] = keypad[controlMap[0x6]];
.LINE 168

	LD	HL,_controlMap+6
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+6),A
;  169		keys[0x7] = keypad[controlMap[0x7]];
.LINE 169

	LD	HL,_controlMap+7
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+7),A
;  170		                              
;  171		keys[0x8] = keypad[controlMap[0x8]];
.LINE 171

	LD	HL,_controlMap+8
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+8),A
;  172		keys[0x9] = keypad[controlMap[0x9]];
.LINE 172

	LD	HL,_controlMap+9
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+9),A
;  173		keys[0xA] = keypad[controlMap[0xA]];
.LINE 173

	LD	HL,_controlMap+10
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+10),A
;  174		keys[0xB] = keypad[controlMap[0xB]];
.LINE 174

	LD	HL,_controlMap+11
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+11),A
;  175		                              
;  176		keys[0xC] = keypad[controlMap[0xC]];
.LINE 176

	LD	HL,_controlMap+12
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+12),A
;  177		keys[0xD] = keypad[controlMap[0xD]];
.LINE 177

	LD	HL,_controlMap+13
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+13),A
;  178		keys[0xE] = keypad[controlMap[0xE]];
.LINE 178

	LD	HL,_controlMap+14
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+14),A
;  179		keys[0xF] = keypad[controlMap[0xF]];
.LINE 179

	LD	HL,_controlMap+15
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+15),A
;  180		
;  181		if(kb_Data[1] & kb_2nd) {
.LINE 181

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_11
	JR	L_15
;  182			while(kb_Data[1] & kb_2nd) {
L_12:
.LINE 182

;  183				kb_Scan();
.LINE 183

	CALL	_kb_Scan
;  184			}
L_11:
.LINE 184

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_12
;  185			paused = 1;
.LINE 185

	LD	A,1
	LD	(_paused),A
;  186		}
;  187	}
L_15:
.LINE 187

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setKeys ***************************
;Name                         Addr/Register   Size   Type
;_paused                             STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_keys                               STATIC     16   variable
;_controlMap                         STATIC     16   variable
;_keypad                             STATIC     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setKeys",187,"_setKeys"
;  188	
;  189	void emulateCycle(uint8_t steps) {
_emulateCycle:
.DEFINE "_emulateCycle"

.VALUE _emulateCycle

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emulateCycle",189,"_emulateCycle"

.LINE 189

.DEFINE "steps"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "cols"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -8

.TYPE 44

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -11

.TYPE 44

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -12

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -13

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -14

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -15

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -16

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -17

.TYPE 12

.ENDEF

.DEFINE "key_pressed"

.CLASS 65

.VALUE -18

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -19

.TYPE 12

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -22

.TYPE 44

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -23

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -24

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -25

.TYPE 12

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -26

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -27

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -28

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -29

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -30

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -31

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -32

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-93
	LD	SP,HL
;  190		
;  191		kb_Scan();
.LINE 191

	CALL	_kb_Scan
;  192		setKeys();
.LINE 192

	CALL	_setKeys
;  193		
;  194		for(step = 0; step < steps; ++step) {
.LINE 194

	XOR	A,A
	LD	(_step),A
	JR	L_178
L_176:
;  195			int i;
;  196			opcode = (memory[pc] << 8) | memory[pc+1];
.LINE 196

	LD	BC,(_pc)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	H,L
	LD	L,0
	LD	DE,HL
	LD	BC,(_pc)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,DE
	CALL	__sor
	LD	BC,HL
	LD	HL,_opcode
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  197			
;  198			pc += 2;
.LINE 198

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  199			
;  200			switch(opcode & 0xf000) {
.LINE 200

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	BC,61440
	CALL	__iand
	CALL	__case16D
	JP	(HL)
L__10:
	DW	16
	DW	0
	DW24	L_16	

	DW	4096
	DW24	L_55	

	DW	8192
	DW24	L_56	

	DW	12288
	DW24	L_58	

	DW	16384
	DW24	L_61	

	DW	20480
	DW24	L_64	

	DW	24576
	DW24	L_68	

	DW	28672
	DW24	L_69	

	DW	32768
	DW24	L_70	

	DW	36864
	DW24	L_81	

	DW	40960
	DW24	L_85	

	DW	45056
	DW24	L_86	

	DW	49152
	DW24	L_87	

	DW	53248
	DW24	L_88	

	DW	57344
	DW24	L_116	

	DW	61440
	DW24	L_124	

	DW24	L_173	

;  201				case 0x0000: {
L_16:
.LINE 201

;  202					switch(opcode & 0x00f0) {
.LINE 202

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,240
	UEXT	HL
	LD	L,A
	LD	BC,192
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_53
;  203						case 0x00c0: {
.LINE 203

;  204							uint8_t n = (opcode & 0x000f);
.LINE 204

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-26),A
;  205							uint8_t *disp;
;  206							
;  207							dbg_sprintf(dbgout, "SCD called\n");
.LINE 207

	LD	BC,L__11
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  208							
;  209							if(extendedScreen) {
.LINE 209

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_19
;  210								disp = &scanvas_data[2];
.LINE 210

	LD	BC,_scanvas_data+2
	LD	(IX+-22),BC
;  211							} else {
.LINE 211

	JR	L_24
L_19:
;  212								disp = &canvas_data[2];
.LINE 212

	LD	BC,_canvas_data+2
	LD	(IX+-22),BC
;  213							}
L_24:
.LINE 213

;  214							for(i = screen_height; i >= 0; i--) {
.LINE 214

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	(IX+-3),HL
	JR	L_23
L_21:
;  215								memcpy(disp + (i+n)*screen_width, disp + i*screen_width, screen_width);
.LINE 215

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-22)
	ADD	HL,BC
	PUSH	HL
	LD	A,(IX+-26)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	DE,HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,(IX+-22)
	ADD	HL,BC
	PUSH	HL
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  216								memset(disp + i*screen_width, 0, screen_width);
.LINE 216

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-22)
	ADD	HL,BC
	PUSH	HL
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
;  217							}
L_23:
.LINE 217

	LD	HL,(IX+-3)
	CALL	__icmpzero
	JP	P,L_21
;  218							
;  219							drawFlag = true; 
.LINE 219

	LD	A,1
	LD	(_drawFlag),A
;  220							
;  221							break;
;  222						}
;  223						break;
;  224					}
L_53:
.LINE 224

;  225					switch(opcode & 0x00ff) {
.LINE 225

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__14:
	DW	7
	DB	224
	DW24	L_26	

	DB	238
	DW24	L_30	

	DB	251
	DW24	L_31	

	DB	252
	DW24	L_40	

	DB	253
	DW24	L_49	

	DB	254
	DW24	L_50	

	DB	255
	DW24	L_51	

	DW24	L_52	

;  226						case 0x00e0:
L_26:
.LINE 226

;  227							if(extendedScreen)
.LINE 227

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_28
;  228								memset(scanvas_data + 2, 0, 8192);
.LINE 228

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  229							else
.LINE 229

	JR	L_29
L_28:
;  230								memset(canvas_data + 2, 0, 2048);
.LINE 230

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
L_29:
;  231							drawFlag = true;
.LINE 231

	LD	A,1
	LD	(_drawFlag),A
;  232							break;
.LINE 232

	JR	L_173
;  233						case 0x00ee:
L_30:
.LINE 233

;  234							pc = stack[(--sp)&0xf];
.LINE 234

	LD	A,(_sp)
	DEC	A
	LD	(_sp),A
	AND	A,15
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	BC,(HL)
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  235							break;
.LINE 235

	JR	L_173
;  236						case 0x00fb: { //SCR
L_31:
.LINE 236

;  237							uint8_t *disp;
;  238							
;  239							if(extendedScreen) {
.LINE 239

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_33
;  240								disp = &scanvas_data[2];
.LINE 240

	LD	BC,_scanvas_data+2
	LD	(IX+-8),BC
;  241							} else {
.LINE 241

	JR	L_38
L_33:
;  242								disp = &canvas_data[2];
.LINE 242

	LD	BC,_canvas_data+2
	LD	(IX+-8),BC
;  243							}
L_38:
.LINE 243

;  244							for(i = 0; i < screen_height; i++) {
.LINE 244

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_37
L_35:
;  245								memcpy(disp + 4, disp, screen_width - 4);
.LINE 245

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	LD	IY,(IX+-8)
	LEA	BC,IY+4
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  246								memset(disp, 0, 4);
.LINE 246

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  247								disp += screen_width;
.LINE 247

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-8)
	ADD	HL,BC
	LD	(IX+-8),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  248							}
L_37:
.LINE 248

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_35
;  249							break;
.LINE 249

	JR	L_173
;  250						}
;  251						case 0x00fc: { //SCL
L_40:
.LINE 251

;  252							uint8_t *disp;
;  253							
;  254							if(extendedScreen) {
.LINE 254

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_42
;  255								disp = &scanvas_data[2];
.LINE 255

	LD	BC,_scanvas_data+2
	LD	(IX+-11),BC
;  256							} else {
.LINE 256

	JR	L_47
L_42:
;  257								disp = &canvas_data[2];
.LINE 257

	LD	BC,_canvas_data+2
	LD	(IX+-11),BC
;  258							}
L_47:
.LINE 258

;  259							for(i = 0; i < screen_height; i++) {
.LINE 259

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_46
L_44:
;  260								memcpy(disp, disp + 4, screen_width - 4);
.LINE 260

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	IY,(IX+-11)
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,(IX+-11)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  261								memset(disp + screen_width - 4, 0, 4);
.LINE 261

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  262								disp += screen_width;
.LINE 262

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	(IX+-11),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  263							}
L_46:
.LINE 263

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_44
;  264							break;
.LINE 264

	JR	L_173
;  265						}
;  266						case 0x00fd:
L_49:
.LINE 266

;  267							playing = 0;
.LINE 267

	XOR	A,A
	LD	(_playing),A
;  268							//exit
;  269							break;
.LINE 269

	JR	L_173
;  270						case 0x00fe:
L_50:
.LINE 270

;  271							extendedScreen = 0;
.LINE 271

	XOR	A,A
	LD	(_extendedScreen),A
;  272							screen_width = 64;
.LINE 272

	LD	A,64
	LD	(_screen_width),A
;  273							screen_height = 32;
.LINE 273

	LD	A,32
	LD	(_screen_height),A
;  274							dbg_sprintf(dbgout, "Extended mode off\n");
.LINE 274

	LD	BC,L__20
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  275							break;
.LINE 275

	JR	L_173
;  276						case 0x00ff:
L_51:
.LINE 276

;  277							extendedScreen = 1;
.LINE 277

	LD	A,1
	LD	(_extendedScreen),A
;  278							screen_width = 128;
.LINE 278

	LD	A,128
	LD	(_screen_width),A
;  279							screen_height = 64;
.LINE 279

	LD	A,64
	LD	(_screen_height),A
;  280							dbg_sprintf(dbgout, "Extended mode on\n");
.LINE 280

	LD	BC,L__21
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  281							break;
.LINE 281

	JR	L_173
;  282						default:
L_52:
.LINE 282

;  283							pc = (pc & 0x0fff);
.LINE 283

	LD	HL,(_pc)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  284							break;
.LINE 284

	JR	L_173
;  285					}
;  286					break;
;  287				}
;  288				case 0x1000: {
L_55:
.LINE 288

;  289					pc = (opcode & 0x0fff);
.LINE 289

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  290					break;
.LINE 290

	JR	L_173
;  291				}
;  292				case 0x2000: {
L_56:
.LINE 292

;  293					stack[sp++] = pc;
.LINE 293

	LD	A,(_sp)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	A,(_pc)
	LD	(HL),A
	INC	HL
	LD	A,(_pc+1)
	LD	(HL),A
	LD	A,(_sp)
	INC	A
	LD	(_sp),A
;  294					pc = (opcode & 0x0fff);
.LINE 294

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  295					break;
.LINE 295

	JR	L_173
;  296				}
;  297				case 0x3000: {
L_58:
.LINE 297

;  298					if(V[(opcode & 0x0f00) >> 8] == (opcode & 0x00ff))
.LINE 298

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_173
;  299						pc += 2;
.LINE 299

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  300					break;
.LINE 300

	JR	L_173
;  301				}
;  302				case 0x4000: {
L_61:
.LINE 302

;  303					if(V[(opcode & 0x0f00) >> 8] != (opcode & 0x00ff))
.LINE 303

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	Z,L_173
;  304						pc += 2;
.LINE 304

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  305					break;
.LINE 305

	JR	L_173
;  306				}
;  307				case 0x5000: {
L_64:
.LINE 307

;  308					if(V[(opcode & 0x0f00) >> 8] == V[(opcode & 0x00f0) >> 4] && (opcode & 0x000f) == 0)
.LINE 308

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	NZ,L_173
	LD	A,(_opcode)
	AND	A,15
	LD	C,A
	LD	B,0
	LD	HL,BC
	CALL	__scmpzero
	JR	NZ,L_173
;  309						pc += 2;
.LINE 309

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  310					break;
.LINE 310

	JR	L_173
;  311				}
;  312				case 0x6000: {
L_68:
.LINE 312

;  313					V[(opcode & 0x0f00) >> 8] = (opcode & 0x00ff);
.LINE 313

	LD	A,(_opcode)
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  314					break;
.LINE 314

	JR	L_173
;  315				}
;  316				case 0x7000: {
L_69:
.LINE 316

;  317					V[(opcode & 0x0f00) >> 8] += (opcode & 0x00ff);
.LINE 317

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-38),HL
	LD	A,(_opcode)
	LD	HL,(IX+-38)
	LD	IY,(IX+-38)
	ADD	A,(HL)
	LD	(IY),A
;  318					break;
.LINE 318

	JR	L_173
;  319				}
;  320				case 0x8000: {
L_70:
.LINE 320

;  321					switch(opcode & 0x000f) {
.LINE 321

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__26:
	DW	9
	DB	0
	DW24	L_71	

	DB	1
	DW24	L_72	

	DB	2
	DW24	L_73	

	DB	3
	DW24	L_74	

	DB	4
	DW24	L_75	

	DB	5
	DW24	L_76	

	DB	6
	DW24	L_77	

	DB	7
	DW24	L_78	

	DB	14
	DW24	L_79	

	DW24	L_173	

;  322						case 0x0000: {
L_71:
.LINE 322

;  323							V[(opcode & 0x0f00) >> 8]  = V[(opcode & 0x00f0) >> 4];
.LINE 323

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
;  324							break;
.LINE 324

	JR	L_173
;  325						}
;  326						case 0x0001: {
L_72:
.LINE 326

;  327							V[(opcode & 0x0f00) >> 8] |= V[(opcode & 0x00f0) >> 4];
.LINE 327

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-41),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-41)
	LD	A,(HL)
	OR	A,(IY)
	LD	HL,(IX+-41)
	LD	(HL),A
;  328							break;
.LINE 328

	JR	L_173
;  329						}
;  330						case 0x0002: {
L_73:
.LINE 330

;  331							V[(opcode & 0x0f00) >> 8] &= V[(opcode & 0x00f0) >> 4];
.LINE 331

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-44),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-44)
	LD	A,(HL)
	AND	A,(IY)
	LD	HL,(IX+-44)
	LD	(HL),A
;  332							break;
.LINE 332

	JR	L_173
;  333						}
;  334						case 0x0003: {
L_74:
.LINE 334

;  335							V[(opcode & 0x0f00) >> 8] ^= V[(opcode & 0x00f0) >> 4];
.LINE 335

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-47),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-47)
	LD	A,(HL)
	XOR	A,(IY)
	LD	HL,(IX+-47)
	LD	(HL),A
;  336							break;
.LINE 336

	JR	L_173
;  337						}
;  338						case 0x0004: {
L_75:
.LINE 338

;  339							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 339

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-23),A
;  340							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 340

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-13),A
;  341							V[0xf] = (V[x] + V[y] > 0xff);
.LINE 341

	LD	A,(IX+-23)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-50),HL
	LD	A,(IX+-13)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-50)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,HL
	LD	HL,255
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L__28
	LD	A,1
	JR	L__29
L__28:
	XOR	A,A
L__29:
	LD	HL,_V+15
	LD	(HL),A
;  342							V[x] += V[y];
.LINE 342

	LD	A,(IX+-13)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-50)
	LD	(IX+-80),HL	; spill
	LD	HL,(IX+-50)
	LD	(IX+-89),HL	; spill
	LD	HL,(IX+-80)	; unspill
	LD	A,(HL)
	ADD	A,(IY)
	LD	HL,(IX+-89)	; unspill
	LD	(HL),A
;  343							break;
.LINE 343

	JR	L_173
;  344						}
;  345						case 0x0005: {
L_76:
.LINE 345

;  346							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 346

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-32),A
;  347							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 347

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-14),A
;  348							V[0xf] = V[x] >= V[y];
.LINE 348

	LD	A,(IX+-32)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-53),HL
	LD	A,(IX+-14)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-53)
	LD	A,(IY)
	CP	A,(HL)
	JR	C,L__31
	LD	A,1
	JR	L__32
L__31:
	XOR	A,A
L__32:
	LD	HL,_V+15
	LD	(HL),A
;  349							V[x] -= V[y];
.LINE 349

	LD	IY,(IX+-53)
	LD	A,(IX+-14)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(IX+-80),HL	; spill
	LD	HL,(IX+-53)
	LD	(IX+-86),HL	; spill
	LD	HL,(IX+-80)	; unspill
	LD	A,(IY)
	SUB	A,(HL)
	LD	HL,(IX+-86)	; unspill
	LD	(HL),A
;  350							break;
.LINE 350

	JR	L_173
;  351						}
;  352						case 0x0006: {
L_77:
.LINE 352

;  353							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 353

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-24),A
;  354							const uint8_t y = (opcode & 0x00f0) >> 4;
;  355							V[0xf] = V[x] & 1;
.LINE 355

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-56),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,_V+15
	LD	(HL),A
;  356							V[x] >>= 1;
.LINE 356

	LD	HL,(IX+-56)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,1
	CALL	__ishrs_b
	LD	IY,(IX+-56)
	LD	(IY),L
;  357							break;
.LINE 357

	JR	L_173
;  358						}
;  359						case 0x0007: {
L_78:
.LINE 359

;  360							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 360

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-25),A
;  361							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 361

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-12),A
;  362							V[0xf] = V[y] >= V[x];
.LINE 362

	LD	A,(IX+-25)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-59),HL
	LD	A,(IX+-12)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-59)
	LD	A,(HL)
	CP	A,(IY)
	JR	C,L__34
	LD	A,1
	JR	L__35
L__34:
	XOR	A,A
L__35:
	LD	HL,_V+15
	LD	(HL),A
;  363							V[x] = V[y] - V[x];
.LINE 363

	LD	A,(IX+-12)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-59)
	LD	(IX+-80),HL	; spill
	LD	HL,(IX+-59)
	LD	(IX+-83),HL	; spill
	LD	HL,(IX+-80)	; unspill
	LD	A,(HL)
	SUB	A,(IY)
	LD	HL,(IX+-83)	; unspill
	LD	(HL),A
;  364							break;
.LINE 364

	JR	L_173
;  365						}
;  366						case 0x000E: {
L_79:
.LINE 366

;  367							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 367

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-31),A
;  368							const uint8_t y = (opcode & 0x00f0) >> 4;
;  369							V[0xf] = V[x] >> 7;
.LINE 369

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-62),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,7
	CALL	__ishrs_b
	LD	IY,_V
	LD	(IY+15),L
;  370							V[x] <<= 1;
.LINE 370

	LD	HL,(IX+-62)
	LD	A,(HL)
	ADD	A,A
	LD	HL,(IX+-62)
	LD	(HL),A
;  371							break;
.LINE 371

	JR	L_173
;  372						}
;  373						break;
;  374					}
;  375					break;
;  376				}
;  377				case 0x9000: {
L_81:
.LINE 377

;  378					if(V[(opcode & 0x0f00) >> 8] != V[(opcode & 0x00f0) >> 4] && (opcode & 0x000f) == 0)
.LINE 378

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_173
	LD	A,(_opcode)
	AND	A,15
	LD	C,A
	LD	B,0
	LD	HL,BC
	CALL	__scmpzero
	JR	NZ,L_173
;  379						pc += 2;
.LINE 379

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  380					break;
.LINE 380

	JR	L_173
;  381				}
;  382				case 0xa000: {
L_85:
.LINE 382

;  383					I = (opcode & 0x0fff);
.LINE 383

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  384					break;
.LINE 384

	JR	L_173
;  385				}
;  386				case 0xb000: {
L_86:
.LINE 386

;  387					pc = V[0] + (opcode & 0x0fff);
.LINE 387

	LD	A,(_V)
	LD	C,A
	LD	B,0
	LD	DE,BC
	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  388					break;
.LINE 388

	JR	L_173
;  389				}
;  390				case 0xc000: {
L_87:
.LINE 390

;  391					V[(opcode & 0x0f00) >> 8] = (rand() % 256) & (opcode & 0x00FF);
.LINE 391

	LD	A,(_opcode)
	LD	D,A
	LD	(IX+-92),DE
	LD	(IX+-93),D
	CALL	_rand
	LD	DE,(IX+-92)
	LD	D,(IX+-93)
	LD	BC,256
	CALL	__irems
	LD	A,D
	AND	A,L
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  392					break;
.LINE 392

	JR	L_173
;  393				}
;  394				case 0xd000: {
L_88:
.LINE 394

;  395					uint8_t x = V[(opcode & 0x0f00) >> 8];
.LINE 395

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-17),A
;  396					uint8_t y = V[(opcode & 0x00f0) >> 4];
.LINE 396

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-19),A
;  397					uint8_t height = (opcode & 0x000f);
.LINE 397

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-4),A
;  398					
;  399					V[0xf] = 0;
.LINE 399

	LD	HL,_V+15
	LD	(HL),0
;  400					
;  401					if(extendedScreen) {
.LINE 401

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_114
;  402						//Extended screen DXY0
;  403						uint8_t cols = 1;
.LINE 403

	LD	(IX+-5),1
;  404						if(height == 0) {
.LINE 404

	LD	A,(IX+-4)
	OR	A,A
	JR	NZ,L_103
;  405							cols = 2;
.LINE 405

	LD	(IX+-5),2
;  406							height = 16;
.LINE 406

	LD	(IX+-4),16
;  407						}
L_103:
.LINE 407

;  408						for(_y = 0; _y < height; ++_y) {
.LINE 408

	XOR	A,A
	LD	(__y),A
	JR	L_102
L_100:
;  409							pixel = memory[I + (cols*_y)];
.LINE 409

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  410							if(cols == 2) {
.LINE 410

	LD	A,(IX+-5)
	CP	A,2
	JR	NZ,L_99
;  411								pixel <<= 8;
.LINE 411

	LD	HL,(_pixel)
	LD	H,L
	LD	L,0
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  412								pixel |= memory[I + (2*_y)+1];
.LINE 412

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	BC,(_pixel)
	CALL	__sor
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  413							}
L_99:
.LINE 413

;  414							for(_x = 0; _x < 8*cols; ++_x) {
.LINE 414

	XOR	A,A
	LD	(__x),A
	JR	L_98
L_96:
;  415								if((pixel & (((cols == 2) ? 0x8000 : 0x80) >> _x)) != 0) {
.LINE 415

	LD	A,(IX+-5)
	CP	A,2
	JR	NZ,L_93
	LD	BC,32768
	LD	(IX+-35),BC
	JR	L_94
L_93:
	LD	BC,128
	LD	(IX+-35),BC
L_94:
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-35)
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_97
;  416									index = (((x + _x) + ((y + _y) << 7)) & 0x1fff) + 2;
.LINE 416

	LD	A,(__y)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-19)
	ADD.SIS	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	A,(__x)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-17)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD.LIS	BC,8191
	CALL	__sand
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  417									V[0xf] |= scanvas_data[index] & 1;
.LINE 417

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-68),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_scanvas_data
	ADD	HL,BC
	LD	(IX+-65),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-68)
	OR	A,(HL)
	LD	HL,(IX+-68)
	LD	(HL),A
;  418									scanvas_data[index] = ~scanvas_data[index];
.LINE 418

	LD	HL,(IX+-65)
	LD	A,(HL)
	CPL	
	LD	HL,(IX+-65)
	LD	(HL),A
;  419								}
;  420							}
L_97:
.LINE 420

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_98:
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JP	M,L_96
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  421						}
L_102:
.LINE 421

	LD	A,(__y)
	CP	A,(IX+-4)
	JR	C,L_100
	JR	L_115
;  422					} else {
L_114:
.LINE 422

;  423						//Normal screen DXYN
;  424						if(height == 0) height = 16;
.LINE 424

	LD	A,(IX+-4)
	OR	A,A
	JR	NZ,L_112
	LD	(IX+-4),16
L_112:
;  425						for(_y = 0; _y < height; ++_y) {
.LINE 425

	XOR	A,A
	LD	(__y),A
	JR	L_111
L_109:
;  426							pixel = memory[I + _y];
.LINE 426

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,HL
	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  427							for(_x = 0; _x < 8; ++_x) {
.LINE 427

	XOR	A,A
	LD	(__x),A
	JR	L_108
L_106:
;  428								if((pixel & (0x80 >> _x)) != 0) {
.LINE 428

	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,128
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_107
;  429									index = (((x + _x) + ((y + _y) << 6)) & 0x7ff) + 2;
.LINE 429

	LD	A,(__y)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-19)
	ADD.SIS	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	A,(__x)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-17)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD.LIS	BC,2047
	CALL	__sand
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  430									V[0xf] |= canvas_data[index] & 1;
.LINE 430

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-74),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(IX+-71),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-74)
	OR	A,(HL)
	LD	HL,(IX+-74)
	LD	(HL),A
;  431									canvas_data[index] = ~canvas_data[index];
.LINE 431

	LD	HL,(IX+-71)
	LD	A,(HL)
	CPL	
	LD	HL,(IX+-71)
	LD	(HL),A
;  432								}
;  433							}
L_107:
.LINE 433

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_108:
	LD	A,(__x)
	CP	A,8
	JR	C,L_106
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  434						}
L_111:
.LINE 434

	LD	A,(__y)
	CP	A,(IX+-4)
	JR	C,L_109
;  435					}
L_115:
.LINE 435

;  436					
;  437					drawFlag = true;
.LINE 437

	LD	A,1
	LD	(_drawFlag),A
;  438					
;  439					break;
.LINE 439

	JR	L_173
;  440				}
;  441				case 0xe000: {
L_116:
.LINE 441

;  442					switch(opcode & 0x00ff) {
.LINE 442

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__49:
	DW	2
	DB	158
	DW24	L_117	

	DB	161
	DW24	L_120	

	DW24	L_173	

;  443						case 0x009e: {
L_117:
.LINE 443

;  444							if(keys[V[(opcode & 0x0f00) >> 8]])
.LINE 444

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_173
;  445								pc += 2;
.LINE 445

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  446							break;
.LINE 446

	JR	L_173
;  447						}
;  448						case 0x00a1: {
L_120:
.LINE 448

;  449							if(!keys[V[(opcode & 0x0f00) >> 8]])
.LINE 449

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_173
;  450								pc += 2;
.LINE 450

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  451							break;
.LINE 451

	JR	L_173
;  452						}
;  453					}
;  454					break;
;  455				}
;  456				case 0xf000: {
L_124:
.LINE 456

;  457					switch(opcode & 0x00ff) {
.LINE 457

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__52:
	DW	12
	DB	7
	DW24	L_125	

	DB	10
	DW24	L_126	

	DB	21
	DW24	L_133	

	DB	24
	DW24	L_135	

	DB	30
	DW24	L_136	

	DB	41
	DW24	L_140	

	DB	48
	DW24	L_141	

	DB	51
	DW24	L_142	

	DB	85
	DW24	L_143	

	DB	101
	DW24	L_149	

	DB	117
	DW24	L_156	

	DB	133
	DW24	L_163	

	DW24	L_173	

;  458						case 0x0007: {
L_125:
.LINE 458

;  459							V[(opcode & 0x0f00) >> 8] = delay_timer;
.LINE 459

	LD	A,(_delay_timer)
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  460							break;
.LINE 460

	JR	L_173
;  461						}
;  462						case 0x000A: {
L_126:
.LINE 462

;  463							bool key_pressed = false;
.LINE 463

	LD	(IX+-18),0
;  464							pc -= 2;
.LINE 464

	LD	IY,(_pc)
	LEA	BC,IY+-2
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  465							
;  466							for(i = 0; i < 16; ++i) {
.LINE 466

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_130
L_128:
;  467								if(keys[i]) {
.LINE 467

	LD	BC,_keys
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_129
;  468									V[(opcode & 0x0f00) >> 8] = i;
.LINE 468

	LD	D,(IX+-3)
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  469									pc += 2;
.LINE 469

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  470									key_pressed = true;
.LINE 470

	LD	(IX+-18),1
;  471									break;
.LINE 471

	JR	L_132
;  472								}
;  473							}
L_129:
.LINE 473

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_130:
	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_128
L_132:
;  474							
;  475							if(!key_pressed)
.LINE 475

	LD	A,(IX+-18)
	OR	A,A
	JR	Z,L_179
;  476								return;
.LINE 476

;  477						}
.LINE 477

;  478						case 0x0015: {
L_133:
.LINE 478

;  479							delay_timer = V[(opcode & 0x0f00) >> 8];
.LINE 479

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  480							break;
.LINE 480

	JR	L_173
;  481						}
;  482						case 0x0018: {
L_135:
.LINE 482

;  483							sound_timer = V[(opcode & 0x0f00) >> 8];
.LINE 483

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  484							break;
.LINE 484

	JR	L_173
;  485						}
;  486						case 0x001E: {
L_136:
.LINE 486

;  487							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 487

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-27),A
;  488							//V[0xf] = (I > 0xfff - V[x]);
;  489							I += V[x];
.LINE 489

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	DE,(_I)
	LD	HL,BC
	ADD.SIS	HL,DE
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  490							if(I >= 0x1000)
.LINE 490

	LD.LIS	BC,4096
	LD	HL,(_I)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_138
;  491								V[0xf] = 1;
.LINE 491

	LD	HL,_V+15
	LD	(HL),1
;  492							else
.LINE 492

	JR	L_173
L_138:
;  493								V[0xf] = 0;
.LINE 493

	LD	HL,_V+15
	LD	(HL),0
;  494							break;
.LINE 494

	JR	L_173
;  495						}
;  496						case 0x0029: {
L_140:
.LINE 496

;  497							I = V[(opcode & 0x0f00) >> 8] * 5;
.LINE 497

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD.LIS	HL,5
	CALL	__smulu
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  498							break;
.LINE 498

	JR	L_173
;  499						}
;  500						case 0x0030: {
L_141:
.LINE 500

;  501							I = V[(opcode & 0x0f00) >> 8] * 10 + 80;
.LINE 501

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD.LIS	HL,10
	CALL	__smulu
	LD	IY,HL
	LEA	BC,IY+80
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  502							break;
.LINE 502

	JR	L_173
;  503						}
;  504						case 0x0033: {
L_142:
.LINE 504

;  505							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 505

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-28),A
;  506							memory[ I ] =  V[x] / 100;
.LINE 506

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-77),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,100
	CALL	__idivs
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  507							memory[I+1] = (V[x] / 10) % 10;
.LINE 507

	LD	HL,(IX+-77)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  508							memory[I+2] = V[x] % 10;
.LINE 508

	LD	HL,(IX+-77)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  509							break;
.LINE 509

	JR	L_173
;  510						}
;  511						case 0x0055: {
L_143:
.LINE 511

;  512							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 512

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-29),A
;  513							for(i = 0; i <= x; ++i) {
.LINE 513

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_147
L_145:
;  514								if(I < 0x1000)
.LINE 514

	LD.LIS	BC,4096
	LD	HL,(_I)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_146
;  515									memory[I + i] = V[i];
.LINE 515

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
;  516							}
L_146:
.LINE 516

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_147:
	LD	A,(IX+-29)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	P,L_145
;  517							break;
.LINE 517

	JR	L_173
;  518						}
;  519						case 0x0065: {
L_149:
.LINE 519

;  520							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 520

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-30),A
;  521							for(i = 0; i <= x; ++i) {
.LINE 521

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_154
L_152:
;  522								if(I < 0x1000)
.LINE 522

	LD.LIS	BC,4096
	LD	HL,(_I)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_151
;  523									V[i] = memory[I + i];
.LINE 523

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
;  524								else
.LINE 524

	JR	L_153
L_151:
;  525									V[i] = 0;
.LINE 525

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	(HL),0
;  526							}
L_153:
.LINE 526

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_154:
	LD	A,(IX+-30)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_152
;  527							break;
.LINE 527

	JR	L_173
;  528						}
;  529						case 0x0075: {
L_156:
.LINE 529

;  530							uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 530

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-15),A
;  531							if (x > 7) x = 7;
.LINE 531

	LD	A,7
	CP	A,(IX+-15)
	JR	NC,L_161
	LD	(IX+-15),7
L_161:
;  532							for(i = 0; i <= x; ++i) {
.LINE 532

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_160
L_158:
;  533								SV[i] = V[i];
.LINE 533

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  534							}
L_160:
.LINE 534

	LD	A,(IX+-15)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_158
;  535							break;
.LINE 535

	JR	L_173
;  536						}
;  537						case 0x0085: {
L_163:
.LINE 537

;  538							uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 538

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-16),A
;  539							if (x > 7) x = 7;
.LINE 539

	LD	A,7
	CP	A,(IX+-16)
	JR	NC,L_168
	LD	(IX+-16),7
L_168:
;  540							for(i = 0; i <= x; ++i) {
.LINE 540

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_167
L_165:
;  541								V[i] = SV[i];
.LINE 541

	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  542							}
L_167:
.LINE 542

	LD	A,(IX+-16)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_165
;  543							break;
;  544						}
;  545					}
;  546					break;
;  547				}
;  548				default:
;  549					break;
;  550			}
L_173:
.LINE 550

;  551			if(sound_timer > 0) {
.LINE 551

	LD	BC,(_sound_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_175
;  552				--sound_timer;
.LINE 552

	LD	BC,(_sound_timer)
	DEC	BC
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  553			}
L_175:
.LINE 553

;  554			if(delay_timer > 0) {
.LINE 554

	LD	BC,(_delay_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_177
;  555				--delay_timer;
.LINE 555

	LD	BC,(_delay_timer)
	DEC	BC
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  556			}
;  557		}
L_177:
.LINE 557

	LD	A,(_step)
	INC	A
	LD	(_step),A
L_178:
	LD	A,(_step)
	CP	A,(IX+6)
	JR	C,L_176
;  558	}
L_179:
.LINE 558

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emulateCycle ***************************
;Name                         Addr/Register   Size   Type
;_SV                                 STATIC      8   variable
;_sound_timer                        STATIC      2   variable
;_delay_timer                        STATIC      2   variable
;_keys                               STATIC     16   variable
;_index                              STATIC      2   variable
;__x                                 STATIC      1   variable
;_pixel                              STATIC      2   variable
;__y                                 STATIC      1   variable
;_rand                               IMPORT  -----   function
;_I                                  STATIC      2   variable
;_V                                  STATIC     16   variable
;_playing                            STATIC      1   variable
;_stack                              STATIC     32   variable
;_sp                                 STATIC      1   variable
;_drawFlag                           STATIC      1   variable
;_memset                             IMPORT  -----   function
;_screen_width                       STATIC      1   variable
;_memcpy                             IMPORT  -----   function
;_screen_height                      STATIC      1   variable
;_canvas_data                        IMPORT   2050   variable
;_scanvas_data                       IMPORT   8194   variable
;_extendedScreen                     STATIC      1   variable
;_sprintf                            IMPORT  -----   function
;_opcode                             STATIC      2   variable
;_pc                                 STATIC      2   variable
;_memory                             STATIC   4096   variable
;_step                               STATIC      1   variable
;_setKeys                            IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;temp91                               IX-35      3   variable
;x                                    IX-32      1   variable
;x                                    IX-31      1   variable
;x                                    IX-30      1   variable
;x                                    IX-29      1   variable
;x                                    IX-28      1   variable
;x                                    IX-27      1   variable
;n                                    IX-26      1   variable
;x                                    IX-25      1   variable
;x                                    IX-24      1   variable
;x                                    IX-23      1   variable
;disp                                 IX-22      3   variable
;y                                    IX-19      1   variable
;key_pressed                          IX-18      1   variable
;x                                    IX-17      1   variable
;x                                    IX-16      1   variable
;x                                    IX-15      1   variable
;y                                    IX-14      1   variable
;y                                    IX-13      1   variable
;y                                    IX-12      1   variable
;disp                                 IX-11      3   variable
;disp                                  IX-8      3   variable
;cols                                  IX-5      1   variable
;height                                IX-4      1   variable
;i                                     IX-3      3   variable
;steps                                 IX+6      1   parameter


; Stack Frame Size: 102 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emulateCycle",558,"_emulateCycle"
	SEGMENT STRSECT
L__11:
	DB	"SCD called"
	DB	10,0
L__20:
	DB	"Extended mode off"
	DB	10,0
L__21:
	DB	"Extended mode on"
	DB	10,0
	XREF _scanvas_data:ROM
	XREF _canvas_data:ROM
	XREF _kb_Scan:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _sprintf:ROM
	XREF _ti_GetSize:ROM
	XREF _ti_Read:ROM
	XREF _ti_Open:ROM
	XREF _ti_CloseAll:ROM
	XREF _rand:ROM
	XREF _srand:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __sor:ROM
	XREF __sand:ROM
	XREF __iand:ROM
	XREF __smulu:ROM
	XREF __irems:ROM
	XREF __ishrs:ROM
	XREF __stoiu:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __case8D:ROM
	XREF __case16D:ROM
	XREF __ishrs_b:ROM
	XREF __sshru_b:ROM
	XDEF _emulateCycle
	XDEF _setKeys
	XDEF _loadProgram
	XDEF _initialize
	XDEF _screen_height
	XDEF _screen_width
	XDEF __x
	XDEF __y
	XDEF _index
	XDEF _pixel
	XDEF _step
	XDEF _fontset_ten
	XDEF _fontset
	XDEF _file
	XDEF _controlMap
	XDEF _keypad
	XDEF _game_data
	XDEF _extendedScreen
	XDEF _playing
	XDEF _paused
	XDEF _drawFlag
	XDEF _keys
	XDEF _sp
	XDEF _stack
	XDEF _sound_timer
	XDEF _delay_timer
	XDEF _pc
	XDEF _I
	XDEF _V
	XDEF _SV
	XDEF _memory
	XDEF _opcode
	END
