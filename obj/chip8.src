; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\CHIP8.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME1"
.TYPE 104
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME7"
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME8",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME10"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME10",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME10"
.BEGREC "__stdio_file",1
.DEFINE "slot"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "__stdio_file"
	SEGMENT DATA
_opcode:
	DW	0
.DEFINE "opcode"
.ALIAS "_opcode"
.CLASS 69
.VALUE _opcode
.TYPE 13
.ENDEF
	SEGMENT BSS
_memory:
	DS	4096
.DEFINE "memory"
.ALIAS "_memory"
.CLASS 83
.VALUE _memory
.DIM 4096
.TYPE 108
.ENDEF
_SV:
	DS	8
.DEFINE "SV"
.ALIAS "_SV"
.CLASS 83
.VALUE _SV
.DIM 8
.TYPE 108
.ENDEF
_V:
	DS	16
.DEFINE "V"
.ALIAS "_V"
.CLASS 83
.VALUE _V
.DIM 16
.TYPE 108
.ENDEF
	SEGMENT DATA
_I:
	DW	0
.DEFINE "I"
.ALIAS "_I"
.CLASS 69
.VALUE _I
.TYPE 13
.ENDEF
_pc:
	DW	0
.DEFINE "pc"
.ALIAS "_pc"
.CLASS 69
.VALUE _pc
.TYPE 13
.ENDEF
_delay_timer:
	DW	0
.DEFINE "delay_timer"
.ALIAS "_delay_timer"
.CLASS 69
.VALUE _delay_timer
.TYPE 3
.ENDEF
_sound_timer:
	DW	0
.DEFINE "sound_timer"
.ALIAS "_sound_timer"
.CLASS 69
.VALUE _sound_timer
.TYPE 3
.ENDEF
	SEGMENT BSS
_stack:
	DS	32
.DEFINE "stack"
.ALIAS "_stack"
.CLASS 83
.VALUE _stack
.DIM 16
.TYPE 109
.ENDEF
	SEGMENT DATA
_sp:
	DB	0
.DEFINE "sp"
.ALIAS "_sp"
.CLASS 69
.VALUE _sp
.TYPE 12
.ENDEF
_keys:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
.DEFINE "keys"
.ALIAS "_keys"
.CLASS 69
.VALUE _keys
.DIM 16
.TYPE 108
.ENDEF
_drawFlag:
	DB	0
.DEFINE "drawFlag"
.ALIAS "_drawFlag"
.CLASS 69
.VALUE _drawFlag
.TYPE 12
.ENDEF
_paused:
	DB	0
.DEFINE "paused"
.ALIAS "_paused"
.CLASS 69
.VALUE _paused
.TYPE 12
.ENDEF
_playing:
	DB	0
.DEFINE "playing"
.ALIAS "_playing"
.CLASS 69
.VALUE _playing
.TYPE 12
.ENDEF
_extendedScreen:
	DB	0
.DEFINE "extendedScreen"
.ALIAS "_extendedScreen"
.CLASS 69
.VALUE _extendedScreen
.TYPE 12
.ENDEF
	SEGMENT BSS
_game_data:
	DS	3584
.DEFINE "game_data"
.ALIAS "_game_data"
.CLASS 83
.VALUE _game_data
.DIM 3584
.TYPE 108
.ENDEF
_keypad:
	DS	16
.DEFINE "keypad"
.ALIAS "_keypad"
.CLASS 83
.VALUE _keypad
.DIM 16
.TYPE 108
.ENDEF
_controlMap:
	DS	16
.DEFINE "controlMap"
.ALIAS "_controlMap"
.CLASS 83
.VALUE _controlMap
.DIM 16
.TYPE 108
.ENDEF
_file:
	DS	1
.DEFINE "file"
.ALIAS "_file"
.CLASS 83
.VALUE _file
.TYPE 12
.ENDEF
	SEGMENT DATA
_fontset:
	DB	240
	DB	144
	DB	144
	DB	144
	DB	240
	DB	32
	DB	96
	DB	32
	DB	32
	DB	112
	DB	240
	DB	16
	DB	240
	DB	128
	DB	240
	DB	240
	DB	16
	DB	240
	DB	16
	DB	240
	DB	144
	DB	144
	DB	240
	DB	16
	DB	16
	DB	240
	DB	128
	DB	240
	DB	16
	DB	240
	DB	240
	DB	128
	DB	240
	DB	144
	DB	240
	DB	240
	DB	16
	DB	32
	DB	64
	DB	64
	DB	240
	DB	144
	DB	240
	DB	144
	DB	240
	DB	240
	DB	144
	DB	240
	DB	16
	DB	240
	DB	240
	DB	144
	DB	240
	DB	144
	DB	144
	DB	224
	DB	144
	DB	224
	DB	144
	DB	224
	DB	240
	DB	128
	DB	128
	DB	128
	DB	240
	DB	224
	DB	144
	DB	144
	DB	144
	DB	224
	DB	240
	DB	128
	DB	240
	DB	128
	DB	240
	DB	240
	DB	128
	DB	240
	DB	128
	DB	128
.DEFINE "fontset"
.ALIAS "_fontset"
.CLASS 69
.VALUE _fontset
.DIM 80
.TYPE 108
.ENDEF
_fontset_ten:
	DW	50812
	DW	57038
	DW	63190
	DW	50918
	DW	124
	DW	12304
	DW	12528
	DW	12336
	DW	12336
	DW	252
	DW	52344
	DW	3276
	DW	12312
	DW	52320
	DW	252
	DW	52344
	DW	3084
	DW	3128
	DW	52236
	DW	120
	DW	7180
	DW	27708
	DW	65228
	DW	3084
	DW	30
	DW	49404
	DW	49344
	DW	3320
	DW	52236
	DW	120
	DW	24632
	DW	49344
	DW	52472
	DW	52428
	DW	120
	DW	50942
	DW	1734
	DW	6156
	DW	12336
	DW	48
	DW	52344
	DW	60620
	DW	56440
	DW	52428
	DW	120
	DW	50812
	DW	50886
	DW	3198
	DW	12312
	DW	112
	DW	30768
	DW	52428
	DW	64716
	DW	52428
	DW	204
	DW	26364
	DW	26214
	DW	26236
	DW	26214
	DW	252
	DW	26172
	DW	49350
	DW	49344
	DW	26310
	DW	60
	DW	27896
	DW	26214
	DW	26214
	DW	27750
	DW	248
	DW	25342
	DW	25696
	DW	25724
	DW	25184
	DW	254
	DW	26366
	DW	25698
	DW	25724
	DW	24672
	DW	240
.DEFINE "fontset_ten"
.ALIAS "_fontset_ten"
.CLASS 69
.VALUE _fontset_ten
.DIM 80
.TYPE 109
.ENDEF
	SEGMENT BSS
_step:
	DS	1
.DEFINE "step"
.ALIAS "_step"
.CLASS 83
.VALUE _step
.TYPE 12
.ENDEF
_pixel:
	DS	2*1
.DEFINE "pixel"
.ALIAS "_pixel"
.CLASS 83
.VALUE _pixel
.TYPE 13
.ENDEF
_index:
	DS	2*1
.DEFINE "index"
.ALIAS "_index"
.CLASS 83
.VALUE _index
.TYPE 13
.ENDEF
__y:
	DS	1
.DEFINE "_y"
.ALIAS "__y"
.CLASS 83
.VALUE __y
.TYPE 12
.ENDEF
__x:
	DS	1
.DEFINE "_x"
.ALIAS "__x"
.CLASS 83
.VALUE __x
.TYPE 12
.ENDEF
_screen_width:
	DS	1
.DEFINE "screen_width"
.ALIAS "_screen_width"
.CLASS 83
.VALUE _screen_width
.TYPE 12
.ENDEF
_screen_height:
	DS	1
.DEFINE "screen_height"
.ALIAS "_screen_height"
.CLASS 83
.VALUE _screen_height
.TYPE 12
.ENDEF
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <debug.h>
;    6	
;    7	#include <math.h>
;    8	#include <stdio.h>
;    9	#include <stdlib.h>
;   10	#include <string.h>
;   11	
;   12	#include <fileioc.h>
;   13	#include <keypadc.h>
;   14	
;   15	#include "chip8.h"
;   16	#include "sprites_gfx.h"
;   17	
;   18	uint16_t opcode = 0;
;   19	uint8_t memory[4096];
;   20	uint8_t SV[8];
;   21	uint8_t V[16];
;   22	uint16_t I = 0;
;   23	uint16_t pc = 0;
;   24	int16_t delay_timer = 0;
;   25	int16_t sound_timer = 0;
;   26	uint16_t stack[16];
;   27	uint8_t sp = 0;
;   28	uint8_t keys[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;   29	bool drawFlag = false;
;   30	
;   31	bool paused = false;
;   32	bool playing = false;
;   33	bool extendedScreen = 0;
;   34	
;   35	uint8_t game_data[3584];
;   36	uint8_t keypad[16];
;   37	uint8_t controlMap[16];
;   38	
;   39	ti_var_t file;
;   40	
;   41	unsigned char fontset[80] = {
;   42	    0xF0, 0x90, 0x90, 0x90, 0xF0, //0
;   43	    0x20, 0x60, 0x20, 0x20, 0x70, //1
;   44	    0xF0, 0x10, 0xF0, 0x80, 0xF0, //2
;   45	    0xF0, 0x10, 0xF0, 0x10, 0xF0, //3
;   46	    0x90, 0x90, 0xF0, 0x10, 0x10, //4
;   47	    0xF0, 0x80, 0xF0, 0x10, 0xF0, //5
;   48	    0xF0, 0x80, 0xF0, 0x90, 0xF0, //6
;   49	    0xF0, 0x10, 0x20, 0x40, 0x40, //7
;   50	    0xF0, 0x90, 0xF0, 0x90, 0xF0, //8
;   51	    0xF0, 0x90, 0xF0, 0x10, 0xF0, //9
;   52	    0xF0, 0x90, 0xF0, 0x90, 0x90, //A
;   53	    0xE0, 0x90, 0xE0, 0x90, 0xE0, //B
;   54	    0xF0, 0x80, 0x80, 0x80, 0xF0, //C
;   55	    0xE0, 0x90, 0x90, 0x90, 0xE0, //D
;   56	    0xF0, 0x80, 0xF0, 0x80, 0xF0, //E
;   57	    0xF0, 0x80, 0xF0, 0x80, 0x80  //F
;   58	};
;   59	uint16_t  fontset_ten[80] = {
;   60		0xC67C, 0xDECE, 0xF6D6, 0xC6E6, 0x007C, // 0
;   61		0x3010, 0x30F0, 0x3030, 0x3030, 0x00FC, // 1
;   62		0xCC78, 0x0CCC, 0x3018, 0xCC60, 0x00FC, // 2
;   63		0xCC78, 0x0C0C, 0x0C38, 0xCC0C, 0x0078, // 3
;   64		0x1C0C, 0x6C3C, 0xFECC, 0x0C0C, 0x001E, // 4
;   65		0xC0FC, 0xC0C0, 0x0CF8, 0xCC0C, 0x0078, // 5
;   66		0x6038, 0xC0C0, 0xCCF8, 0xCCCC, 0x0078, // 6
;   67		0xC6FE, 0x06C6, 0x180C, 0x3030, 0x0030, // 7
;   68		0xCC78, 0xECCC, 0xDC78, 0xCCCC, 0x0078, // 8
;   69		0xC67C, 0xC6C6, 0x0C7E, 0x3018, 0x0070, // 9
;   70		0x7830, 0xCCCC, 0xFCCC, 0xCCCC, 0x00CC, // A
;   71		0x66FC, 0x6666, 0x667C, 0x6666, 0x00FC, // B
;   72		0x663C, 0xC0C6, 0xC0C0, 0x66C6, 0x003C, // C
;   73		0x6CF8, 0x6666, 0x6666, 0x6C66, 0x00F8, // D
;   74		0x62FE, 0x6460, 0x647C, 0x6260, 0x00FE, // E
;   75		0x66FE, 0x6462, 0x647C, 0x6060, 0x00F0  // F
;   76	};
;   77	
;   78	uint8_t step;
;   79	uint16_t pixel;
;   80	uint16_t index;
;   81	
;   82	uint8_t _y;
;   83	uint8_t _x;
;   84	
;   85	uint8_t screen_width;
;   86	uint8_t screen_height;
	SEGMENT CODE
;   87	
;   88	void initialize() {
_initialize:
.DEFINE "_initialize"

.VALUE _initialize

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initialize",88,"_initialize"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   89		
;   90		opcode = I = sp = delay_timer = sound_timer = 0;
.LINE 90

	LD	HL,_sound_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_delay_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	XOR	A,A
	LD	(_sp),A
	LD	HL,_I
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_opcode
	LD	(HL),0
	INC	HL
	LD	(HL),0
;   91		pc = 0x200;
.LINE 91

	LD	HL,_pc
	LD	(HL),0
	INC	HL
	LD	(HL),2
;   92		
;   93		extendedScreen = 0;
.LINE 93

	XOR	A,A
	LD	(_extendedScreen),A
;   94		screen_width = 64;
.LINE 94

	LD	A,64
	LD	(_screen_width),A
;   95		screen_height = 32;
.LINE 95

	LD	A,32
	LD	(_screen_height),A
;   96		
;   97		scanvas_data[0] = 128;
.LINE 97

	LD	A,128
	LD	(_scanvas_data),A
;   98		scanvas_data[1] = 64;
.LINE 98

	LD	HL,_scanvas_data
	INC	HL
	LD	(HL),64
;   99		memset(scanvas_data + 2, 0, 8192);
.LINE 99

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  100	
;  101		canvas_data[0] = 64;
.LINE 101

	LD	A,64
	LD	(_canvas_data),A
;  102		canvas_data[1] = 32;
.LINE 102

	LD	HL,_canvas_data
	INC	HL
	LD	(HL),32
;  103		memset(canvas_data + 2, 0, 2048);
.LINE 103

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  104			
;  105		memset(keys, 0, 16);
.LINE 105

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_keys
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  106		memset(stack, 0, 16);
.LINE 106

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_stack
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  107		memset(V, 0, 16);
.LINE 107

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_V
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  108		memset(SV, 0, 8);
.LINE 108

	LD	BC,8
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_SV
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  109		memset(memory, 0, 4096);
.LINE 109

	LD	BC,4096
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  110		
;  111		memcpy(memory, fontset, 80);
.LINE 111

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  112		memcpy(memory + 80, fontset_ten, 80);
.LINE 112

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset_ten
	PUSH	BC
	LD	BC,_memory+80
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  113		
;  114		srand(rtc_Time());
.LINE 114

	LD	BC,(15925316)
	PUSH	BC
	CALL	_srand
	POP	BC
;  115	}
.LINE 115

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initialize ***************************
;Name                         Addr/Register   Size   Type
;_srand                              IMPORT  -----   function
;_fontset_ten                        STATIC    160   variable
;_fontset                            STATIC     80   variable
;_memcpy                             IMPORT  -----   function
;_memory                             STATIC   4096   variable
;_SV                                 STATIC      8   variable
;_V                                  STATIC     16   variable
;_stack                              STATIC     32   variable
;_keys                               STATIC     16   variable
;_canvas_data                        IMPORT   2050   variable
;_memset                             IMPORT  -----   function
;_scanvas_data                       IMPORT   8194   variable
;_screen_height                      STATIC      1   variable
;_screen_width                       STATIC      1   variable
;_extendedScreen                     STATIC      1   variable
;_pc                                 STATIC      2   variable
;_opcode                             STATIC      2   variable
;_I                                  STATIC      2   variable
;_sp                                 STATIC      1   variable
;_delay_timer                        STATIC      2   variable
;_sound_timer                        STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initialize",115,"_initialize"
;  116	
;  117	void loadProgram(char *fileName) {
_loadProgram:
.DEFINE "_loadProgram"

.VALUE _loadProgram

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "loadProgram",117,"_loadProgram"

.LINE 117

.DEFINE "fileName"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "romSize"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;  118		int i;
;  119		uint16_t romSize;
;  120		
;  121		playing = true;
.LINE 121

	LD	A,1
	LD	(_playing),A
;  122		paused = false;
.LINE 122

	XOR	A,A
	LD	(_paused),A
;  123		
;  124		ti_CloseAll();
.LINE 124

	CALL	_ti_CloseAll
;  125		file = ti_Open(fileName, "r");
.LINE 125

	LD	BC,L__1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(_file),A
;  126		ti_Read(&game_data, ti_GetSize(file), 1, file);
.LINE 126

	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	PUSH	HL
	LD	BC,_game_data
	PUSH	BC
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  127		
;  128		romSize = ti_GetSize(file)-(16+6);
.LINE 128

	LD	A,(_file)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	IY,HL
	LEA	HL,IY+-22
	LD	(IX+-5),L
	LD	(IX+-4),H
;  129		
;  130		initialize();
.LINE 130

	CALL	_initialize
;  131		
;  132		if((4096-512) > romSize) {
.LINE 132

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,3584
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_9
;  133			for(i = 0; i < romSize; ++i) {
.LINE 133

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
;  134				memory[i + 512] = (uint8_t)game_data[i+16+6];
.LINE 134

	LD	IY,(IX+-3)
	LEA	HL,IY+22
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,512
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  135			}
L_3:
.LINE 135

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
;  136		}
L_9:
.LINE 136

;  137		for(i = 0; i < 16; i++) {
.LINE 137

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_8
L_6:
;  138			controlMap[i] = (uint8_t)game_data[i+6];
.LINE 138

	LD	IY,(IX+-3)
	LEA	HL,IY+6
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_controlMap
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  139		}
L_8:
.LINE 139

	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_6
;  140	}
.LINE 140

	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadProgram ***************************
;Name                         Addr/Register   Size   Type
;_controlMap                         STATIC     16   variable
;_memory                             STATIC   4096   variable
;_initialize                         IMPORT  -----   function
;_game_data                          STATIC   3584   variable
;_ti_GetSize                         IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_file                               STATIC      1   variable
;_ti_Open                            IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_paused                             STATIC      1   variable
;_playing                            STATIC      1   variable
;romSize                               IX-5      2   variable
;i                                     IX-3      3   variable
;fileName                              IX+6      3   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "loadProgram",140,"_loadProgram"
	SEGMENT STRSECT
L__1:
	DB	"r"
	DB	0
	SEGMENT CODE
;  141	
;  142	void setKeys() {
_setKeys:
.DEFINE "_setKeys"

.VALUE _setKeys

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setKeys",142,"_setKeys"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  143		keypad[0x0] = kb_Data[4] & kb_DecPnt;
.LINE 143

	LD	A,(16056344)
	AND	A,1
	LD	(_keypad),A
;  144		keypad[0x1] = kb_Data[3] & kb_7;
.LINE 144

	LD	A,(16056342)
	AND	A,8
	LD	HL,_keypad
	INC	HL
	LD	(HL),A
;  145		keypad[0x2] = kb_Data[4] & kb_8;
.LINE 145

	LD	A,(16056344)
	AND	A,8
	LD	IY,_keypad
	LEA	HL,IY+2
	LD	(HL),A
;  146		keypad[0x3] = kb_Data[5] & kb_9;
.LINE 146

	LD	A,(16056346)
	AND	A,8
	LEA	HL,IY+3
	LD	(HL),A
;  147		keypad[0x4] = kb_Data[3] & kb_4;
.LINE 147

	LD	A,(16056342)
	AND	A,4
	LEA	HL,IY+4
	LD	(HL),A
;  148		keypad[0x5] = kb_Data[4] & kb_5;
.LINE 148

	LD	A,(16056344)
	AND	A,4
	LEA	HL,IY+5
	LD	(HL),A
;  149		keypad[0x6] = kb_Data[5] & kb_6;
.LINE 149

	LD	A,(16056346)
	AND	A,4
	LEA	HL,IY+6
	LD	(HL),A
;  150		keypad[0x7] = kb_Data[3] & kb_1;
.LINE 150

	LD	A,(16056342)
	AND	A,2
	LEA	HL,IY+7
	LD	(HL),A
;  151		keypad[0x8] = kb_Data[4] & kb_2;
.LINE 151

	LD	A,(16056344)
	AND	A,2
	LEA	HL,IY+8
	LD	(HL),A
;  152		keypad[0x9] = kb_Data[5] & kb_3;
.LINE 152

	LD	A,(16056346)
	AND	A,2
	LEA	HL,IY+9
	LD	(HL),A
;  153		keypad[0xA] = kb_Data[3] & kb_0;
.LINE 153

	LD	A,(16056342)
	AND	A,1
	LEA	HL,IY+10
	LD	(HL),A
;  154		keypad[0xB] = kb_Data[5] & kb_Chs;
.LINE 154

	LD	A,(16056346)
	AND	A,1
	LEA	HL,IY+11
	LD	(HL),A
;  155		keypad[0xC] = kb_Data[6] & kb_Mul;
.LINE 155

	LD	A,(16056348)
	AND	A,8
	LEA	HL,IY+12
	LD	(HL),A
;  156		keypad[0xD] = kb_Data[6] & kb_Sub;
.LINE 156

	LD	A,(16056348)
	AND	A,4
	LEA	HL,IY+13
	LD	(HL),A
;  157		keypad[0xE] = kb_Data[6] & kb_Add;
.LINE 157

	LD	A,(16056348)
	AND	A,2
	LEA	HL,IY+14
	LD	(HL),A
;  158		keypad[0xF] = kb_Data[6] & kb_Enter;
.LINE 158

	LD	A,(16056348)
	AND	A,1
	LD	HL,_keypad+15
	LD	(HL),A
;  159		
;  160		keys[0x0] = keypad[controlMap[0x0]];
.LINE 160

	LD	A,(_controlMap)
	UEXT	HL
	LD	L,A
	LD	BC,_keypad
	ADD	HL,BC
	LD	A,(HL)
	LD	(_keys),A
;  161		keys[0x1] = keypad[controlMap[0x1]];
.LINE 161

	LD	HL,_controlMap
	INC	HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,_keys
	LD	A,(HL)
	LD	(IY+1),A
;  162		keys[0x2] = keypad[controlMap[0x2]];
.LINE 162

	LD	HL,_controlMap+2
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+2),A
;  163		keys[0x3] = keypad[controlMap[0x3]];
.LINE 163

	LD	HL,_controlMap+3
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+3),A
;  164		                              
;  165		keys[0x4] = keypad[controlMap[0x4]];
.LINE 165

	LD	HL,_controlMap+4
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+4),A
;  166		keys[0x5] = keypad[controlMap[0x5]];
.LINE 166

	LD	HL,_controlMap+5
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+5),A
;  167		keys[0x6] = keypad[controlMap[0x6]];
.LINE 167

	LD	HL,_controlMap+6
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+6),A
;  168		keys[0x7] = keypad[controlMap[0x7]];
.LINE 168

	LD	HL,_controlMap+7
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+7),A
;  169		                              
;  170		keys[0x8] = keypad[controlMap[0x8]];
.LINE 170

	LD	HL,_controlMap+8
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+8),A
;  171		keys[0x9] = keypad[controlMap[0x9]];
.LINE 171

	LD	HL,_controlMap+9
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+9),A
;  172		keys[0xA] = keypad[controlMap[0xA]];
.LINE 172

	LD	HL,_controlMap+10
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+10),A
;  173		keys[0xB] = keypad[controlMap[0xB]];
.LINE 173

	LD	HL,_controlMap+11
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+11),A
;  174		                              
;  175		keys[0xC] = keypad[controlMap[0xC]];
.LINE 175

	LD	HL,_controlMap+12
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+12),A
;  176		keys[0xD] = keypad[controlMap[0xD]];
.LINE 176

	LD	HL,_controlMap+13
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+13),A
;  177		keys[0xE] = keypad[controlMap[0xE]];
.LINE 177

	LD	HL,_controlMap+14
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+14),A
;  178		keys[0xF] = keypad[controlMap[0xF]];
.LINE 178

	LD	HL,_controlMap+15
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+15),A
;  179		
;  180		if(kb_Data[1] & kb_2nd) {
.LINE 180

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_11
	JR	L_15
;  181			while(kb_Data[1] & kb_2nd) {
L_12:
.LINE 181

;  182				kb_Scan();
.LINE 182

	CALL	_kb_Scan
;  183			}
L_11:
.LINE 183

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_12
;  184			paused = 1;
.LINE 184

	LD	A,1
	LD	(_paused),A
;  185		}
;  186	}
L_15:
.LINE 186

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setKeys ***************************
;Name                         Addr/Register   Size   Type
;_paused                             STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_keys                               STATIC     16   variable
;_controlMap                         STATIC     16   variable
;_keypad                             STATIC     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setKeys",186,"_setKeys"
;  187	
;  188	void emulateCycle(uint8_t steps) {
_emulateCycle:
.DEFINE "_emulateCycle"

.VALUE _emulateCycle

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emulateCycle",188,"_emulateCycle"

.LINE 188

.DEFINE "steps"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "cols"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -10

.TYPE 44

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -13

.TYPE 44

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -16

.TYPE 44

.ENDEF

.DEFINE "xd"

.CLASS 65

.VALUE -17

.TYPE 12

.ENDEF

.DEFINE "key_pressed"

.CLASS 65

.VALUE -18

.TYPE 12

.ENDEF

.DEFINE "yd"

.CLASS 65

.VALUE -19

.TYPE 12

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -20

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-74
	LD	SP,HL
;  189		
;  190		kb_Scan();
.LINE 190

	CALL	_kb_Scan
;  191		setKeys();
.LINE 191

	CALL	_setKeys
;  192		
;  193		for(step = 0; step < steps; ++step) {
.LINE 193

	XOR	A,A
	LD	(_step),A
	JR	L_170
L_168:
;  194			int i;
;  195			uint8_t x;
;  196			uint8_t y;
;  197			opcode = (memory[pc] << 8) | memory[pc+1];
.LINE 197

	LD	BC,(_pc)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	H,L
	LD	L,0
	LD	DE,HL
	LD	BC,(_pc)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,DE
	CALL	__sor
	LD	BC,HL
	LD	HL,_opcode
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  198			x = (opcode & 0x0f00) >> 8;
.LINE 198

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-4),A
;  199			y = (opcode & 0x00f0) >> 4;
.LINE 199

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-5),A
;  200			
;  201			pc += 2;
.LINE 201

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  202			
;  203			switch(opcode & 0xf000) {
.LINE 203

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	BC,61440
	CALL	__iand
	CALL	__case16D
	JP	(HL)
L__9:
	DW	16
	DW	0
	DW24	L_16	

	DW	4096
	DW24	L_55	

	DW	8192
	DW24	L_56	

	DW	12288
	DW24	L_58	

	DW	16384
	DW24	L_61	

	DW	20480
	DW24	L_64	

	DW	24576
	DW24	L_67	

	DW	28672
	DW24	L_68	

	DW	32768
	DW24	L_69	

	DW	36864
	DW24	L_80	

	DW	40960
	DW24	L_83	

	DW	45056
	DW24	L_84	

	DW	49152
	DW24	L_85	

	DW	53248
	DW24	L_86	

	DW	57344
	DW24	L_118	

	DW	61440
	DW24	L_126	

	DW24	L_169	

;  204				case 0x0000: {
L_16:
.LINE 204

;  205					switch(opcode & 0x00f0) {
.LINE 205

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,240
	UEXT	HL
	LD	L,A
	LD	BC,192
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_53
;  206						case 0x00c0: { //SCD
.LINE 206

;  207							uint8_t n = (opcode & 0x000f);
.LINE 207

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-20),A
;  208							uint8_t *disp;
;  209							
;  210							if(extendedScreen) {
.LINE 210

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_19
;  211								disp = &scanvas_data[2];
.LINE 211

	LD	BC,_scanvas_data+2
	LD	(IX+-16),BC
;  212							} else {
.LINE 212

	JR	L_24
L_19:
;  213								disp = &canvas_data[2];
.LINE 213

	LD	BC,_canvas_data+2
	LD	(IX+-16),BC
;  214							}
L_24:
.LINE 214

;  215							for(i = screen_height-2; i >= 0; i--) {
.LINE 215

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	DEC	HL
	DEC	HL
	LD	(IX+-3),HL
	JR	L_23
L_21:
;  216								memcpy(disp + (i+n)*screen_width, disp + i*screen_width, screen_width);
.LINE 216

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-16)
	ADD	HL,BC
	PUSH	HL
	LD	A,(IX+-20)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	DE,HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,(IX+-16)
	ADD	HL,BC
	PUSH	HL
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  217								memset(disp + i*screen_width, 0, screen_width);
.LINE 217

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-16)
	ADD	HL,BC
	PUSH	HL
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
;  218							}
L_23:
.LINE 218

	LD	HL,(IX+-3)
	CALL	__icmpzero
	JP	P,L_21
;  219							
;  220							drawFlag = true; 
.LINE 220

	LD	A,1
	LD	(_drawFlag),A
;  221							
;  222							break;
;  223						}
;  224						break;
;  225					}
L_53:
.LINE 225

;  226					switch(opcode & 0x00ff) {
.LINE 226

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__12:
	DW	7
	DB	224
	DW24	L_26	

	DB	238
	DW24	L_30	

	DB	251
	DW24	L_31	

	DB	252
	DW24	L_40	

	DB	253
	DW24	L_49	

	DB	254
	DW24	L_50	

	DB	255
	DW24	L_51	

	DW24	L_52	

;  227						case 0x00e0:
L_26:
.LINE 227

;  228							if(extendedScreen)
.LINE 228

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_28
;  229								memset(scanvas_data + 2, 0, 8192);
.LINE 229

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  230							else
.LINE 230

	JR	L_29
L_28:
;  231								memset(canvas_data + 2, 0, 2048);
.LINE 231

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
L_29:
;  232							drawFlag = true;
.LINE 232

	LD	A,1
	LD	(_drawFlag),A
;  233							break;
.LINE 233

	JR	L_169
;  234						case 0x00ee:
L_30:
.LINE 234

;  235							pc = stack[(--sp)&0xf];
.LINE 235

	LD	A,(_sp)
	DEC	A
	LD	(_sp),A
	AND	A,15
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	BC,(HL)
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  236							break;
.LINE 236

	JR	L_169
;  237						case 0x00fb: { //SCR
L_31:
.LINE 237

;  238							uint8_t *disp;
;  239							
;  240							if(extendedScreen) {
.LINE 240

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_33
;  241								disp = &scanvas_data[2];
.LINE 241

	LD	BC,_scanvas_data+2
	LD	(IX+-10),BC
;  242							} else {
.LINE 242

	JR	L_38
L_33:
;  243								disp = &canvas_data[2];
.LINE 243

	LD	BC,_canvas_data+2
	LD	(IX+-10),BC
;  244							}
L_38:
.LINE 244

;  245							for(i = 0; i < screen_height; i++) {
.LINE 245

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_37
L_35:
;  246								memmove(disp + 4, disp, screen_width - 4);
.LINE 246

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	LD	IY,(IX+-10)
	LEA	BC,IY+4
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  247								memset(disp, 0, 4);
.LINE 247

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  248								disp += screen_width;
.LINE 248

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-10)
	ADD	HL,BC
	LD	(IX+-10),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  249							}
L_37:
.LINE 249

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_35
;  250							break;
.LINE 250

	JR	L_169
;  251						}
;  252						case 0x00fc: { //SCL
L_40:
.LINE 252

;  253							uint8_t *disp;
;  254							
;  255							if(extendedScreen) {
.LINE 255

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_42
;  256								disp = &scanvas_data[2];
.LINE 256

	LD	BC,_scanvas_data+2
	LD	(IX+-13),BC
;  257							} else {
.LINE 257

	JR	L_47
L_42:
;  258								disp = &canvas_data[2];
.LINE 258

	LD	BC,_canvas_data+2
	LD	(IX+-13),BC
;  259							}
L_47:
.LINE 259

;  260							for(i = 0; i < screen_height; i++) {
.LINE 260

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_46
L_44:
;  261								memmove(disp, disp + 4, screen_width - 4);
.LINE 261

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	IY,(IX+-13)
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  262								memset(disp + screen_width - 4, 0, 4);
.LINE 262

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-13)
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  263								disp += screen_width;
.LINE 263

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-13)
	ADD	HL,BC
	LD	(IX+-13),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  264							}
L_46:
.LINE 264

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_44
;  265							break;
.LINE 265

	JR	L_169
;  266						}
;  267						case 0x00fd:
L_49:
.LINE 267

;  268							playing = 0;
.LINE 268

	XOR	A,A
	LD	(_playing),A
;  269							//exit
;  270							break;
.LINE 270

	JR	L_169
;  271						case 0x00fe:
L_50:
.LINE 271

;  272							extendedScreen = 0;
.LINE 272

	XOR	A,A
	LD	(_extendedScreen),A
;  273							screen_width = 64;
.LINE 273

	LD	A,64
	LD	(_screen_width),A
;  274							screen_height = 32;
.LINE 274

	LD	A,32
	LD	(_screen_height),A
;  275							memcpy(canvas_data + 2, scanvas_data + 2, 2048);
.LINE 275

	LD	BC,2048
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  276							dbg_sprintf(dbgout, "Extended mode off\n");
.LINE 276

	LD	BC,L__18
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  277							break;
.LINE 277

	JR	L_169
;  278						case 0x00ff:
L_51:
.LINE 278

;  279							extendedScreen = 1;
.LINE 279

	LD	A,1
	LD	(_extendedScreen),A
;  280							screen_width = 128;
.LINE 280

	LD	A,128
	LD	(_screen_width),A
;  281							screen_height = 64;
.LINE 281

	LD	A,64
	LD	(_screen_height),A
;  282							memcpy(scanvas_data + 2, canvas_data + 2, 2048);
.LINE 282

	LD	BC,2048
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  283							dbg_sprintf(dbgout, "Extended mode on\n");
.LINE 283

	LD	BC,L__19
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  284							break;
.LINE 284

	JR	L_169
;  285						default:
L_52:
.LINE 285

;  286							pc = (pc & 0x0fff);
.LINE 286

	LD	HL,(_pc)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  287							break;
.LINE 287

	JR	L_169
;  288					}
;  289					break;
;  290				}
;  291				case 0x1000: {
L_55:
.LINE 291

;  292					pc = (opcode & 0x0fff);
.LINE 292

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  293					break;
.LINE 293

	JR	L_169
;  294				}
;  295				case 0x2000: {
L_56:
.LINE 295

;  296					stack[sp++] = pc;
.LINE 296

	LD	A,(_sp)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	A,(_pc)
	LD	(HL),A
	INC	HL
	LD	A,(_pc+1)
	LD	(HL),A
	LD	A,(_sp)
	INC	A
	LD	(_sp),A
;  297					pc = (opcode & 0x0fff);
.LINE 297

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  298					break;
.LINE 298

	JR	L_169
;  299				}
;  300				case 0x3000: {
L_58:
.LINE 300

;  301					if(V[x] == (opcode & 0x00ff))
.LINE 301

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_169
;  302						pc += 2;
.LINE 302

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  303					break;
.LINE 303

	JR	L_169
;  304				}
;  305				case 0x4000: {
L_61:
.LINE 305

;  306					if(V[x] != (opcode & 0x00ff))
.LINE 306

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	Z,L_169
;  307						pc += 2;
.LINE 307

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  308					break;
.LINE 308

	JR	L_169
;  309				}
;  310				case 0x5000: {
L_64:
.LINE 310

;  311					if(V[x] == V[y])
.LINE 311

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	NZ,L_169
;  312						pc += 2;
.LINE 312

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  313					break;
.LINE 313

	JR	L_169
;  314				}
;  315				case 0x6000: {
L_67:
.LINE 315

;  316					V[x] = (opcode & 0x00ff);
.LINE 316

	LD	A,(_opcode)
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  317					break;
.LINE 317

	JR	L_169
;  318				}
;  319				case 0x7000: {
L_68:
.LINE 319

;  320					V[x] = (V[x] + (opcode & 0x00ff)) & 0xff;
.LINE 320

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-26),HL
	LD	A,(_opcode)
	LD	HL,(IX+-26)
	ADD	A,(HL)
	LD	HL,(IX+-26)
	LD	(HL),A
;  321					break;
.LINE 321

	JR	L_169
;  322				}
;  323				case 0x8000: {
L_69:
.LINE 323

;  324					switch(opcode & 0x000f) {
.LINE 324

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__23:
	DW	9
	DB	0
	DW24	L_70	

	DB	1
	DW24	L_71	

	DB	2
	DW24	L_72	

	DB	3
	DW24	L_73	

	DB	4
	DW24	L_74	

	DB	5
	DW24	L_75	

	DB	6
	DW24	L_76	

	DB	7
	DW24	L_77	

	DB	14
	DW24	L_78	

	DW24	L_169	

;  325						case 0x0000: {
L_70:
.LINE 325

;  326							V[x]  = V[y];
.LINE 326

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
;  327							break;
.LINE 327

	JR	L_169
;  328						}
;  329						case 0x0001: {
L_71:
.LINE 329

;  330							V[x] |= V[y];
.LINE 330

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-29),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-29)
	LD	A,(HL)
	OR	A,(IY)
	LD	HL,(IX+-29)
	LD	(HL),A
;  331							break;
.LINE 331

	JR	L_169
;  332						}
;  333						case 0x0002: {
L_72:
.LINE 333

;  334							V[x] &= V[y];
.LINE 334

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-32),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-32)
	LD	A,(HL)
	AND	A,(IY)
	LD	HL,(IX+-32)
	LD	(HL),A
;  335							break;
.LINE 335

	JR	L_169
;  336						}
;  337						case 0x0003: {
L_73:
.LINE 337

;  338							V[x] ^= V[y];
.LINE 338

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-35),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-35)
	LD	A,(HL)
	XOR	A,(IY)
	LD	HL,(IX+-35)
	LD	(HL),A
;  339							break;
.LINE 339

	JR	L_169
;  340						}
;  341						case 0x0004: {
L_74:
.LINE 341

;  342							V[0xf] = (V[x] + V[y] > 0xff);
.LINE 342

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-38),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-38)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,HL
	LD	HL,255
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L__25
	LD	A,1
	JR	L__26
L__25:
	XOR	A,A
L__26:
	LD	HL,_V+15
	LD	(HL),A
;  343							V[x] += V[y];
.LINE 343

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-38)
	LD	(IX+-62),HL	; spill
	LD	HL,(IX+-38)
	LD	(IX+-71),HL	; spill
	LD	HL,(IX+-62)	; unspill
	LD	A,(HL)
	ADD	A,(IY)
	LD	HL,(IX+-71)	; unspill
	LD	(HL),A
;  344							V[x] &= 255;
.LINE 344

	LD	HL,(IX+-38)
	LD	A,(HL)
	LD	HL,(IX+-38)
	LD	(HL),A
;  345							break;
.LINE 345

	JR	L_169
;  346						}
;  347						case 0x0005: {
L_75:
.LINE 347

;  348							V[0xf] = V[x] >= V[y];
.LINE 348

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-41),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-41)
	LD	A,(IY)
	CP	A,(HL)
	JR	C,L__28
	LD	A,1
	JR	L__29
L__28:
	XOR	A,A
L__29:
	LD	HL,_V+15
	LD	(HL),A
;  349							V[x] -= V[y];
.LINE 349

	LD	IY,(IX+-41)
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(IX+-62),HL	; spill
	LD	HL,(IX+-41)
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-62)	; unspill
	LD	A,(IY)
	SUB	A,(HL)
	LD	HL,(IX+-68)	; unspill
	LD	(HL),A
;  350							break;
.LINE 350

	JR	L_169
;  351						}
;  352						case 0x0006: {
L_76:
.LINE 352

;  353							V[0xf] = V[x] & 1;
.LINE 353

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-44),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,_V+15
	LD	(HL),A
;  354							V[x] >>= 1;
.LINE 354

	LD	HL,(IX+-44)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,1
	CALL	__ishrs_b
	LD	IY,(IX+-44)
	LD	(IY),L
;  355							break;
.LINE 355

	JR	L_169
;  356						}
;  357						case 0x0007: {
L_77:
.LINE 357

;  358							V[0xf] = V[y] >= V[x];
.LINE 358

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-47),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-47)
	LD	A,(HL)
	CP	A,(IY)
	JR	C,L__31
	LD	A,1
	JR	L__32
L__31:
	XOR	A,A
L__32:
	LD	HL,_V+15
	LD	(HL),A
;  359							V[x] = V[y] - V[x];
.LINE 359

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-47)
	LD	(IX+-62),HL	; spill
	LD	HL,(IX+-47)
	LD	(IX+-65),HL	; spill
	LD	HL,(IX+-62)	; unspill
	LD	A,(HL)
	SUB	A,(IY)
	LD	HL,(IX+-65)	; unspill
	LD	(HL),A
;  360							break;
.LINE 360

	JR	L_169
;  361						}
;  362						case 0x000E: {
L_78:
.LINE 362

;  363							V[0xf] = V[x] >> 7;
.LINE 363

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-50),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,7
	CALL	__ishrs_b
	LD	IY,_V
	LD	(IY+15),L
;  364							V[x] <<= 1;
.LINE 364

	LD	HL,(IX+-50)
	LD	A,(HL)
	ADD	A,A
	LD	HL,(IX+-50)
	LD	(HL),A
;  365							break;
.LINE 365

	JR	L_169
;  366						}
;  367						break;
;  368					}
;  369					break;
;  370				}
;  371				case 0x9000: {
L_80:
.LINE 371

;  372					if(V[x] != V[y])
.LINE 372

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_169
;  373						pc += 2;
.LINE 373

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  374					break;
.LINE 374

	JR	L_169
;  375				}
;  376				case 0xa000: {
L_83:
.LINE 376

;  377					I = (opcode & 0x0fff);
.LINE 377

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  378					break;
.LINE 378

	JR	L_169
;  379				}
;  380				case 0xb000: {
L_84:
.LINE 380

;  381					pc = V[0] + (opcode & 0x0fff);
.LINE 381

	LD	A,(_V)
	LD	C,A
	LD	B,0
	LD	DE,BC
	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  382					break;
.LINE 382

	JR	L_169
;  383				}
;  384				case 0xc000: {
L_85:
.LINE 384

;  385					V[x] = (rand() & 0xff) & (opcode & 0x00FF);
.LINE 385

	LD	A,(_opcode)
	LD	B,A
	LD	(IX+-74),BC
	CALL	_rand
	LD	BC,(IX+-74)
	LD	A,B
	AND	A,L
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  386					break;
.LINE 386

	JR	L_169
;  387				}
;  388				case 0xd000: {
L_86:
.LINE 388

;  389					uint8_t xd = V[x];
.LINE 389

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-17),A
;  390					uint8_t yd = V[y];
.LINE 390

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-19),A
;  391					uint8_t height = (opcode & 0x000f);
.LINE 391

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-6),A
;  392					
;  393					V[0xf] = 0;
.LINE 393

	LD	HL,_V+15
	LD	(HL),0
;  394					
;  395					if(extendedScreen) {
.LINE 395

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_116
;  396						//Extended screen DXY0
;  397						uint8_t cols = 1;
.LINE 397

	LD	(IX+-7),1
;  398						if(height == 0) {
.LINE 398

	LD	A,(IX+-6)
	OR	A,A
	JR	NZ,L_103
;  399							cols = 2;
.LINE 399

	LD	(IX+-7),2
;  400							height = 16;
.LINE 400

	LD	(IX+-6),16
;  401						}
L_103:
.LINE 401

;  402						for(_y = 0; _y < height; ++_y) {
.LINE 402

	XOR	A,A
	LD	(__y),A
	JR	L_102
L_100:
;  403							pixel = memory[I + (cols*_y)];
.LINE 403

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  404							if(cols == 2) {
.LINE 404

	LD	A,(IX+-7)
	CP	A,2
	JR	NZ,L_99
;  405								pixel <<= 8;
.LINE 405

	LD	HL,(_pixel)
	LD	H,L
	LD	L,0
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  406								pixel |= memory[I + (_y << 1)+1];
.LINE 406

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	BC,(_pixel)
	CALL	__sor
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  407							}
L_99:
.LINE 407

;  408							for(_x = 0; _x < (cols << 3); ++_x) {
.LINE 408

	XOR	A,A
	LD	(__x),A
	JR	L_98
L_96:
;  409								if((pixel & (((cols == 2) ? 0x8000 : 0x80) >> _x)) != 0) {
.LINE 409

	LD	A,(IX+-7)
	CP	A,2
	JR	NZ,L_91
	LD	BC,32768
	LD	(IX+-23),BC
	JR	L_92
L_91:
	LD	BC,128
	LD	(IX+-23),BC
L_92:
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-23)
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_97
;  410									index = (((xd + _x) & 0x7f) + (((yd + _y) & 0x3f) << 7)) + 2;
.LINE 410

	LD	A,(__x)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-17)
	ADD.SIS	HL,BC
	LD	A,L
	RES	7,A
	LD	C,A
	LD	DE,BC
	LD	A,(__y)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-19)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,63
	LD	C,A
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  411									V[0xf] |= scanvas_data[index] & 1;
.LINE 411

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-53),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_scanvas_data
	ADD	HL,BC
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-53)
	OR	A,(HL)
	LD	HL,(IX+-53)
	LD	(HL),A
;  412									if (scanvas_data[index])
.LINE 412

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_scanvas_data
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_94
;  413										scanvas_data[index] = 0;
.LINE 413

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_scanvas_data
	ADD	HL,BC
	LD	(HL),0
;  414									else
.LINE 414

	JR	L_97
L_94:
;  415										scanvas_data[index] = 1;
.LINE 415

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_scanvas_data
	ADD	HL,BC
	LD	(HL),1
;  416								}
;  417							}
L_97:
.LINE 417

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_98:
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JP	M,L_96
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  418						}
L_102:
.LINE 418

	LD	A,(__y)
	CP	A,(IX+-6)
	JR	C,L_100
	JR	L_117
;  419					} else {
L_116:
.LINE 419

;  420						//Normal screen DXYN
;  421						if(height == 0) height = 16;
.LINE 421

	LD	A,(IX+-6)
	OR	A,A
	JR	NZ,L_114
	LD	(IX+-6),16
L_114:
;  422						for(_y = 0; _y < height; ++_y) {
.LINE 422

	XOR	A,A
	LD	(__y),A
	JR	L_113
L_111:
;  423							pixel = memory[I + _y];
.LINE 423

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,HL
	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  424							for(_x = 0; _x < 8; ++_x) {
.LINE 424

	XOR	A,A
	LD	(__x),A
	JR	L_110
L_108:
;  425								if((pixel & (0x80 >> _x)) != 0) {
.LINE 425

	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,128
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_109
;  426									index = (((xd + _x) & 0x3f) + (((yd + _y) & 0x1f) << 6)) + 2;
.LINE 426

	LD	A,(__x)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-17)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,63
	LD	C,A
	LD	DE,BC
	LD	A,(__y)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-19)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,31
	LD	C,A
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  427									V[0xf] |= canvas_data[index] & 1;
.LINE 427

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-56),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-56)
	OR	A,(HL)
	LD	HL,(IX+-56)
	LD	(HL),A
;  428									if (canvas_data[index])
.LINE 428

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_106
;  429										canvas_data[index] = 0;
.LINE 429

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(HL),0
;  430									else
.LINE 430

	JR	L_109
L_106:
;  431										canvas_data[index] = 1;
.LINE 431

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(HL),1
;  432								}
;  433							}
L_109:
.LINE 433

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_110:
	LD	A,(__x)
	CP	A,8
	JR	C,L_108
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  434						}
L_113:
.LINE 434

	LD	A,(__y)
	CP	A,(IX+-6)
	JR	C,L_111
;  435					}
L_117:
.LINE 435

;  436					
;  437					drawFlag = true;
.LINE 437

	LD	A,1
	LD	(_drawFlag),A
;  438					
;  439					break;
.LINE 439

	JR	L_169
;  440				}
;  441				case 0xe000: {
L_118:
.LINE 441

;  442					switch(opcode & 0x00ff) {
.LINE 442

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__47:
	DW	2
	DB	158
	DW24	L_119	

	DB	161
	DW24	L_122	

	DW24	L_169	

;  443						case 0x009e: {
L_119:
.LINE 443

;  444							if(keys[V[x]])
.LINE 444

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_169
;  445								pc += 2;
.LINE 445

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  446							break;
.LINE 446

	JR	L_169
;  447						}
;  448						case 0x00a1: {
L_122:
.LINE 448

;  449							if(!keys[V[x]])
.LINE 449

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_169
;  450								pc += 2;
.LINE 450

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  451							break;
.LINE 451

	JR	L_169
;  452						}
;  453					}
;  454					break;
;  455				}
;  456				case 0xf000: {
L_126:
.LINE 456

;  457					switch(opcode & 0x00ff) {
.LINE 457

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__50:
	DW	12
	DB	7
	DW24	L_127	

	DB	10
	DW24	L_128	

	DB	21
	DW24	L_135	

	DB	24
	DW24	L_137	

	DB	30
	DW24	L_138	

	DB	41
	DW24	L_139	

	DB	48
	DW24	L_140	

	DB	51
	DW24	L_141	

	DB	85
	DW24	L_142	

	DB	101
	DW24	L_147	

	DB	117
	DW24	L_152	

	DB	133
	DW24	L_159	

	DW24	L_169	

;  458						case 0x0007: {
L_127:
.LINE 458

;  459							V[x] = delay_timer;
.LINE 459

	LD	A,(_delay_timer)
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  460							break;
.LINE 460

	JR	L_169
;  461						}
;  462						case 0x000A: {
L_128:
.LINE 462

;  463							bool key_pressed = false;
.LINE 463

	LD	(IX+-18),0
;  464							pc -= 2;
.LINE 464

	LD	IY,(_pc)
	LEA	BC,IY+-2
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  465							
;  466							for(i = 0; i < 16; ++i) {
.LINE 466

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_132
L_130:
;  467								if(keys[i]) {
.LINE 467

	LD	BC,_keys
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_131
;  468									V[x] = i;
.LINE 468

	LD	B,(IX+-3)
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  469									pc += 2;
.LINE 469

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  470									key_pressed = true;
.LINE 470

	LD	(IX+-18),1
;  471									break;
.LINE 471

	JR	L_134
;  472								}
;  473							}
L_131:
.LINE 473

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_132:
	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_130
L_134:
;  474							
;  475							if(!key_pressed)
.LINE 475

	LD	A,(IX+-18)
	OR	A,A
	JR	Z,L_175
;  476								return;
.LINE 476

;  477						}
.LINE 477

;  478						case 0x0015: {
L_135:
.LINE 478

;  479							delay_timer = V[x];
.LINE 479

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  480							break;
.LINE 480

	JR	L_169
;  481						}
;  482						case 0x0018: {
L_137:
.LINE 482

;  483							sound_timer = V[x];
.LINE 483

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  484							break;
.LINE 484

	JR	L_169
;  485						}
;  486						case 0x001E: {
L_138:
.LINE 486

;  487							I = (I + V[x]) & 0xffff;
.LINE 487

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	DE,(_I)
	LD	HL,BC
	ADD.SIS	HL,DE
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  488							break;
.LINE 488

	JR	L_169
;  489						}
;  490						case 0x0029: {
L_139:
.LINE 490

;  491							I = (V[x] & 0xf) * 5;
.LINE 491

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	AND	A,15
	LD	C,A
	LD	B,0
	LD.LIS	HL,5
	CALL	__smulu
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  492							break;
.LINE 492

	JR	L_169
;  493						}
;  494						case 0x0030: {
L_140:
.LINE 494

;  495							I = (V[x] & 0xf) * 10 + 80;
.LINE 495

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	AND	A,15
	LD	C,A
	LD	B,0
	LD.LIS	HL,10
	CALL	__smulu
	LD	IY,HL
	LEA	BC,IY+80
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  496							break;
.LINE 496

	JR	L_169
;  497						}
;  498						case 0x0033: {
L_141:
.LINE 498

;  499							memory[ I ] = V[x] / 100;
.LINE 499

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-59),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,100
	CALL	__idivs
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  500							memory[I+1] = (V[x] / 10) % 10;
.LINE 500

	LD	HL,(IX+-59)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  501							memory[I+2] = V[x] % 10;
.LINE 501

	LD	HL,(IX+-59)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  502							break;
.LINE 502

	JR	L_169
;  503						}
;  504						case 0x0055: {
L_142:
.LINE 504

;  505							for(i = 0; i <= x; ++i) {
.LINE 505

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_145
L_143:
;  506								memory[I + i] = V[i];
.LINE 506

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  507							}
L_145:
.LINE 507

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	P,L_143
;  508							break;
.LINE 508

	JR	L_169
;  509						}
;  510						case 0x0065: {
L_147:
.LINE 510

;  511							for(i = 0; i <= x; ++i) {
.LINE 511

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_150
L_148:
;  512								V[i] = memory[I + i];
.LINE 512

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  513							}
L_150:
.LINE 513

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_148
;  514							break;
.LINE 514

	JR	L_169
;  515						}
;  516						case 0x0075: {
L_152:
.LINE 516

;  517							if (x > 7) x = 7;
.LINE 517

	LD	A,7
	CP	A,(IX+-4)
	JR	NC,L_157
	LD	(IX+-4),7
L_157:
;  518							for(i = 0; i <= x; ++i) {
.LINE 518

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_156
L_154:
;  519								SV[i] = V[i];
.LINE 519

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  520							}
L_156:
.LINE 520

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_154
;  521							break;
.LINE 521

	JR	L_169
;  522						}
;  523						case 0x0085: {
L_159:
.LINE 523

;  524							if (x > 7) x = 7;
.LINE 524

	LD	A,7
	CP	A,(IX+-4)
	JR	NC,L_164
	LD	(IX+-4),7
L_164:
;  525							for(i = 0; i <= x; ++i) {
.LINE 525

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_163
L_161:
;  526								V[i] = SV[i];
.LINE 526

	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  527							}
L_163:
.LINE 527

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_161
;  528							break;
;  529						}
;  530					}
;  531					break;
;  532				}
;  533				default:
;  534					break;
;  535			}
;  536		}
L_169:
.LINE 536

	LD	A,(_step)
	INC	A
	LD	(_step),A
L_170:
	LD	A,(_step)
	CP	A,(IX+6)
	JR	C,L_168
;  537		if(sound_timer > 0) {
.LINE 537

	LD	BC,(_sound_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_174
;  538			--sound_timer;
.LINE 538

	LD	BC,(_sound_timer)
	DEC	BC
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  539		}
L_174:
.LINE 539

;  540		if(delay_timer > 0) {
.LINE 540

	LD	BC,(_delay_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_175
;  541			--delay_timer;
.LINE 541

	LD	BC,(_delay_timer)
	DEC	BC
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  542		}
;  543	}
L_175:
.LINE 543

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emulateCycle ***************************
;Name                         Addr/Register   Size   Type
;_SV                                 STATIC      8   variable
;_sound_timer                        STATIC      2   variable
;_delay_timer                        STATIC      2   variable
;_keys                               STATIC     16   variable
;_index                              STATIC      2   variable
;__x                                 STATIC      1   variable
;_pixel                              STATIC      2   variable
;__y                                 STATIC      1   variable
;_rand                               IMPORT  -----   function
;_I                                  STATIC      2   variable
;_V                                  STATIC     16   variable
;_sprintf                            IMPORT  -----   function
;_playing                            STATIC      1   variable
;_memmove                            IMPORT  -----   function
;_stack                              STATIC     32   variable
;_sp                                 STATIC      1   variable
;_drawFlag                           STATIC      1   variable
;_memset                             IMPORT  -----   function
;_screen_width                       STATIC      1   variable
;_memcpy                             IMPORT  -----   function
;_screen_height                      STATIC      1   variable
;_canvas_data                        IMPORT   2050   variable
;_scanvas_data                       IMPORT   8194   variable
;_extendedScreen                     STATIC      1   variable
;_opcode                             STATIC      2   variable
;_pc                                 STATIC      2   variable
;_memory                             STATIC   4096   variable
;_step                               STATIC      1   variable
;_setKeys                            IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;temp89                               IX-23      3   variable
;n                                    IX-20      1   variable
;yd                                   IX-19      1   variable
;key_pressed                          IX-18      1   variable
;xd                                   IX-17      1   variable
;disp                                 IX-16      3   variable
;disp                                 IX-13      3   variable
;disp                                 IX-10      3   variable
;cols                                  IX-7      1   variable
;height                                IX-6      1   variable
;y                                     IX-5      1   variable
;x                                     IX-4      1   variable
;i                                     IX-3      3   variable
;steps                                 IX+6      1   parameter


; Stack Frame Size: 83 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emulateCycle",543,"_emulateCycle"
	SEGMENT STRSECT
L__18:
	DB	"Extended mode off"
	DB	10,0
L__19:
	DB	"Extended mode on"
	DB	10,0
	XREF _scanvas_data:ROM
	XREF _canvas_data:ROM
	XREF _kb_Scan:ROM
	XREF _memmove:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _sprintf:ROM
	XREF _ti_GetSize:ROM
	XREF _ti_Read:ROM
	XREF _ti_Open:ROM
	XREF _ti_CloseAll:ROM
	XREF _rand:ROM
	XREF _srand:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __sor:ROM
	XREF __sand:ROM
	XREF __iand:ROM
	XREF __smulu:ROM
	XREF __irems:ROM
	XREF __ishrs:ROM
	XREF __stoiu:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __case8D:ROM
	XREF __case16D:ROM
	XREF __ishrs_b:ROM
	XREF __sshru_b:ROM
	XDEF _emulateCycle
	XDEF _setKeys
	XDEF _loadProgram
	XDEF _initialize
	XDEF _screen_height
	XDEF _screen_width
	XDEF __x
	XDEF __y
	XDEF _index
	XDEF _pixel
	XDEF _step
	XDEF _fontset_ten
	XDEF _fontset
	XDEF _file
	XDEF _controlMap
	XDEF _keypad
	XDEF _game_data
	XDEF _extendedScreen
	XDEF _playing
	XDEF _paused
	XDEF _drawFlag
	XDEF _keys
	XDEF _sp
	XDEF _stack
	XDEF _sound_timer
	XDEF _delay_timer
	XDEF _pc
	XDEF _I
	XDEF _V
	XDEF _SV
	XDEF _memory
	XDEF _opcode
	END
