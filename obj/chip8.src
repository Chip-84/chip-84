; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\CHIP8.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME1"
.TYPE 104
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME7"
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME8",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME10"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME10",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME10"
.BEGREC "__stdio_file",1
.DEFINE "slot"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "__stdio_file"
	SEGMENT DATA
_opcode:
	DW	0
.DEFINE "opcode"
.ALIAS "_opcode"
.CLASS 69
.VALUE _opcode
.TYPE 13
.ENDEF
	SEGMENT BSS
_memory:
	DS	4096
.DEFINE "memory"
.ALIAS "_memory"
.CLASS 83
.VALUE _memory
.DIM 4096
.TYPE 108
.ENDEF
_SV:
	DS	8
.DEFINE "SV"
.ALIAS "_SV"
.CLASS 83
.VALUE _SV
.DIM 8
.TYPE 108
.ENDEF
_V:
	DS	16
.DEFINE "V"
.ALIAS "_V"
.CLASS 83
.VALUE _V
.DIM 16
.TYPE 108
.ENDEF
	SEGMENT DATA
_I:
	DW	0
.DEFINE "I"
.ALIAS "_I"
.CLASS 69
.VALUE _I
.TYPE 13
.ENDEF
_pc:
	DW	0
.DEFINE "pc"
.ALIAS "_pc"
.CLASS 69
.VALUE _pc
.TYPE 13
.ENDEF
_delay_timer:
	DW	0
.DEFINE "delay_timer"
.ALIAS "_delay_timer"
.CLASS 69
.VALUE _delay_timer
.TYPE 3
.ENDEF
_sound_timer:
	DW	0
.DEFINE "sound_timer"
.ALIAS "_sound_timer"
.CLASS 69
.VALUE _sound_timer
.TYPE 3
.ENDEF
	SEGMENT BSS
_stack:
	DS	32
.DEFINE "stack"
.ALIAS "_stack"
.CLASS 83
.VALUE _stack
.DIM 16
.TYPE 109
.ENDEF
	SEGMENT DATA
_sp:
	DB	0
.DEFINE "sp"
.ALIAS "_sp"
.CLASS 69
.VALUE _sp
.TYPE 12
.ENDEF
_keys:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
.DEFINE "keys"
.ALIAS "_keys"
.CLASS 69
.VALUE _keys
.DIM 16
.TYPE 108
.ENDEF
_drawFlag:
	DB	0
.DEFINE "drawFlag"
.ALIAS "_drawFlag"
.CLASS 69
.VALUE _drawFlag
.TYPE 12
.ENDEF
_paused:
	DB	0
.DEFINE "paused"
.ALIAS "_paused"
.CLASS 69
.VALUE _paused
.TYPE 12
.ENDEF
_playing:
	DB	0
.DEFINE "playing"
.ALIAS "_playing"
.CLASS 69
.VALUE _playing
.TYPE 12
.ENDEF
_extendedScreen:
	DB	0
.DEFINE "extendedScreen"
.ALIAS "_extendedScreen"
.CLASS 69
.VALUE _extendedScreen
.TYPE 12
.ENDEF
	SEGMENT BSS
_game_data:
	DS	3584
.DEFINE "game_data"
.ALIAS "_game_data"
.CLASS 83
.VALUE _game_data
.DIM 3584
.TYPE 108
.ENDEF
_keypad:
	DS	16
.DEFINE "keypad"
.ALIAS "_keypad"
.CLASS 83
.VALUE _keypad
.DIM 16
.TYPE 108
.ENDEF
_controlMap:
	DS	16
.DEFINE "controlMap"
.ALIAS "_controlMap"
.CLASS 83
.VALUE _controlMap
.DIM 16
.TYPE 108
.ENDEF
_file:
	DS	1
.DEFINE "file"
.ALIAS "_file"
.CLASS 83
.VALUE _file
.TYPE 12
.ENDEF
	SEGMENT DATA
_fontset:
	DB	240
	DB	144
	DB	144
	DB	144
	DB	240
	DB	32
	DB	96
	DB	32
	DB	32
	DB	112
	DB	240
	DB	16
	DB	240
	DB	128
	DB	240
	DB	240
	DB	16
	DB	240
	DB	16
	DB	240
	DB	144
	DB	144
	DB	240
	DB	16
	DB	16
	DB	240
	DB	128
	DB	240
	DB	16
	DB	240
	DB	240
	DB	128
	DB	240
	DB	144
	DB	240
	DB	240
	DB	16
	DB	32
	DB	64
	DB	64
	DB	240
	DB	144
	DB	240
	DB	144
	DB	240
	DB	240
	DB	144
	DB	240
	DB	16
	DB	240
	DB	240
	DB	144
	DB	240
	DB	144
	DB	144
	DB	224
	DB	144
	DB	224
	DB	144
	DB	224
	DB	240
	DB	128
	DB	128
	DB	128
	DB	240
	DB	224
	DB	144
	DB	144
	DB	144
	DB	224
	DB	240
	DB	128
	DB	240
	DB	128
	DB	240
	DB	240
	DB	128
	DB	240
	DB	128
	DB	128
.DEFINE "fontset"
.ALIAS "_fontset"
.CLASS 69
.VALUE _fontset
.DIM 80
.TYPE 108
.ENDEF
_fontset_ten:
	DW	50812
	DW	57038
	DW	63190
	DW	50918
	DW	124
	DW	12304
	DW	12528
	DW	12336
	DW	12336
	DW	252
	DW	52344
	DW	3276
	DW	12312
	DW	52320
	DW	252
	DW	52344
	DW	3084
	DW	3128
	DW	52236
	DW	120
	DW	7180
	DW	27708
	DW	65228
	DW	3084
	DW	30
	DW	49404
	DW	49344
	DW	3320
	DW	52236
	DW	120
	DW	24632
	DW	49344
	DW	52472
	DW	52428
	DW	120
	DW	50942
	DW	1734
	DW	6156
	DW	12336
	DW	48
	DW	52344
	DW	60620
	DW	56440
	DW	52428
	DW	120
	DW	50812
	DW	50886
	DW	3198
	DW	12312
	DW	112
	DW	30768
	DW	52428
	DW	64716
	DW	52428
	DW	204
	DW	26364
	DW	26214
	DW	26236
	DW	26214
	DW	252
	DW	26172
	DW	49350
	DW	49344
	DW	26310
	DW	60
	DW	27896
	DW	26214
	DW	26214
	DW	27750
	DW	248
	DW	25342
	DW	25696
	DW	25724
	DW	25184
	DW	254
	DW	26366
	DW	25698
	DW	25724
	DW	24672
	DW	240
.DEFINE "fontset_ten"
.ALIAS "_fontset_ten"
.CLASS 69
.VALUE _fontset_ten
.DIM 80
.TYPE 109
.ENDEF
	SEGMENT BSS
_step:
	DS	1
.DEFINE "step"
.ALIAS "_step"
.CLASS 83
.VALUE _step
.TYPE 12
.ENDEF
_pixel:
	DS	2*1
.DEFINE "pixel"
.ALIAS "_pixel"
.CLASS 83
.VALUE _pixel
.TYPE 13
.ENDEF
_index:
	DS	2*1
.DEFINE "index"
.ALIAS "_index"
.CLASS 83
.VALUE _index
.TYPE 13
.ENDEF
__y:
	DS	1
.DEFINE "_y"
.ALIAS "__y"
.CLASS 83
.VALUE __y
.TYPE 12
.ENDEF
__x:
	DS	1
.DEFINE "_x"
.ALIAS "__x"
.CLASS 83
.VALUE __x
.TYPE 12
.ENDEF
_screen_width:
	DS	1
.DEFINE "screen_width"
.ALIAS "_screen_width"
.CLASS 83
.VALUE _screen_width
.TYPE 12
.ENDEF
_screen_height:
	DS	1
.DEFINE "screen_height"
.ALIAS "_screen_height"
.CLASS 83
.VALUE _screen_height
.TYPE 12
.ENDEF
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <debug.h>
;    6	
;    7	#include <math.h>
;    8	#include <stdio.h>
;    9	#include <stdlib.h>
;   10	#include <string.h>
;   11	
;   12	#include <fileioc.h>
;   13	#include <keypadc.h>
;   14	
;   15	#include "chip8.h"
;   16	#include "sprites_gfx.h"
;   17	
;   18	uint16_t opcode = 0;
;   19	uint8_t memory[4096];
;   20	uint8_t SV[8];
;   21	uint8_t V[16];
;   22	uint16_t I = 0;
;   23	uint16_t pc = 0;
;   24	int16_t delay_timer = 0;
;   25	int16_t sound_timer = 0;
;   26	uint16_t stack[16];
;   27	uint8_t sp = 0;
;   28	uint8_t keys[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;   29	bool drawFlag = false;
;   30	
;   31	bool paused = false;
;   32	bool playing = false;
;   33	bool extendedScreen = 0;
;   34	
;   35	uint8_t game_data[3584];
;   36	uint8_t keypad[16];
;   37	uint8_t controlMap[16];
;   38	
;   39	ti_var_t file;
;   40	
;   41	unsigned char fontset[80] = {
;   42	    0xF0, 0x90, 0x90, 0x90, 0xF0, //0
;   43	    0x20, 0x60, 0x20, 0x20, 0x70, //1
;   44	    0xF0, 0x10, 0xF0, 0x80, 0xF0, //2
;   45	    0xF0, 0x10, 0xF0, 0x10, 0xF0, //3
;   46	    0x90, 0x90, 0xF0, 0x10, 0x10, //4
;   47	    0xF0, 0x80, 0xF0, 0x10, 0xF0, //5
;   48	    0xF0, 0x80, 0xF0, 0x90, 0xF0, //6
;   49	    0xF0, 0x10, 0x20, 0x40, 0x40, //7
;   50	    0xF0, 0x90, 0xF0, 0x90, 0xF0, //8
;   51	    0xF0, 0x90, 0xF0, 0x10, 0xF0, //9
;   52	    0xF0, 0x90, 0xF0, 0x90, 0x90, //A
;   53	    0xE0, 0x90, 0xE0, 0x90, 0xE0, //B
;   54	    0xF0, 0x80, 0x80, 0x80, 0xF0, //C
;   55	    0xE0, 0x90, 0x90, 0x90, 0xE0, //D
;   56	    0xF0, 0x80, 0xF0, 0x80, 0xF0, //E
;   57	    0xF0, 0x80, 0xF0, 0x80, 0x80  //F
;   58	};
;   59	uint16_t  fontset_ten[80] = {
;   60		0xC67C, 0xDECE, 0xF6D6, 0xC6E6, 0x007C, // 0
;   61		0x3010, 0x30F0, 0x3030, 0x3030, 0x00FC, // 1
;   62		0xCC78, 0x0CCC, 0x3018, 0xCC60, 0x00FC, // 2
;   63		0xCC78, 0x0C0C, 0x0C38, 0xCC0C, 0x0078, // 3
;   64		0x1C0C, 0x6C3C, 0xFECC, 0x0C0C, 0x001E, // 4
;   65		0xC0FC, 0xC0C0, 0x0CF8, 0xCC0C, 0x0078, // 5
;   66		0x6038, 0xC0C0, 0xCCF8, 0xCCCC, 0x0078, // 6
;   67		0xC6FE, 0x06C6, 0x180C, 0x3030, 0x0030, // 7
;   68		0xCC78, 0xECCC, 0xDC78, 0xCCCC, 0x0078, // 8
;   69		0xC67C, 0xC6C6, 0x0C7E, 0x3018, 0x0070, // 9
;   70		0x7830, 0xCCCC, 0xFCCC, 0xCCCC, 0x00CC, // A
;   71		0x66FC, 0x6666, 0x667C, 0x6666, 0x00FC, // B
;   72		0x663C, 0xC0C6, 0xC0C0, 0x66C6, 0x003C, // C
;   73		0x6CF8, 0x6666, 0x6666, 0x6C66, 0x00F8, // D
;   74		0x62FE, 0x6460, 0x647C, 0x6260, 0x00FE, // E
;   75		0x66FE, 0x6462, 0x647C, 0x6060, 0x00F0  // F
;   76	};
;   77	
;   78	uint8_t step;
;   79	uint16_t pixel;
;   80	uint16_t index;
;   81	
;   82	uint8_t _y;
;   83	uint8_t _x;
;   84	
;   85	uint8_t screen_width;
;   86	uint8_t screen_height;
	SEGMENT CODE
;   87	
;   88	void initialize() {
_initialize:
.DEFINE "_initialize"

.VALUE _initialize

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initialize",88,"_initialize"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   89		
;   90		opcode = I = sp = delay_timer = sound_timer = 0;
.LINE 90

	LD	HL,_sound_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_delay_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	XOR	A,A
	LD	(_sp),A
	LD	HL,_I
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_opcode
	LD	(HL),0
	INC	HL
	LD	(HL),0
;   91		pc = 0x200;
.LINE 91

	LD	HL,_pc
	LD	(HL),0
	INC	HL
	LD	(HL),2
;   92		
;   93		extendedScreen = 0;
.LINE 93

	XOR	A,A
	LD	(_extendedScreen),A
;   94		screen_width = 64;
.LINE 94

	LD	A,64
	LD	(_screen_width),A
;   95		screen_height = 32;
.LINE 95

	LD	A,32
	LD	(_screen_height),A
;   96		
;   97		scanvas_data[0] = 128;
.LINE 97

	LD	A,128
	LD	(_scanvas_data),A
;   98		scanvas_data[1] = 64;
.LINE 98

	LD	HL,_scanvas_data
	INC	HL
	LD	(HL),64
;   99		memset(scanvas_data + 2, 0, 8192);
.LINE 99

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  100	
;  101		canvas_data[0] = 64;
.LINE 101

	LD	A,64
	LD	(_canvas_data),A
;  102		canvas_data[1] = 32;
.LINE 102

	LD	HL,_canvas_data
	INC	HL
	LD	(HL),32
;  103		memset(canvas_data + 2, 0, 2048);
.LINE 103

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  104			
;  105		memset(keys, 0, 16);
.LINE 105

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_keys
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  106		memset(stack, 0, 16);
.LINE 106

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_stack
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  107		memset(V, 0, 16);
.LINE 107

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_V
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  108		memset(SV, 0, 8);
.LINE 108

	LD	BC,8
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_SV
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  109		memset(memory, 0, 4096);
.LINE 109

	LD	BC,4096
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  110		
;  111		memcpy(memory, fontset, 80);
.LINE 111

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  112		memcpy(memory + 80, fontset_ten, 80);
.LINE 112

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset_ten
	PUSH	BC
	LD	BC,_memory+80
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  113		
;  114		srand(rtc_Time());
.LINE 114

	LD	BC,(15925316)
	PUSH	BC
	CALL	_srand
	POP	BC
;  115	}
.LINE 115

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initialize ***************************
;Name                         Addr/Register   Size   Type
;_srand                              IMPORT  -----   function
;_fontset_ten                        STATIC    160   variable
;_fontset                            STATIC     80   variable
;_memcpy                             IMPORT  -----   function
;_memory                             STATIC   4096   variable
;_SV                                 STATIC      8   variable
;_V                                  STATIC     16   variable
;_stack                              STATIC     32   variable
;_keys                               STATIC     16   variable
;_canvas_data                        IMPORT   2050   variable
;_memset                             IMPORT  -----   function
;_scanvas_data                       IMPORT   8194   variable
;_screen_height                      STATIC      1   variable
;_screen_width                       STATIC      1   variable
;_extendedScreen                     STATIC      1   variable
;_pc                                 STATIC      2   variable
;_opcode                             STATIC      2   variable
;_I                                  STATIC      2   variable
;_sp                                 STATIC      1   variable
;_delay_timer                        STATIC      2   variable
;_sound_timer                        STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initialize",115,"_initialize"
;  116	
;  117	void loadProgram(char *fileName) {
_loadProgram:
.DEFINE "_loadProgram"

.VALUE _loadProgram

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "loadProgram",117,"_loadProgram"

.LINE 117

.DEFINE "fileName"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "romSize"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;  118		int i;
;  119		uint16_t romSize;
;  120		
;  121		playing = true;
.LINE 121

	LD	A,1
	LD	(_playing),A
;  122		paused = false;
.LINE 122

	XOR	A,A
	LD	(_paused),A
;  123		
;  124		ti_CloseAll();
.LINE 124

	CALL	_ti_CloseAll
;  125		file = ti_Open(fileName, "r");
.LINE 125

	LD	BC,L__1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(_file),A
;  126		ti_Read(&game_data, ti_GetSize(file), 1, file);
.LINE 126

	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	PUSH	HL
	LD	BC,_game_data
	PUSH	BC
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  127		
;  128		romSize = ti_GetSize(file)-(16+6);
.LINE 128

	LD	A,(_file)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	IY,HL
	LEA	HL,IY+-22
	LD	(IX+-5),L
	LD	(IX+-4),H
;  129		dbg_sprintf(dbgout, "%d ", romSize);
.LINE 129

	LD	BC,(IX+-5)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__2
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  130		
;  131		initialize();
.LINE 131

	CALL	_initialize
;  132		
;  133		if((4096-512) > romSize) {
.LINE 133

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,3584
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_9
;  134			for(i = 0; i < romSize; ++i) {
.LINE 134

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
;  135				memory[i + 512] = (uint8_t)game_data[i+16+6];
.LINE 135

	LD	IY,(IX+-3)
	LEA	HL,IY+22
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,512
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  136			}
L_3:
.LINE 136

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
;  137		}
L_9:
.LINE 137

;  138		for(i = 0; i < 16; i++) {
.LINE 138

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_8
L_6:
;  139			controlMap[i] = (uint8_t)game_data[i+6];
.LINE 139

	LD	IY,(IX+-3)
	LEA	HL,IY+6
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_controlMap
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  140		}
L_8:
.LINE 140

	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_6
;  141	}
.LINE 141

	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadProgram ***************************
;Name                         Addr/Register   Size   Type
;_controlMap                         STATIC     16   variable
;_memory                             STATIC   4096   variable
;_initialize                         IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_game_data                          STATIC   3584   variable
;_ti_GetSize                         IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_file                               STATIC      1   variable
;_ti_Open                            IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_paused                             STATIC      1   variable
;_playing                            STATIC      1   variable
;romSize                               IX-5      2   variable
;i                                     IX-3      3   variable
;fileName                              IX+6      3   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "loadProgram",141,"_loadProgram"
	SEGMENT STRSECT
L__1:
	DB	"r"
	DB	0
L__2:
	DB	"%d "
	DB	0
	SEGMENT CODE
;  142	
;  143	void setKeys() {
_setKeys:
.DEFINE "_setKeys"

.VALUE _setKeys

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setKeys",143,"_setKeys"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  144		keypad[0x0] = kb_Data[4] & kb_DecPnt;
.LINE 144

	LD	A,(16056344)
	AND	A,1
	LD	(_keypad),A
;  145		keypad[0x1] = kb_Data[3] & kb_7;
.LINE 145

	LD	A,(16056342)
	AND	A,8
	LD	HL,_keypad
	INC	HL
	LD	(HL),A
;  146		keypad[0x2] = kb_Data[4] & kb_8;
.LINE 146

	LD	A,(16056344)
	AND	A,8
	LD	IY,_keypad
	LEA	HL,IY+2
	LD	(HL),A
;  147		keypad[0x3] = kb_Data[5] & kb_9;
.LINE 147

	LD	A,(16056346)
	AND	A,8
	LEA	HL,IY+3
	LD	(HL),A
;  148		keypad[0x4] = kb_Data[3] & kb_4;
.LINE 148

	LD	A,(16056342)
	AND	A,4
	LEA	HL,IY+4
	LD	(HL),A
;  149		keypad[0x5] = kb_Data[4] & kb_5;
.LINE 149

	LD	A,(16056344)
	AND	A,4
	LEA	HL,IY+5
	LD	(HL),A
;  150		keypad[0x6] = kb_Data[5] & kb_6;
.LINE 150

	LD	A,(16056346)
	AND	A,4
	LEA	HL,IY+6
	LD	(HL),A
;  151		keypad[0x7] = kb_Data[3] & kb_1;
.LINE 151

	LD	A,(16056342)
	AND	A,2
	LEA	HL,IY+7
	LD	(HL),A
;  152		keypad[0x8] = kb_Data[4] & kb_2;
.LINE 152

	LD	A,(16056344)
	AND	A,2
	LEA	HL,IY+8
	LD	(HL),A
;  153		keypad[0x9] = kb_Data[5] & kb_3;
.LINE 153

	LD	A,(16056346)
	AND	A,2
	LEA	HL,IY+9
	LD	(HL),A
;  154		keypad[0xA] = kb_Data[3] & kb_0;
.LINE 154

	LD	A,(16056342)
	AND	A,1
	LEA	HL,IY+10
	LD	(HL),A
;  155		keypad[0xB] = kb_Data[5] & kb_Chs;
.LINE 155

	LD	A,(16056346)
	AND	A,1
	LEA	HL,IY+11
	LD	(HL),A
;  156		keypad[0xC] = kb_Data[6] & kb_Mul;
.LINE 156

	LD	A,(16056348)
	AND	A,8
	LEA	HL,IY+12
	LD	(HL),A
;  157		keypad[0xD] = kb_Data[6] & kb_Sub;
.LINE 157

	LD	A,(16056348)
	AND	A,4
	LEA	HL,IY+13
	LD	(HL),A
;  158		keypad[0xE] = kb_Data[6] & kb_Add;
.LINE 158

	LD	A,(16056348)
	AND	A,2
	LEA	HL,IY+14
	LD	(HL),A
;  159		keypad[0xF] = kb_Data[6] & kb_Enter;
.LINE 159

	LD	A,(16056348)
	AND	A,1
	LD	HL,_keypad+15
	LD	(HL),A
;  160		
;  161		keys[0x0] = keypad[controlMap[0x0]];
.LINE 161

	LD	A,(_controlMap)
	UEXT	HL
	LD	L,A
	LD	BC,_keypad
	ADD	HL,BC
	LD	A,(HL)
	LD	(_keys),A
;  162		keys[0x1] = keypad[controlMap[0x1]];
.LINE 162

	LD	HL,_controlMap
	INC	HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,_keys
	LD	A,(HL)
	LD	(IY+1),A
;  163		keys[0x2] = keypad[controlMap[0x2]];
.LINE 163

	LD	HL,_controlMap+2
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+2),A
;  164		keys[0x3] = keypad[controlMap[0x3]];
.LINE 164

	LD	HL,_controlMap+3
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+3),A
;  165		                              
;  166		keys[0x4] = keypad[controlMap[0x4]];
.LINE 166

	LD	HL,_controlMap+4
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+4),A
;  167		keys[0x5] = keypad[controlMap[0x5]];
.LINE 167

	LD	HL,_controlMap+5
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+5),A
;  168		keys[0x6] = keypad[controlMap[0x6]];
.LINE 168

	LD	HL,_controlMap+6
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+6),A
;  169		keys[0x7] = keypad[controlMap[0x7]];
.LINE 169

	LD	HL,_controlMap+7
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+7),A
;  170		                              
;  171		keys[0x8] = keypad[controlMap[0x8]];
.LINE 171

	LD	HL,_controlMap+8
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+8),A
;  172		keys[0x9] = keypad[controlMap[0x9]];
.LINE 172

	LD	HL,_controlMap+9
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+9),A
;  173		keys[0xA] = keypad[controlMap[0xA]];
.LINE 173

	LD	HL,_controlMap+10
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+10),A
;  174		keys[0xB] = keypad[controlMap[0xB]];
.LINE 174

	LD	HL,_controlMap+11
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+11),A
;  175		                              
;  176		keys[0xC] = keypad[controlMap[0xC]];
.LINE 176

	LD	HL,_controlMap+12
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+12),A
;  177		keys[0xD] = keypad[controlMap[0xD]];
.LINE 177

	LD	HL,_controlMap+13
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+13),A
;  178		keys[0xE] = keypad[controlMap[0xE]];
.LINE 178

	LD	HL,_controlMap+14
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+14),A
;  179		keys[0xF] = keypad[controlMap[0xF]];
.LINE 179

	LD	HL,_controlMap+15
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+15),A
;  180		
;  181		if(kb_Data[1] & kb_2nd) {
.LINE 181

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_11
	JR	L_15
;  182			while(kb_Data[1] & kb_2nd) {
L_12:
.LINE 182

;  183				kb_Scan();
.LINE 183

	CALL	_kb_Scan
;  184			}
L_11:
.LINE 184

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_12
;  185			paused = 1;
.LINE 185

	LD	A,1
	LD	(_paused),A
;  186		}
;  187	}
L_15:
.LINE 187

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setKeys ***************************
;Name                         Addr/Register   Size   Type
;_paused                             STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_keys                               STATIC     16   variable
;_controlMap                         STATIC     16   variable
;_keypad                             STATIC     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setKeys",187,"_setKeys"
;  188	
;  189	void emulateCycle(uint8_t steps) {
_emulateCycle:
.DEFINE "_emulateCycle"

.VALUE _emulateCycle

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emulateCycle",189,"_emulateCycle"

.LINE 189

.DEFINE "steps"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "cols"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -10

.TYPE 44

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -13

.TYPE 44

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -16

.TYPE 44

.ENDEF

.DEFINE "xd"

.CLASS 65

.VALUE -17

.TYPE 12

.ENDEF

.DEFINE "key_pressed"

.CLASS 65

.VALUE -18

.TYPE 12

.ENDEF

.DEFINE "yd"

.CLASS 65

.VALUE -19

.TYPE 12

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -20

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-80
	LD	SP,HL
;  190		
;  191		kb_Scan();
.LINE 191

	CALL	_kb_Scan
;  192		setKeys();
.LINE 192

	CALL	_setKeys
;  193		
;  194		for(step = 0; step < steps; ++step) {
.LINE 194

	XOR	A,A
	LD	(_step),A
	JR	L_166
L_164:
;  195			int i;
;  196			uint8_t x;
;  197			uint8_t y;
;  198			opcode = (memory[pc] << 8) | memory[pc+1];
.LINE 198

	LD	BC,(_pc)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	H,L
	LD	L,0
	LD	DE,HL
	LD	BC,(_pc)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,DE
	CALL	__sor
	LD	BC,HL
	LD	HL,_opcode
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  199			x = (opcode & 0x0f00) >> 8;
.LINE 199

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-4),A
;  200			y = (opcode & 0x00f0) >> 4;
.LINE 200

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-5),A
;  201			
;  202			pc += 2;
.LINE 202

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  203			dbg_sprintf(dbgout, "%x \n", opcode);
.LINE 203

	LD	BC,(_opcode)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__10
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  204			switch(opcode & 0xf000) {
.LINE 204

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	BC,61440
	CALL	__iand
	CALL	__case16D
	JP	(HL)
L__11:
	DW	16
	DW	0
	DW24	L_16	

	DW	4096
	DW24	L_55	

	DW	8192
	DW24	L_56	

	DW	12288
	DW24	L_58	

	DW	16384
	DW24	L_61	

	DW	20480
	DW24	L_64	

	DW	24576
	DW24	L_67	

	DW	28672
	DW24	L_68	

	DW	32768
	DW24	L_69	

	DW	36864
	DW24	L_80	

	DW	40960
	DW24	L_83	

	DW	45056
	DW24	L_84	

	DW	49152
	DW24	L_85	

	DW	53248
	DW24	L_86	

	DW	57344
	DW24	L_114	

	DW	61440
	DW24	L_122	

	DW24	L_165	

;  205				case 0x0000: {
L_16:
.LINE 205

;  206					switch(opcode & 0x00f0) {
.LINE 206

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,240
	UEXT	HL
	LD	L,A
	LD	BC,192
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_53
;  207						case 0x00c0: { //SCD
.LINE 207

;  208							uint8_t n = (opcode & 0x000f);
.LINE 208

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-20),A
;  209							uint8_t *disp;
;  210							
;  211							if(extendedScreen) {
.LINE 211

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_19
;  212								disp = &scanvas_data[2];
.LINE 212

	LD	BC,_scanvas_data+2
	LD	(IX+-16),BC
;  213							} else {
.LINE 213

	JR	L_24
L_19:
;  214								disp = &canvas_data[2];
.LINE 214

	LD	BC,_canvas_data+2
	LD	(IX+-16),BC
;  215							}
L_24:
.LINE 215

;  216							for(i = screen_height-2; i >= 0; i--) {
.LINE 216

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	DEC	HL
	DEC	HL
	LD	(IX+-3),HL
	JR	L_23
L_21:
;  217								memcpy(disp + (i+n)*screen_width, disp + i*screen_width, screen_width);
.LINE 217

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-16)
	ADD	HL,BC
	PUSH	HL
	LD	A,(IX+-20)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	DE,HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,(IX+-16)
	ADD	HL,BC
	PUSH	HL
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  218								memset(disp + i*screen_width, 0, screen_width);
.LINE 218

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-16)
	ADD	HL,BC
	PUSH	HL
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
;  219							}
L_23:
.LINE 219

	LD	HL,(IX+-3)
	CALL	__icmpzero
	JP	P,L_21
;  220							
;  221							drawFlag = true; 
.LINE 221

	LD	A,1
	LD	(_drawFlag),A
;  222							
;  223							break;
;  224						}
;  225						break;
;  226					}
L_53:
.LINE 226

;  227					switch(opcode & 0x00ff) {
.LINE 227

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__14:
	DW	7
	DB	224
	DW24	L_26	

	DB	238
	DW24	L_30	

	DB	251
	DW24	L_31	

	DB	252
	DW24	L_40	

	DB	253
	DW24	L_49	

	DB	254
	DW24	L_50	

	DB	255
	DW24	L_51	

	DW24	L_52	

;  228						case 0x00e0:
L_26:
.LINE 228

;  229							if(extendedScreen)
.LINE 229

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_28
;  230								memset(scanvas_data + 2, 0, 8192);
.LINE 230

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  231							else
.LINE 231

	JR	L_29
L_28:
;  232								memset(canvas_data + 2, 0, 2048);
.LINE 232

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
L_29:
;  233							drawFlag = true;
.LINE 233

	LD	A,1
	LD	(_drawFlag),A
;  234							break;
.LINE 234

	JR	L_165
;  235						case 0x00ee:
L_30:
.LINE 235

;  236							pc = stack[(--sp)&0xf];
.LINE 236

	LD	A,(_sp)
	DEC	A
	LD	(_sp),A
	AND	A,15
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	BC,(HL)
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  237							break;
.LINE 237

	JR	L_165
;  238						case 0x00fb: { //SCR
L_31:
.LINE 238

;  239							uint8_t *disp;
;  240							
;  241							if(extendedScreen) {
.LINE 241

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_33
;  242								disp = &scanvas_data[2];
.LINE 242

	LD	BC,_scanvas_data+2
	LD	(IX+-10),BC
;  243							} else {
.LINE 243

	JR	L_38
L_33:
;  244								disp = &canvas_data[2];
.LINE 244

	LD	BC,_canvas_data+2
	LD	(IX+-10),BC
;  245							}
L_38:
.LINE 245

;  246							for(i = 0; i < screen_height; i++) {
.LINE 246

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_37
L_35:
;  247								memmove(disp + 4, disp, screen_width - 4);
.LINE 247

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	LD	IY,(IX+-10)
	LEA	BC,IY+4
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  248								memset(disp, 0, 4);
.LINE 248

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  249								disp += screen_width;
.LINE 249

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-10)
	ADD	HL,BC
	LD	(IX+-10),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  250							}
L_37:
.LINE 250

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_35
;  251							break;
.LINE 251

	JR	L_165
;  252						}
;  253						case 0x00fc: { //SCL
L_40:
.LINE 253

;  254							uint8_t *disp;
;  255							
;  256							if(extendedScreen) {
.LINE 256

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_42
;  257								disp = &scanvas_data[2];
.LINE 257

	LD	BC,_scanvas_data+2
	LD	(IX+-13),BC
;  258							} else {
.LINE 258

	JR	L_47
L_42:
;  259								disp = &canvas_data[2];
.LINE 259

	LD	BC,_canvas_data+2
	LD	(IX+-13),BC
;  260							}
L_47:
.LINE 260

;  261							for(i = 0; i < screen_height; i++) {
.LINE 261

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_46
L_44:
;  262								memmove(disp, disp + 4, screen_width - 4);
.LINE 262

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	IY,(IX+-13)
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  263								memset(disp + screen_width - 4, 0, 4);
.LINE 263

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-13)
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  264								disp += screen_width;
.LINE 264

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-13)
	ADD	HL,BC
	LD	(IX+-13),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  265							}
L_46:
.LINE 265

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_44
;  266							break;
.LINE 266

	JR	L_165
;  267						}
;  268						case 0x00fd:
L_49:
.LINE 268

;  269							playing = 0;
.LINE 269

	XOR	A,A
	LD	(_playing),A
;  270							//exit
;  271							break;
.LINE 271

	JR	L_165
;  272						case 0x00fe:
L_50:
.LINE 272

;  273							extendedScreen = 0;
.LINE 273

	XOR	A,A
	LD	(_extendedScreen),A
;  274							screen_width = 64;
.LINE 274

	LD	A,64
	LD	(_screen_width),A
;  275							screen_height = 32;
.LINE 275

	LD	A,32
	LD	(_screen_height),A
;  276							memcpy(canvas_data + 2, scanvas_data + 2, 2048);
.LINE 276

	LD	BC,2048
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  277							dbg_sprintf(dbgout, "Extended mode off\n");
.LINE 277

	LD	BC,L__20
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  278							break;
.LINE 278

	JR	L_165
;  279						case 0x00ff:
L_51:
.LINE 279

;  280							extendedScreen = 1;
.LINE 280

	LD	A,1
	LD	(_extendedScreen),A
;  281							screen_width = 128;
.LINE 281

	LD	A,128
	LD	(_screen_width),A
;  282							screen_height = 64;
.LINE 282

	LD	A,64
	LD	(_screen_height),A
;  283							memcpy(scanvas_data + 2, canvas_data + 2, 2048);
.LINE 283

	LD	BC,2048
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  284							dbg_sprintf(dbgout, "Extended mode on\n");
.LINE 284

	LD	BC,L__21
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  285							break;
.LINE 285

	JR	L_165
;  286						default:
L_52:
.LINE 286

;  287							pc = (pc & 0x0fff);
.LINE 287

	LD	HL,(_pc)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  288							break;
.LINE 288

	JR	L_165
;  289					}
;  290					break;
;  291				}
;  292				case 0x1000: {
L_55:
.LINE 292

;  293					pc = (opcode & 0x0fff);
.LINE 293

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  294					break;
.LINE 294

	JR	L_165
;  295				}
;  296				case 0x2000: {
L_56:
.LINE 296

;  297					stack[sp++] = pc;
.LINE 297

	LD	A,(_sp)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	A,(_pc)
	LD	(HL),A
	INC	HL
	LD	A,(_pc+1)
	LD	(HL),A
	LD	A,(_sp)
	INC	A
	LD	(_sp),A
;  298					pc = (opcode & 0x0fff);
.LINE 298

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  299					break;
.LINE 299

	JR	L_165
;  300				}
;  301				case 0x3000: {
L_58:
.LINE 301

;  302					if(V[x] == (opcode & 0x00ff))
.LINE 302

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_165
;  303						pc += 2;
.LINE 303

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  304					break;
.LINE 304

	JR	L_165
;  305				}
;  306				case 0x4000: {
L_61:
.LINE 306

;  307					if(V[x] != (opcode & 0x00ff))
.LINE 307

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	Z,L_165
;  308						pc += 2;
.LINE 308

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  309					break;
.LINE 309

	JR	L_165
;  310				}
;  311				case 0x5000: {
L_64:
.LINE 311

;  312					if(V[x] == V[y])
.LINE 312

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	NZ,L_165
;  313						pc += 2;
.LINE 313

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  314					break;
.LINE 314

	JR	L_165
;  315				}
;  316				case 0x6000: {
L_67:
.LINE 316

;  317					V[x] = (opcode & 0x00ff);
.LINE 317

	LD	A,(_opcode)
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  318					break;
.LINE 318

	JR	L_165
;  319				}
;  320				case 0x7000: {
L_68:
.LINE 320

;  321					V[x] = (V[x] + (opcode & 0x00ff)) & 0xff;
.LINE 321

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-26),HL
	LD	A,(_opcode)
	LD	HL,(IX+-26)
	ADD	A,(HL)
	LD	HL,(IX+-26)
	LD	(HL),A
;  322					break;
.LINE 322

	JR	L_165
;  323				}
;  324				case 0x8000: {
L_69:
.LINE 324

;  325					switch(opcode & 0x000f) {
.LINE 325

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__25:
	DW	9
	DB	0
	DW24	L_70	

	DB	1
	DW24	L_71	

	DB	2
	DW24	L_72	

	DB	3
	DW24	L_73	

	DB	4
	DW24	L_74	

	DB	5
	DW24	L_75	

	DB	6
	DW24	L_76	

	DB	7
	DW24	L_77	

	DB	14
	DW24	L_78	

	DW24	L_165	

;  326						case 0x0000: {
L_70:
.LINE 326

;  327							V[x]  = V[y];
.LINE 327

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
;  328							break;
.LINE 328

	JR	L_165
;  329						}
;  330						case 0x0001: {
L_71:
.LINE 330

;  331							V[x] |= V[y];
.LINE 331

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-29),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-29)
	LD	A,(HL)
	OR	A,(IY)
	LD	HL,(IX+-29)
	LD	(HL),A
;  332							break;
.LINE 332

	JR	L_165
;  333						}
;  334						case 0x0002: {
L_72:
.LINE 334

;  335							V[x] &= V[y];
.LINE 335

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-32),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-32)
	LD	A,(HL)
	AND	A,(IY)
	LD	HL,(IX+-32)
	LD	(HL),A
;  336							break;
.LINE 336

	JR	L_165
;  337						}
;  338						case 0x0003: {
L_73:
.LINE 338

;  339							V[x] ^= V[y];
.LINE 339

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-35),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-35)
	LD	A,(HL)
	XOR	A,(IY)
	LD	HL,(IX+-35)
	LD	(HL),A
;  340							break;
.LINE 340

	JR	L_165
;  341						}
;  342						case 0x0004: {
L_74:
.LINE 342

;  343							V[0xf] = (V[x] + V[y] > 0xff);
.LINE 343

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-38),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-38)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,HL
	LD	HL,255
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L__27
	LD	A,1
	JR	L__28
L__27:
	XOR	A,A
L__28:
	LD	HL,_V+15
	LD	(HL),A
;  344							V[x] += V[y];
.LINE 344

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-38)
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-38)
	LD	(IX+-77),HL	; spill
	LD	HL,(IX+-68)	; unspill
	LD	A,(HL)
	ADD	A,(IY)
	LD	HL,(IX+-77)	; unspill
	LD	(HL),A
;  345							V[x] &= 255;
.LINE 345

	LD	HL,(IX+-38)
	LD	A,(HL)
	LD	HL,(IX+-38)
	LD	(HL),A
;  346							break;
.LINE 346

	JR	L_165
;  347						}
;  348						case 0x0005: {
L_75:
.LINE 348

;  349							V[0xf] = V[x] >= V[y];
.LINE 349

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-41),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-41)
	LD	A,(IY)
	CP	A,(HL)
	JR	C,L__30
	LD	A,1
	JR	L__31
L__30:
	XOR	A,A
L__31:
	LD	HL,_V+15
	LD	(HL),A
;  350							V[x] -= V[y];
.LINE 350

	LD	IY,(IX+-41)
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-41)
	LD	(IX+-74),HL	; spill
	LD	HL,(IX+-68)	; unspill
	LD	A,(IY)
	SUB	A,(HL)
	LD	HL,(IX+-74)	; unspill
	LD	(HL),A
;  351							break;
.LINE 351

	JR	L_165
;  352						}
;  353						case 0x0006: {
L_76:
.LINE 353

;  354							V[0xf] = V[x] & 1;
.LINE 354

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-44),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,_V+15
	LD	(HL),A
;  355							V[x] >>= 1;
.LINE 355

	LD	HL,(IX+-44)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,1
	CALL	__ishrs_b
	LD	IY,(IX+-44)
	LD	(IY),L
;  356							break;
.LINE 356

	JR	L_165
;  357						}
;  358						case 0x0007: {
L_77:
.LINE 358

;  359							V[0xf] = V[y] >= V[x];
.LINE 359

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-47),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-47)
	LD	A,(HL)
	CP	A,(IY)
	JR	C,L__33
	LD	A,1
	JR	L__34
L__33:
	XOR	A,A
L__34:
	LD	HL,_V+15
	LD	(HL),A
;  360							V[x] = V[y] - V[x];
.LINE 360

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-47)
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-47)
	LD	(IX+-71),HL	; spill
	LD	HL,(IX+-68)	; unspill
	LD	A,(HL)
	SUB	A,(IY)
	LD	HL,(IX+-71)	; unspill
	LD	(HL),A
;  361							break;
.LINE 361

	JR	L_165
;  362						}
;  363						case 0x000E: {
L_78:
.LINE 363

;  364							V[0xf] = V[x] >> 7;
.LINE 364

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-50),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,7
	CALL	__ishrs_b
	LD	IY,_V
	LD	(IY+15),L
;  365							V[x] <<= 1;
.LINE 365

	LD	HL,(IX+-50)
	LD	A,(HL)
	ADD	A,A
	LD	HL,(IX+-50)
	LD	(HL),A
;  366							break;
.LINE 366

	JR	L_165
;  367						}
;  368						break;
;  369					}
;  370					break;
;  371				}
;  372				case 0x9000: {
L_80:
.LINE 372

;  373					if(V[x] != V[y])
.LINE 373

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_165
;  374						pc += 2;
.LINE 374

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  375					break;
.LINE 375

	JR	L_165
;  376				}
;  377				case 0xa000: {
L_83:
.LINE 377

;  378					I = (opcode & 0x0fff);
.LINE 378

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  379					break;
.LINE 379

	JR	L_165
;  380				}
;  381				case 0xb000: {
L_84:
.LINE 381

;  382					pc = V[0] + (opcode & 0x0fff);
.LINE 382

	LD	A,(_V)
	LD	C,A
	LD	B,0
	LD	DE,BC
	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  383					break;
.LINE 383

	JR	L_165
;  384				}
;  385				case 0xc000: {
L_85:
.LINE 385

;  386					V[x] = (rand() & 0xff) & (opcode & 0x00FF);
.LINE 386

	LD	A,(_opcode)
	LD	B,A
	LD	(IX+-80),BC
	CALL	_rand
	LD	BC,(IX+-80)
	LD	A,B
	AND	A,L
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  387					break;
.LINE 387

	JR	L_165
;  388				}
;  389				case 0xd000: {
L_86:
.LINE 389

;  390					uint8_t xd = V[x];
.LINE 390

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-17),A
;  391					uint8_t yd = V[y];
.LINE 391

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-19),A
;  392					uint8_t height = (opcode & 0x000f);
.LINE 392

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-6),A
;  393					
;  394					V[0xf] = 0;
.LINE 394

	LD	HL,_V+15
	LD	(HL),0
;  395					
;  396					if(extendedScreen) {
.LINE 396

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_112
;  397						//Extended screen DXY0
;  398						uint8_t cols = 1;
.LINE 398

	LD	(IX+-7),1
;  399						if(height == 0) {
.LINE 399

	LD	A,(IX+-6)
	OR	A,A
	JR	NZ,L_101
;  400							cols = 2;
.LINE 400

	LD	(IX+-7),2
;  401							height = 16;
.LINE 401

	LD	(IX+-6),16
;  402						}
L_101:
.LINE 402

;  403						for(_y = 0; _y < height; ++_y) {
.LINE 403

	XOR	A,A
	LD	(__y),A
	JR	L_100
L_98:
;  404							pixel = memory[I + (cols*_y)];
.LINE 404

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  405							if(cols == 2) {
.LINE 405

	LD	A,(IX+-7)
	CP	A,2
	JR	NZ,L_97
;  406								pixel <<= 8;
.LINE 406

	LD	HL,(_pixel)
	LD	H,L
	LD	L,0
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  407								pixel |= memory[I + (_y << 1)+1];
.LINE 407

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	BC,(_pixel)
	CALL	__sor
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  408							}
L_97:
.LINE 408

;  409							for(_x = 0; _x < (cols << 3); ++_x) {
.LINE 409

	XOR	A,A
	LD	(__x),A
	JR	L_96
L_94:
;  410								if((pixel & (((cols == 2) ? 0x8000 : 0x80) >> _x)) != 0) {
.LINE 410

	LD	A,(IX+-7)
	CP	A,2
	JR	NZ,L_91
	LD	BC,32768
	LD	(IX+-23),BC
	JR	L_92
L_91:
	LD	BC,128
	LD	(IX+-23),BC
L_92:
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-23)
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_95
;  411									index = (((xd + _x) & 0x7f) + (((yd + _y) & 0x3f) << 7)) + 2;
.LINE 411

	LD	A,(__x)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-17)
	ADD.SIS	HL,BC
	LD	A,L
	RES	7,A
	LD	C,A
	LD	DE,BC
	LD	A,(__y)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-19)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,63
	LD	C,A
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  412									V[0xf] |= scanvas_data[index] & 1;
.LINE 412

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-56),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_scanvas_data
	ADD	HL,BC
	LD	(IX+-53),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-56)
	OR	A,(HL)
	LD	HL,(IX+-56)
	LD	(HL),A
;  413									scanvas_data[index] = ~scanvas_data[index];
.LINE 413

	LD	HL,(IX+-53)
	LD	A,(HL)
	CPL	
	LD	HL,(IX+-53)
	LD	(HL),A
;  414								}
;  415							}
L_95:
.LINE 415

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_96:
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JP	M,L_94
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  416						}
L_100:
.LINE 416

	LD	A,(__y)
	CP	A,(IX+-6)
	JR	C,L_98
	JR	L_113
;  417					} else {
L_112:
.LINE 417

;  418						//Normal screen DXYN
;  419						if(height == 0) height = 16;
.LINE 419

	LD	A,(IX+-6)
	OR	A,A
	JR	NZ,L_110
	LD	(IX+-6),16
L_110:
;  420						for(_y = 0; _y < height; ++_y) {
.LINE 420

	XOR	A,A
	LD	(__y),A
	JR	L_109
L_107:
;  421							pixel = memory[I + _y];
.LINE 421

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,HL
	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  422							for(_x = 0; _x < 8; ++_x) {
.LINE 422

	XOR	A,A
	LD	(__x),A
	JR	L_106
L_104:
;  423								if((pixel & (0x80 >> _x)) != 0) {
.LINE 423

	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,128
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_105
;  424									index = (((xd + _x) & 0x3f) + (((yd + _y) & 0x1f) << 6)) + 2;
.LINE 424

	LD	A,(__x)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-17)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,63
	LD	C,A
	LD	DE,BC
	LD	A,(__y)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-19)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,31
	LD	C,A
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  425									V[0xf] |= canvas_data[index] & 1;
.LINE 425

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-62),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(IX+-59),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-62)
	OR	A,(HL)
	LD	HL,(IX+-62)
	LD	(HL),A
;  426									canvas_data[index] = ~canvas_data[index];
.LINE 426

	LD	HL,(IX+-59)
	LD	A,(HL)
	CPL	
	LD	HL,(IX+-59)
	LD	(HL),A
;  427								}
;  428							}
L_105:
.LINE 428

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_106:
	LD	A,(__x)
	CP	A,8
	JR	C,L_104
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  429						}
L_109:
.LINE 429

	LD	A,(__y)
	CP	A,(IX+-6)
	JR	C,L_107
;  430					}
L_113:
.LINE 430

;  431					
;  432					drawFlag = true;
.LINE 432

	LD	A,1
	LD	(_drawFlag),A
;  433					
;  434					break;
.LINE 434

	JR	L_165
;  435				}
;  436				case 0xe000: {
L_114:
.LINE 436

;  437					switch(opcode & 0x00ff) {
.LINE 437

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__47:
	DW	2
	DB	158
	DW24	L_115	

	DB	161
	DW24	L_118	

	DW24	L_165	

;  438						case 0x009e: {
L_115:
.LINE 438

;  439							if(keys[V[x]])
.LINE 439

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_165
;  440								pc += 2;
.LINE 440

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  441							break;
.LINE 441

	JR	L_165
;  442						}
;  443						case 0x00a1: {
L_118:
.LINE 443

;  444							if(!keys[V[x]])
.LINE 444

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_165
;  445								pc += 2;
.LINE 445

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  446							break;
.LINE 446

	JR	L_165
;  447						}
;  448					}
;  449					break;
;  450				}
;  451				case 0xf000: {
L_122:
.LINE 451

;  452					switch(opcode & 0x00ff) {
.LINE 452

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__50:
	DW	12
	DB	7
	DW24	L_123	

	DB	10
	DW24	L_124	

	DB	21
	DW24	L_131	

	DB	24
	DW24	L_133	

	DB	30
	DW24	L_134	

	DB	41
	DW24	L_135	

	DB	48
	DW24	L_136	

	DB	51
	DW24	L_137	

	DB	85
	DW24	L_138	

	DB	101
	DW24	L_143	

	DB	117
	DW24	L_148	

	DB	133
	DW24	L_155	

	DW24	L_165	

;  453						case 0x0007: {
L_123:
.LINE 453

;  454							V[x] = delay_timer;
.LINE 454

	LD	A,(_delay_timer)
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  455							break;
.LINE 455

	JR	L_165
;  456						}
;  457						case 0x000A: {
L_124:
.LINE 457

;  458							bool key_pressed = false;
.LINE 458

	LD	(IX+-18),0
;  459							pc -= 2;
.LINE 459

	LD	IY,(_pc)
	LEA	BC,IY+-2
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  460							
;  461							for(i = 0; i < 16; ++i) {
.LINE 461

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_128
L_126:
;  462								if(keys[i]) {
.LINE 462

	LD	BC,_keys
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_127
;  463									V[x] = i;
.LINE 463

	LD	B,(IX+-3)
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  464									pc += 2;
.LINE 464

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  465									key_pressed = true;
.LINE 465

	LD	(IX+-18),1
;  466									break;
.LINE 466

	JR	L_130
;  467								}
;  468							}
L_127:
.LINE 468

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_128:
	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_126
L_130:
;  469							
;  470							if(!key_pressed)
.LINE 470

	LD	A,(IX+-18)
	OR	A,A
	JR	Z,L_171
;  471								return;
.LINE 471

;  472						}
.LINE 472

;  473						case 0x0015: {
L_131:
.LINE 473

;  474							delay_timer = V[x];
.LINE 474

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  475							break;
.LINE 475

	JR	L_165
;  476						}
;  477						case 0x0018: {
L_133:
.LINE 477

;  478							sound_timer = V[x];
.LINE 478

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  479							break;
.LINE 479

	JR	L_165
;  480						}
;  481						case 0x001E: {
L_134:
.LINE 481

;  482							I = (I + V[x]) & 0xffff;
.LINE 482

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	DE,(_I)
	LD	HL,BC
	ADD.SIS	HL,DE
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  483							break;
.LINE 483

	JR	L_165
;  484						}
;  485						case 0x0029: {
L_135:
.LINE 485

;  486							I = (V[x] & 0xf) * 5;
.LINE 486

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	AND	A,15
	LD	C,A
	LD	B,0
	LD.LIS	HL,5
	CALL	__smulu
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  487							break;
.LINE 487

	JR	L_165
;  488						}
;  489						case 0x0030: {
L_136:
.LINE 489

;  490							I = (V[x] & 0xf) * 10 + 80;
.LINE 490

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	AND	A,15
	LD	C,A
	LD	B,0
	LD.LIS	HL,10
	CALL	__smulu
	LD	IY,HL
	LEA	BC,IY+80
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  491							break;
.LINE 491

	JR	L_165
;  492						}
;  493						case 0x0033: {
L_137:
.LINE 493

;  494							memory[ I ] = V[x] / 100;
.LINE 494

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-65),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,100
	CALL	__idivs
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  495							memory[I+1] = (V[x] / 10) % 10;
.LINE 495

	LD	HL,(IX+-65)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  496							memory[I+2] = V[x] % 10;
.LINE 496

	LD	HL,(IX+-65)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  497							break;
.LINE 497

	JR	L_165
;  498						}
;  499						case 0x0055: {
L_138:
.LINE 499

;  500							for(i = 0; i <= x; ++i) {
.LINE 500

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_141
L_139:
;  501								memory[I + i] = V[i];
.LINE 501

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  502							}
L_141:
.LINE 502

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	P,L_139
;  503							break;
.LINE 503

	JR	L_165
;  504						}
;  505						case 0x0065: {
L_143:
.LINE 505

;  506							for(i = 0; i <= x; ++i) {
.LINE 506

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_146
L_144:
;  507								V[i] = memory[I + i];
.LINE 507

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  508							}
L_146:
.LINE 508

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_144
;  509							break;
.LINE 509

	JR	L_165
;  510						}
;  511						case 0x0075: {
L_148:
.LINE 511

;  512							if (x > 7) x = 7;
.LINE 512

	LD	A,7
	CP	A,(IX+-4)
	JR	NC,L_153
	LD	(IX+-4),7
L_153:
;  513							for(i = 0; i <= x; ++i) {
.LINE 513

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_152
L_150:
;  514								SV[i] = V[i];
.LINE 514

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  515							}
L_152:
.LINE 515

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_150
;  516							break;
.LINE 516

	JR	L_165
;  517						}
;  518						case 0x0085: {
L_155:
.LINE 518

;  519							if (x > 7) x = 7;
.LINE 519

	LD	A,7
	CP	A,(IX+-4)
	JR	NC,L_160
	LD	(IX+-4),7
L_160:
;  520							for(i = 0; i <= x; ++i) {
.LINE 520

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_159
L_157:
;  521								V[i] = SV[i];
.LINE 521

	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  522							}
L_159:
.LINE 522

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_157
;  523							break;
;  524						}
;  525					}
;  526					break;
;  527				}
;  528				default:
;  529					break;
;  530			}
;  531		}
L_165:
.LINE 531

	LD	A,(_step)
	INC	A
	LD	(_step),A
L_166:
	LD	A,(_step)
	CP	A,(IX+6)
	JR	C,L_164
;  532		if(sound_timer > 0) {
.LINE 532

	LD	BC,(_sound_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_170
;  533			--sound_timer;
.LINE 533

	LD	BC,(_sound_timer)
	DEC	BC
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  534		}
L_170:
.LINE 534

;  535		if(delay_timer > 0) {
.LINE 535

	LD	BC,(_delay_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_171
;  536			--delay_timer;
.LINE 536

	LD	BC,(_delay_timer)
	DEC	BC
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  537		}
;  538	}
L_171:
.LINE 538

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emulateCycle ***************************
;Name                         Addr/Register   Size   Type
;_SV                                 STATIC      8   variable
;_sound_timer                        STATIC      2   variable
;_delay_timer                        STATIC      2   variable
;_keys                               STATIC     16   variable
;_index                              STATIC      2   variable
;__x                                 STATIC      1   variable
;_pixel                              STATIC      2   variable
;__y                                 STATIC      1   variable
;_rand                               IMPORT  -----   function
;_I                                  STATIC      2   variable
;_V                                  STATIC     16   variable
;_playing                            STATIC      1   variable
;_memmove                            IMPORT  -----   function
;_stack                              STATIC     32   variable
;_sp                                 STATIC      1   variable
;_drawFlag                           STATIC      1   variable
;_memset                             IMPORT  -----   function
;_screen_width                       STATIC      1   variable
;_memcpy                             IMPORT  -----   function
;_screen_height                      STATIC      1   variable
;_canvas_data                        IMPORT   2050   variable
;_scanvas_data                       IMPORT   8194   variable
;_extendedScreen                     STATIC      1   variable
;_sprintf                            IMPORT  -----   function
;_opcode                             STATIC      2   variable
;_pc                                 STATIC      2   variable
;_memory                             STATIC   4096   variable
;_step                               STATIC      1   variable
;_setKeys                            IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;temp89                               IX-23      3   variable
;n                                    IX-20      1   variable
;yd                                   IX-19      1   variable
;key_pressed                          IX-18      1   variable
;xd                                   IX-17      1   variable
;disp                                 IX-16      3   variable
;disp                                 IX-13      3   variable
;disp                                 IX-10      3   variable
;cols                                  IX-7      1   variable
;height                                IX-6      1   variable
;y                                     IX-5      1   variable
;x                                     IX-4      1   variable
;i                                     IX-3      3   variable
;steps                                 IX+6      1   parameter


; Stack Frame Size: 89 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emulateCycle",538,"_emulateCycle"
	SEGMENT STRSECT
L__10:
	DB	"%x "
	DB	10,0
L__20:
	DB	"Extended mode off"
	DB	10,0
L__21:
	DB	"Extended mode on"
	DB	10,0
	XREF _scanvas_data:ROM
	XREF _canvas_data:ROM
	XREF _kb_Scan:ROM
	XREF _memmove:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _sprintf:ROM
	XREF _ti_GetSize:ROM
	XREF _ti_Read:ROM
	XREF _ti_Open:ROM
	XREF _ti_CloseAll:ROM
	XREF _rand:ROM
	XREF _srand:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __sor:ROM
	XREF __sand:ROM
	XREF __iand:ROM
	XREF __smulu:ROM
	XREF __irems:ROM
	XREF __ishrs:ROM
	XREF __stoiu:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __case8D:ROM
	XREF __case16D:ROM
	XREF __ishrs_b:ROM
	XREF __sshru_b:ROM
	XDEF _emulateCycle
	XDEF _setKeys
	XDEF _loadProgram
	XDEF _initialize
	XDEF _screen_height
	XDEF _screen_width
	XDEF __x
	XDEF __y
	XDEF _index
	XDEF _pixel
	XDEF _step
	XDEF _fontset_ten
	XDEF _fontset
	XDEF _file
	XDEF _controlMap
	XDEF _keypad
	XDEF _game_data
	XDEF _extendedScreen
	XDEF _playing
	XDEF _paused
	XDEF _drawFlag
	XDEF _keys
	XDEF _sp
	XDEF _stack
	XDEF _sound_timer
	XDEF _delay_timer
	XDEF _pc
	XDEF _I
	XDEF _V
	XDEF _SV
	XDEF _memory
	XDEF _opcode
	END
