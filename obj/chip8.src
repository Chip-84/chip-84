; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\CHIP8.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME1"
.TYPE 104
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME7"
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME8",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME10"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME10",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME10"
.BEGREC "__stdio_file",1
.DEFINE "slot"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "__stdio_file"
	SEGMENT DATA
_opcode:
	DW	0
.DEFINE "opcode"
.ALIAS "_opcode"
.CLASS 69
.VALUE _opcode
.TYPE 13
.ENDEF
	SEGMENT BSS
_memory:
	DS	4096
.DEFINE "memory"
.ALIAS "_memory"
.CLASS 83
.VALUE _memory
.DIM 4096
.TYPE 108
.ENDEF
_SV:
	DS	8
.DEFINE "SV"
.ALIAS "_SV"
.CLASS 83
.VALUE _SV
.DIM 8
.TYPE 108
.ENDEF
_V:
	DS	16
.DEFINE "V"
.ALIAS "_V"
.CLASS 83
.VALUE _V
.DIM 16
.TYPE 108
.ENDEF
	SEGMENT DATA
_I:
	DW	0
.DEFINE "I"
.ALIAS "_I"
.CLASS 69
.VALUE _I
.TYPE 13
.ENDEF
_pc:
	DW	0
.DEFINE "pc"
.ALIAS "_pc"
.CLASS 69
.VALUE _pc
.TYPE 13
.ENDEF
_delay_timer:
	DW	0
.DEFINE "delay_timer"
.ALIAS "_delay_timer"
.CLASS 69
.VALUE _delay_timer
.TYPE 3
.ENDEF
_sound_timer:
	DW	0
.DEFINE "sound_timer"
.ALIAS "_sound_timer"
.CLASS 69
.VALUE _sound_timer
.TYPE 3
.ENDEF
	SEGMENT BSS
_stack:
	DS	32
.DEFINE "stack"
.ALIAS "_stack"
.CLASS 83
.VALUE _stack
.DIM 16
.TYPE 109
.ENDEF
	SEGMENT DATA
_sp:
	DB	0
.DEFINE "sp"
.ALIAS "_sp"
.CLASS 69
.VALUE _sp
.TYPE 12
.ENDEF
_keys:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
.DEFINE "keys"
.ALIAS "_keys"
.CLASS 69
.VALUE _keys
.DIM 16
.TYPE 108
.ENDEF
_drawFlag:
	DB	0
.DEFINE "drawFlag"
.ALIAS "_drawFlag"
.CLASS 69
.VALUE _drawFlag
.TYPE 12
.ENDEF
_paused:
	DB	0
.DEFINE "paused"
.ALIAS "_paused"
.CLASS 69
.VALUE _paused
.TYPE 12
.ENDEF
_playing:
	DB	0
.DEFINE "playing"
.ALIAS "_playing"
.CLASS 69
.VALUE _playing
.TYPE 12
.ENDEF
_extendedScreen:
	DB	0
.DEFINE "extendedScreen"
.ALIAS "_extendedScreen"
.CLASS 69
.VALUE _extendedScreen
.TYPE 12
.ENDEF
	SEGMENT BSS
_game_data:
	DS	3584
.DEFINE "game_data"
.ALIAS "_game_data"
.CLASS 83
.VALUE _game_data
.DIM 3584
.TYPE 108
.ENDEF
_keypad:
	DS	16
.DEFINE "keypad"
.ALIAS "_keypad"
.CLASS 83
.VALUE _keypad
.DIM 16
.TYPE 108
.ENDEF
_controlMap:
	DS	16
.DEFINE "controlMap"
.ALIAS "_controlMap"
.CLASS 83
.VALUE _controlMap
.DIM 16
.TYPE 108
.ENDEF
_file:
	DS	1
.DEFINE "file"
.ALIAS "_file"
.CLASS 83
.VALUE _file
.TYPE 12
.ENDEF
	SEGMENT DATA
_fontset:
	DB	240
	DB	144
	DB	144
	DB	144
	DB	240
	DB	32
	DB	96
	DB	32
	DB	32
	DB	112
	DB	240
	DB	16
	DB	240
	DB	128
	DB	240
	DB	240
	DB	16
	DB	240
	DB	16
	DB	240
	DB	144
	DB	144
	DB	240
	DB	16
	DB	16
	DB	240
	DB	128
	DB	240
	DB	16
	DB	240
	DB	240
	DB	128
	DB	240
	DB	144
	DB	240
	DB	240
	DB	16
	DB	32
	DB	64
	DB	64
	DB	240
	DB	144
	DB	240
	DB	144
	DB	240
	DB	240
	DB	144
	DB	240
	DB	16
	DB	240
	DB	240
	DB	144
	DB	240
	DB	144
	DB	144
	DB	224
	DB	144
	DB	224
	DB	144
	DB	224
	DB	240
	DB	128
	DB	128
	DB	128
	DB	240
	DB	224
	DB	144
	DB	144
	DB	144
	DB	224
	DB	240
	DB	128
	DB	240
	DB	128
	DB	240
	DB	240
	DB	128
	DB	240
	DB	128
	DB	128
.DEFINE "fontset"
.ALIAS "_fontset"
.CLASS 69
.VALUE _fontset
.DIM 80
.TYPE 108
.ENDEF
_fontset_ten:
	DW	50812
	DW	57038
	DW	63190
	DW	50918
	DW	124
	DW	12304
	DW	12528
	DW	12336
	DW	12336
	DW	252
	DW	52344
	DW	3276
	DW	12312
	DW	52320
	DW	252
	DW	52344
	DW	3084
	DW	3128
	DW	52236
	DW	120
	DW	7180
	DW	27708
	DW	65228
	DW	3084
	DW	30
	DW	49404
	DW	49344
	DW	3320
	DW	52236
	DW	120
	DW	24632
	DW	49344
	DW	52472
	DW	52428
	DW	120
	DW	50942
	DW	1734
	DW	6156
	DW	12336
	DW	48
	DW	52344
	DW	60620
	DW	56440
	DW	52428
	DW	120
	DW	50812
	DW	50886
	DW	3198
	DW	12312
	DW	112
	DW	30768
	DW	52428
	DW	64716
	DW	52428
	DW	204
	DW	26364
	DW	26214
	DW	26236
	DW	26214
	DW	252
	DW	26172
	DW	49350
	DW	49344
	DW	26310
	DW	60
	DW	27896
	DW	26214
	DW	26214
	DW	27750
	DW	248
	DW	25342
	DW	25696
	DW	25724
	DW	25184
	DW	254
	DW	26366
	DW	25698
	DW	25724
	DW	24672
	DW	240
.DEFINE "fontset_ten"
.ALIAS "_fontset_ten"
.CLASS 69
.VALUE _fontset_ten
.DIM 80
.TYPE 109
.ENDEF
	SEGMENT BSS
_step:
	DS	1
.DEFINE "step"
.ALIAS "_step"
.CLASS 83
.VALUE _step
.TYPE 12
.ENDEF
_pixel:
	DS	2*1
.DEFINE "pixel"
.ALIAS "_pixel"
.CLASS 83
.VALUE _pixel
.TYPE 13
.ENDEF
_index:
	DS	2*1
.DEFINE "index"
.ALIAS "_index"
.CLASS 83
.VALUE _index
.TYPE 13
.ENDEF
__y:
	DS	1
.DEFINE "_y"
.ALIAS "__y"
.CLASS 83
.VALUE __y
.TYPE 12
.ENDEF
__x:
	DS	1
.DEFINE "_x"
.ALIAS "__x"
.CLASS 83
.VALUE __x
.TYPE 12
.ENDEF
_screen_width:
	DS	1
.DEFINE "screen_width"
.ALIAS "_screen_width"
.CLASS 83
.VALUE _screen_width
.TYPE 12
.ENDEF
_screen_height:
	DS	1
.DEFINE "screen_height"
.ALIAS "_screen_height"
.CLASS 83
.VALUE _screen_height
.TYPE 12
.ENDEF
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <debug.h>
;    6	
;    7	#include <math.h>
;    8	#include <stdio.h>
;    9	#include <stdlib.h>
;   10	#include <string.h>
;   11	
;   12	#include <fileioc.h>
;   13	#include <keypadc.h>
;   14	
;   15	#include "chip8.h"
;   16	#include "sprites_gfx.h"
;   17	
;   18	uint16_t opcode = 0;
;   19	uint8_t memory[4096];
;   20	uint8_t SV[8];
;   21	uint8_t V[16];
;   22	uint16_t I = 0;
;   23	uint16_t pc = 0;
;   24	int16_t delay_timer = 0;
;   25	int16_t sound_timer = 0;
;   26	uint16_t stack[16];
;   27	uint8_t sp = 0;
;   28	uint8_t keys[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;   29	bool drawFlag = false;
;   30	
;   31	bool paused = false;
;   32	bool playing = false;
;   33	bool extendedScreen = 0;
;   34	
;   35	uint8_t game_data[3584];
;   36	uint8_t keypad[16];
;   37	uint8_t controlMap[16];
;   38	
;   39	ti_var_t file;
;   40	
;   41	unsigned char fontset[80] = {
;   42	    0xF0, 0x90, 0x90, 0x90, 0xF0, //0
;   43	    0x20, 0x60, 0x20, 0x20, 0x70, //1
;   44	    0xF0, 0x10, 0xF0, 0x80, 0xF0, //2
;   45	    0xF0, 0x10, 0xF0, 0x10, 0xF0, //3
;   46	    0x90, 0x90, 0xF0, 0x10, 0x10, //4
;   47	    0xF0, 0x80, 0xF0, 0x10, 0xF0, //5
;   48	    0xF0, 0x80, 0xF0, 0x90, 0xF0, //6
;   49	    0xF0, 0x10, 0x20, 0x40, 0x40, //7
;   50	    0xF0, 0x90, 0xF0, 0x90, 0xF0, //8
;   51	    0xF0, 0x90, 0xF0, 0x10, 0xF0, //9
;   52	    0xF0, 0x90, 0xF0, 0x90, 0x90, //A
;   53	    0xE0, 0x90, 0xE0, 0x90, 0xE0, //B
;   54	    0xF0, 0x80, 0x80, 0x80, 0xF0, //C
;   55	    0xE0, 0x90, 0x90, 0x90, 0xE0, //D
;   56	    0xF0, 0x80, 0xF0, 0x80, 0xF0, //E
;   57	    0xF0, 0x80, 0xF0, 0x80, 0x80  //F
;   58	};
;   59	uint16_t  fontset_ten[80] = {
;   60		0xC67C, 0xDECE, 0xF6D6, 0xC6E6, 0x007C, // 0
;   61		0x3010, 0x30F0, 0x3030, 0x3030, 0x00FC, // 1
;   62		0xCC78, 0x0CCC, 0x3018, 0xCC60, 0x00FC, // 2
;   63		0xCC78, 0x0C0C, 0x0C38, 0xCC0C, 0x0078, // 3
;   64		0x1C0C, 0x6C3C, 0xFECC, 0x0C0C, 0x001E, // 4
;   65		0xC0FC, 0xC0C0, 0x0CF8, 0xCC0C, 0x0078, // 5
;   66		0x6038, 0xC0C0, 0xCCF8, 0xCCCC, 0x0078, // 6
;   67		0xC6FE, 0x06C6, 0x180C, 0x3030, 0x0030, // 7
;   68		0xCC78, 0xECCC, 0xDC78, 0xCCCC, 0x0078, // 8
;   69		0xC67C, 0xC6C6, 0x0C7E, 0x3018, 0x0070, // 9
;   70		0x7830, 0xCCCC, 0xFCCC, 0xCCCC, 0x00CC, // A
;   71		0x66FC, 0x6666, 0x667C, 0x6666, 0x00FC, // B
;   72		0x663C, 0xC0C6, 0xC0C0, 0x66C6, 0x003C, // C
;   73		0x6CF8, 0x6666, 0x6666, 0x6C66, 0x00F8, // D
;   74		0x62FE, 0x6460, 0x647C, 0x6260, 0x00FE, // E
;   75		0x66FE, 0x6462, 0x647C, 0x6060, 0x00F0  // F
;   76	};
;   77	
;   78	uint8_t step;
;   79	uint16_t pixel;
;   80	uint16_t index;
;   81	
;   82	uint8_t _y;
;   83	uint8_t _x;
;   84	
;   85	uint8_t screen_width;
;   86	uint8_t screen_height;
	SEGMENT CODE
;   87	
;   88	void initialize() {
_initialize:
.DEFINE "_initialize"

.VALUE _initialize

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initialize",88,"_initialize"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   89		
;   90		opcode = I = sp = delay_timer = sound_timer = 0;
.LINE 90

	LD	HL,_sound_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_delay_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	XOR	A,A
	LD	(_sp),A
	LD	HL,_I
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_opcode
	LD	(HL),0
	INC	HL
	LD	(HL),0
;   91		pc = 0x200;
.LINE 91

	LD	HL,_pc
	LD	(HL),0
	INC	HL
	LD	(HL),2
;   92		
;   93		extendedScreen = 0;
.LINE 93

	XOR	A,A
	LD	(_extendedScreen),A
;   94		screen_width = 64;
.LINE 94

	LD	A,64
	LD	(_screen_width),A
;   95		screen_height = 32;
.LINE 95

	LD	A,32
	LD	(_screen_height),A
;   96		
;   97		scanvas_data[0] = 128;
.LINE 97

	LD	A,128
	LD	(_scanvas_data),A
;   98		scanvas_data[1] = 64;
.LINE 98

	LD	HL,_scanvas_data
	INC	HL
	LD	(HL),64
;   99		memset(scanvas_data + 2, 0, 8192);
.LINE 99

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  100	
;  101		canvas_data[0] = 64;
.LINE 101

	LD	A,64
	LD	(_canvas_data),A
;  102		canvas_data[1] = 32;
.LINE 102

	LD	HL,_canvas_data
	INC	HL
	LD	(HL),32
;  103		memset(canvas_data + 2, 0, 2048);
.LINE 103

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  104			
;  105		memset(keys, 0, 16);
.LINE 105

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_keys
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  106		memset(stack, 0, 16);
.LINE 106

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_stack
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  107		memset(V, 0, 16);
.LINE 107

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_V
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  108		memset(SV, 0, 8);
.LINE 108

	LD	BC,8
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_SV
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  109		memset(memory, 0, 4096);
.LINE 109

	LD	BC,4096
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  110		
;  111		memcpy(memory, fontset, 80);
.LINE 111

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  112		memcpy(memory + 80, fontset_ten, 80);
.LINE 112

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset_ten
	PUSH	BC
	LD	BC,_memory+80
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  113		
;  114		srand(rtc_Time());
.LINE 114

	LD	BC,(15925316)
	PUSH	BC
	CALL	_srand
	POP	BC
;  115	}
.LINE 115

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initialize ***************************
;Name                         Addr/Register   Size   Type
;_srand                              IMPORT  -----   function
;_fontset_ten                        STATIC    160   variable
;_fontset                            STATIC     80   variable
;_memcpy                             IMPORT  -----   function
;_memory                             STATIC   4096   variable
;_SV                                 STATIC      8   variable
;_V                                  STATIC     16   variable
;_stack                              STATIC     32   variable
;_keys                               STATIC     16   variable
;_canvas_data                        IMPORT   2050   variable
;_memset                             IMPORT  -----   function
;_scanvas_data                       IMPORT   8194   variable
;_screen_height                      STATIC      1   variable
;_screen_width                       STATIC      1   variable
;_extendedScreen                     STATIC      1   variable
;_pc                                 STATIC      2   variable
;_opcode                             STATIC      2   variable
;_I                                  STATIC      2   variable
;_sp                                 STATIC      1   variable
;_delay_timer                        STATIC      2   variable
;_sound_timer                        STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initialize",115,"_initialize"
;  116	
;  117	void loadProgram(char *fileName) {
_loadProgram:
.DEFINE "_loadProgram"

.VALUE _loadProgram

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "loadProgram",117,"_loadProgram"

.LINE 117

.DEFINE "fileName"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "romSize"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;  118		int i;
;  119		uint16_t romSize;
;  120		
;  121		playing = true;
.LINE 121

	LD	A,1
	LD	(_playing),A
;  122		paused = false;
.LINE 122

	XOR	A,A
	LD	(_paused),A
;  123		
;  124		ti_CloseAll();
.LINE 124

	CALL	_ti_CloseAll
;  125		file = ti_Open(fileName, "r");
.LINE 125

	LD	BC,L__1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(_file),A
;  126		ti_Read(&game_data, ti_GetSize(file), 1, file);
.LINE 126

	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	PUSH	HL
	LD	BC,_game_data
	PUSH	BC
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  127		
;  128		romSize = ti_GetSize(file)-(16+6);
.LINE 128

	LD	A,(_file)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	IY,HL
	LEA	HL,IY+-22
	LD	(IX+-5),L
	LD	(IX+-4),H
;  129		dbg_sprintf(dbgout, "%d ", romSize);
.LINE 129

	LD	BC,(IX+-5)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__2
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  130		
;  131		initialize();
.LINE 131

	CALL	_initialize
;  132		
;  133		if((4096-512) > romSize) {
.LINE 133

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,3584
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_9
;  134			for(i = 0; i < romSize; ++i) {
.LINE 134

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
;  135				memory[i + 512] = (uint8_t)game_data[i+16+6];
.LINE 135

	LD	IY,(IX+-3)
	LEA	HL,IY+22
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,512
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  136			}
L_3:
.LINE 136

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
;  137		}
L_9:
.LINE 137

;  138		for(i = 0; i < 16; i++) {
.LINE 138

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_8
L_6:
;  139			controlMap[i] = (uint8_t)game_data[i+6];
.LINE 139

	LD	IY,(IX+-3)
	LEA	HL,IY+6
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_controlMap
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  140		}
L_8:
.LINE 140

	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_6
;  141	}
.LINE 141

	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadProgram ***************************
;Name                         Addr/Register   Size   Type
;_controlMap                         STATIC     16   variable
;_memory                             STATIC   4096   variable
;_initialize                         IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_game_data                          STATIC   3584   variable
;_ti_GetSize                         IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_file                               STATIC      1   variable
;_ti_Open                            IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_paused                             STATIC      1   variable
;_playing                            STATIC      1   variable
;romSize                               IX-5      2   variable
;i                                     IX-3      3   variable
;fileName                              IX+6      3   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "loadProgram",141,"_loadProgram"
	SEGMENT STRSECT
L__1:
	DB	"r"
	DB	0
L__2:
	DB	"%d "
	DB	0
	SEGMENT CODE
;  142	
;  143	void setKeys() {
_setKeys:
.DEFINE "_setKeys"

.VALUE _setKeys

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setKeys",143,"_setKeys"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  144		keypad[0x0] = kb_Data[4] & kb_DecPnt;
.LINE 144

	LD	A,(16056344)
	AND	A,1
	LD	(_keypad),A
;  145		keypad[0x1] = kb_Data[3] & kb_7;
.LINE 145

	LD	A,(16056342)
	AND	A,8
	LD	HL,_keypad
	INC	HL
	LD	(HL),A
;  146		keypad[0x2] = kb_Data[4] & kb_8;
.LINE 146

	LD	A,(16056344)
	AND	A,8
	LD	IY,_keypad
	LEA	HL,IY+2
	LD	(HL),A
;  147		keypad[0x3] = kb_Data[5] & kb_9;
.LINE 147

	LD	A,(16056346)
	AND	A,8
	LEA	HL,IY+3
	LD	(HL),A
;  148		keypad[0x4] = kb_Data[3] & kb_4;
.LINE 148

	LD	A,(16056342)
	AND	A,4
	LEA	HL,IY+4
	LD	(HL),A
;  149		keypad[0x5] = kb_Data[4] & kb_5;
.LINE 149

	LD	A,(16056344)
	AND	A,4
	LEA	HL,IY+5
	LD	(HL),A
;  150		keypad[0x6] = kb_Data[5] & kb_6;
.LINE 150

	LD	A,(16056346)
	AND	A,4
	LEA	HL,IY+6
	LD	(HL),A
;  151		keypad[0x7] = kb_Data[3] & kb_1;
.LINE 151

	LD	A,(16056342)
	AND	A,2
	LEA	HL,IY+7
	LD	(HL),A
;  152		keypad[0x8] = kb_Data[4] & kb_2;
.LINE 152

	LD	A,(16056344)
	AND	A,2
	LEA	HL,IY+8
	LD	(HL),A
;  153		keypad[0x9] = kb_Data[5] & kb_3;
.LINE 153

	LD	A,(16056346)
	AND	A,2
	LEA	HL,IY+9
	LD	(HL),A
;  154		keypad[0xA] = kb_Data[3] & kb_0;
.LINE 154

	LD	A,(16056342)
	AND	A,1
	LEA	HL,IY+10
	LD	(HL),A
;  155		keypad[0xB] = kb_Data[5] & kb_Chs;
.LINE 155

	LD	A,(16056346)
	AND	A,1
	LEA	HL,IY+11
	LD	(HL),A
;  156		keypad[0xC] = kb_Data[6] & kb_Mul;
.LINE 156

	LD	A,(16056348)
	AND	A,8
	LEA	HL,IY+12
	LD	(HL),A
;  157		keypad[0xD] = kb_Data[6] & kb_Sub;
.LINE 157

	LD	A,(16056348)
	AND	A,4
	LEA	HL,IY+13
	LD	(HL),A
;  158		keypad[0xE] = kb_Data[6] & kb_Add;
.LINE 158

	LD	A,(16056348)
	AND	A,2
	LEA	HL,IY+14
	LD	(HL),A
;  159		keypad[0xF] = kb_Data[6] & kb_Enter;
.LINE 159

	LD	A,(16056348)
	AND	A,1
	LD	HL,_keypad+15
	LD	(HL),A
;  160		
;  161		keys[0x0] = keypad[controlMap[0x0]];
.LINE 161

	LD	A,(_controlMap)
	UEXT	HL
	LD	L,A
	LD	BC,_keypad
	ADD	HL,BC
	LD	A,(HL)
	LD	(_keys),A
;  162		keys[0x1] = keypad[controlMap[0x1]];
.LINE 162

	LD	HL,_controlMap
	INC	HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,_keys
	LD	A,(HL)
	LD	(IY+1),A
;  163		keys[0x2] = keypad[controlMap[0x2]];
.LINE 163

	LD	HL,_controlMap+2
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+2),A
;  164		keys[0x3] = keypad[controlMap[0x3]];
.LINE 164

	LD	HL,_controlMap+3
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+3),A
;  165		                              
;  166		keys[0x4] = keypad[controlMap[0x4]];
.LINE 166

	LD	HL,_controlMap+4
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+4),A
;  167		keys[0x5] = keypad[controlMap[0x5]];
.LINE 167

	LD	HL,_controlMap+5
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+5),A
;  168		keys[0x6] = keypad[controlMap[0x6]];
.LINE 168

	LD	HL,_controlMap+6
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+6),A
;  169		keys[0x7] = keypad[controlMap[0x7]];
.LINE 169

	LD	HL,_controlMap+7
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+7),A
;  170		                              
;  171		keys[0x8] = keypad[controlMap[0x8]];
.LINE 171

	LD	HL,_controlMap+8
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+8),A
;  172		keys[0x9] = keypad[controlMap[0x9]];
.LINE 172

	LD	HL,_controlMap+9
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+9),A
;  173		keys[0xA] = keypad[controlMap[0xA]];
.LINE 173

	LD	HL,_controlMap+10
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+10),A
;  174		keys[0xB] = keypad[controlMap[0xB]];
.LINE 174

	LD	HL,_controlMap+11
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+11),A
;  175		                              
;  176		keys[0xC] = keypad[controlMap[0xC]];
.LINE 176

	LD	HL,_controlMap+12
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+12),A
;  177		keys[0xD] = keypad[controlMap[0xD]];
.LINE 177

	LD	HL,_controlMap+13
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+13),A
;  178		keys[0xE] = keypad[controlMap[0xE]];
.LINE 178

	LD	HL,_controlMap+14
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+14),A
;  179		keys[0xF] = keypad[controlMap[0xF]];
.LINE 179

	LD	HL,_controlMap+15
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IY+15),A
;  180		
;  181		if(kb_Data[1] & kb_2nd) {
.LINE 181

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_11
	JR	L_15
;  182			while(kb_Data[1] & kb_2nd) {
L_12:
.LINE 182

;  183				kb_Scan();
.LINE 183

	CALL	_kb_Scan
;  184			}
L_11:
.LINE 184

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_12
;  185			paused = 1;
.LINE 185

	LD	A,1
	LD	(_paused),A
;  186		}
;  187	}
L_15:
.LINE 187

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setKeys ***************************
;Name                         Addr/Register   Size   Type
;_paused                             STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_keys                               STATIC     16   variable
;_controlMap                         STATIC     16   variable
;_keypad                             STATIC     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setKeys",187,"_setKeys"
;  188	
;  189	void emulateCycle(uint8_t steps) {
_emulateCycle:
.DEFINE "_emulateCycle"

.VALUE _emulateCycle

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emulateCycle",189,"_emulateCycle"

.LINE 189

.DEFINE "steps"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "cols"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -8

.TYPE 44

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -11

.TYPE 44

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -12

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -13

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -14

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -15

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -16

.TYPE 12

.ENDEF

.DEFINE "key_pressed"

.CLASS 65

.VALUE -17

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -18

.TYPE 12

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -21

.TYPE 44

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -22

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -23

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -24

.TYPE 12

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -25

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -26

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -27

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -28

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -29

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -30

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -31

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -32

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-86
	LD	SP,HL
;  190		
;  191		kb_Scan();
.LINE 191

	CALL	_kb_Scan
;  192		setKeys();
.LINE 192

	CALL	_setKeys
;  193		
;  194		for(step = 0; step < steps; ++step) {
.LINE 194

	XOR	A,A
	LD	(_step),A
	JR	L_166
L_164:
;  195			int i;
;  196			opcode = (memory[pc] << 8) | memory[pc+1];
.LINE 196

	LD	BC,(_pc)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	H,L
	LD	L,0
	LD	DE,HL
	LD	BC,(_pc)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,DE
	CALL	__sor
	LD	BC,HL
	LD	HL,_opcode
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  197			
;  198			pc += 2;
.LINE 198

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  199			
;  200			switch(opcode & 0xf000) {
.LINE 200

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	BC,61440
	CALL	__iand
	CALL	__case16D
	JP	(HL)
L__10:
	DW	16
	DW	0
	DW24	L_16	

	DW	4096
	DW24	L_55	

	DW	8192
	DW24	L_56	

	DW	12288
	DW24	L_58	

	DW	16384
	DW24	L_61	

	DW	20480
	DW24	L_64	

	DW	24576
	DW24	L_67	

	DW	28672
	DW24	L_68	

	DW	32768
	DW24	L_69	

	DW	36864
	DW24	L_80	

	DW	40960
	DW24	L_83	

	DW	45056
	DW24	L_84	

	DW	49152
	DW24	L_85	

	DW	53248
	DW24	L_86	

	DW	57344
	DW24	L_114	

	DW	61440
	DW24	L_122	

	DW24	L_165	

;  201				case 0x0000: {
L_16:
.LINE 201

;  202					switch(opcode & 0x00f0) {
.LINE 202

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,240
	UEXT	HL
	LD	L,A
	LD	BC,192
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_53
;  203						case 0x00c0: { //SCD
.LINE 203

;  204							uint8_t n = (opcode & 0x000f);
.LINE 204

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-25),A
;  205							uint8_t *disp;
;  206							
;  207							if(extendedScreen) {
.LINE 207

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_19
;  208								disp = &scanvas_data[2];
.LINE 208

	LD	BC,_scanvas_data+2
	LD	(IX+-21),BC
;  209							} else {
.LINE 209

	JR	L_24
L_19:
;  210								disp = &canvas_data[2];
.LINE 210

	LD	BC,_canvas_data+2
	LD	(IX+-21),BC
;  211							}
L_24:
.LINE 211

;  212							for(i = screen_height-2; i >= 0; i--) {
.LINE 212

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	DEC	HL
	DEC	HL
	LD	(IX+-3),HL
	JR	L_23
L_21:
;  213								memcpy(disp + (i+n)*screen_width, disp + i*screen_width, screen_width);
.LINE 213

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-21)
	ADD	HL,BC
	PUSH	HL
	LD	A,(IX+-25)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	DE,HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,(IX+-21)
	ADD	HL,BC
	PUSH	HL
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  214								memset(disp + i*screen_width, 0, screen_width);
.LINE 214

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-21)
	ADD	HL,BC
	PUSH	HL
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
;  215							}
L_23:
.LINE 215

	LD	HL,(IX+-3)
	CALL	__icmpzero
	JP	P,L_21
;  216							
;  217							drawFlag = true; 
.LINE 217

	LD	A,1
	LD	(_drawFlag),A
;  218							
;  219							break;
;  220						}
;  221						break;
;  222					}
L_53:
.LINE 222

;  223					switch(opcode & 0x00ff) {
.LINE 223

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__13:
	DW	7
	DB	224
	DW24	L_26	

	DB	238
	DW24	L_30	

	DB	251
	DW24	L_31	

	DB	252
	DW24	L_40	

	DB	253
	DW24	L_49	

	DB	254
	DW24	L_50	

	DB	255
	DW24	L_51	

	DW24	L_52	

;  224						case 0x00e0:
L_26:
.LINE 224

;  225							if(extendedScreen)
.LINE 225

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_28
;  226								memset(scanvas_data + 2, 0, 8192);
.LINE 226

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scanvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  227							else
.LINE 227

	JR	L_29
L_28:
;  228								memset(canvas_data + 2, 0, 2048);
.LINE 228

	LD	BC,2048
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
L_29:
;  229							drawFlag = true;
.LINE 229

	LD	A,1
	LD	(_drawFlag),A
;  230							break;
.LINE 230

	JR	L_165
;  231						case 0x00ee:
L_30:
.LINE 231

;  232							pc = stack[(--sp)&0xf];
.LINE 232

	LD	A,(_sp)
	DEC	A
	LD	(_sp),A
	AND	A,15
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	BC,(HL)
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  233							break;
.LINE 233

	JR	L_165
;  234						case 0x00fb: { //SCR
L_31:
.LINE 234

;  235							uint8_t *disp;
;  236							
;  237							if(extendedScreen) {
.LINE 237

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_33
;  238								disp = &scanvas_data[2];
.LINE 238

	LD	BC,_scanvas_data+2
	LD	(IX+-8),BC
;  239							} else {
.LINE 239

	JR	L_38
L_33:
;  240								disp = &canvas_data[2];
.LINE 240

	LD	BC,_canvas_data+2
	LD	(IX+-8),BC
;  241							}
L_38:
.LINE 241

;  242							for(i = 0; i < screen_height; i++) {
.LINE 242

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_37
L_35:
;  243								memcpy(disp + 4, disp, screen_width - 4);
.LINE 243

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	LD	IY,(IX+-8)
	LEA	BC,IY+4
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  244								memset(disp, 0, 4);
.LINE 244

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  245								disp += screen_width;
.LINE 245

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-8)
	ADD	HL,BC
	LD	(IX+-8),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  246							}
L_37:
.LINE 246

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_35
;  247							break;
.LINE 247

	JR	L_165
;  248						}
;  249						case 0x00fc: { //SCL
L_40:
.LINE 249

;  250							uint8_t *disp;
;  251							
;  252							if(extendedScreen) {
.LINE 252

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_42
;  253								disp = &scanvas_data[2];
.LINE 253

	LD	BC,_scanvas_data+2
	LD	(IX+-11),BC
;  254							} else {
.LINE 254

	JR	L_47
L_42:
;  255								disp = &canvas_data[2];
.LINE 255

	LD	BC,_canvas_data+2
	LD	(IX+-11),BC
;  256							}
L_47:
.LINE 256

;  257							for(i = 0; i < screen_height; i++) {
.LINE 257

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_46
L_44:
;  258								memcpy(disp, disp + 4, screen_width - 4);
.LINE 258

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	IY,(IX+-11)
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,(IX+-11)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  259								memset(disp + screen_width - 4, 0, 4);
.LINE 259

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  260								disp += screen_width;
.LINE 260

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	(IX+-11),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  261							}
L_46:
.LINE 261

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_44
;  262							break;
.LINE 262

	JR	L_165
;  263						}
;  264						case 0x00fd:
L_49:
.LINE 264

;  265							playing = 0;
.LINE 265

	XOR	A,A
	LD	(_playing),A
;  266							//exit
;  267							break;
.LINE 267

	JR	L_165
;  268						case 0x00fe:
L_50:
.LINE 268

;  269							extendedScreen = 0;
.LINE 269

	XOR	A,A
	LD	(_extendedScreen),A
;  270							screen_width = 64;
.LINE 270

	LD	A,64
	LD	(_screen_width),A
;  271							screen_height = 32;
.LINE 271

	LD	A,32
	LD	(_screen_height),A
;  272							dbg_sprintf(dbgout, "Extended mode off\n");
.LINE 272

	LD	BC,L__19
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  273							break;
.LINE 273

	JR	L_165
;  274						case 0x00ff:
L_51:
.LINE 274

;  275							extendedScreen = 1;
.LINE 275

	LD	A,1
	LD	(_extendedScreen),A
;  276							screen_width = 128;
.LINE 276

	LD	A,128
	LD	(_screen_width),A
;  277							screen_height = 64;
.LINE 277

	LD	A,64
	LD	(_screen_height),A
;  278							dbg_sprintf(dbgout, "Extended mode on\n");
.LINE 278

	LD	BC,L__20
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  279							break;
.LINE 279

	JR	L_165
;  280						default:
L_52:
.LINE 280

;  281							pc = (pc & 0x0fff);
.LINE 281

	LD	HL,(_pc)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  282							break;
.LINE 282

	JR	L_165
;  283					}
;  284					break;
;  285				}
;  286				case 0x1000: {
L_55:
.LINE 286

;  287					pc = (opcode & 0x0fff);
.LINE 287

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  288					break;
.LINE 288

	JR	L_165
;  289				}
;  290				case 0x2000: {
L_56:
.LINE 290

;  291					stack[sp++] = pc;
.LINE 291

	LD	A,(_sp)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	A,(_pc)
	LD	(HL),A
	INC	HL
	LD	A,(_pc+1)
	LD	(HL),A
	LD	A,(_sp)
	INC	A
	LD	(_sp),A
;  292					pc = (opcode & 0x0fff);
.LINE 292

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  293					break;
.LINE 293

	JR	L_165
;  294				}
;  295				case 0x3000: {
L_58:
.LINE 295

;  296					if(V[(opcode & 0x0f00) >> 8] == (opcode & 0x00ff))
.LINE 296

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_165
;  297						pc += 2;
.LINE 297

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  298					break;
.LINE 298

	JR	L_165
;  299				}
;  300				case 0x4000: {
L_61:
.LINE 300

;  301					if(V[(opcode & 0x0f00) >> 8] != (opcode & 0x00ff))
.LINE 301

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	Z,L_165
;  302						pc += 2;
.LINE 302

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  303					break;
.LINE 303

	JR	L_165
;  304				}
;  305				case 0x5000: {
L_64:
.LINE 305

;  306					if(V[(opcode & 0x0f00) >> 8] == V[(opcode & 0x00f0) >> 4])
.LINE 306

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	NZ,L_165
;  307						pc += 2;
.LINE 307

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  308					break;
.LINE 308

	JR	L_165
;  309				}
;  310				case 0x6000: {
L_67:
.LINE 310

;  311					V[(opcode & 0x0f00) >> 8] = (opcode & 0x00ff);
.LINE 311

	LD	A,(_opcode)
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  312					break;
.LINE 312

	JR	L_165
;  313				}
;  314				case 0x7000: {
L_68:
.LINE 314

;  315					V[(opcode & 0x0f00) >> 8] = (V[(opcode & 0x0f00) >> 8] + (opcode & 0x00ff)) & 0xff;
.LINE 315

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-38),HL
	LD	A,(_opcode)
	LD	HL,(IX+-38)
	ADD	A,(HL)
	LD	HL,(IX+-38)
	LD	(HL),A
;  316					break;
.LINE 316

	JR	L_165
;  317				}
;  318				case 0x8000: {
L_69:
.LINE 318

;  319					switch(opcode & 0x000f) {
.LINE 319

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__24:
	DW	9
	DB	0
	DW24	L_70	

	DB	1
	DW24	L_71	

	DB	2
	DW24	L_72	

	DB	3
	DW24	L_73	

	DB	4
	DW24	L_74	

	DB	5
	DW24	L_75	

	DB	6
	DW24	L_76	

	DB	7
	DW24	L_77	

	DB	14
	DW24	L_78	

	DW24	L_165	

;  320						case 0x0000: {
L_70:
.LINE 320

;  321							V[(opcode & 0x0f00) >> 8]  = V[(opcode & 0x00f0) >> 4];
.LINE 321

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
;  322							break;
.LINE 322

	JR	L_165
;  323						}
;  324						case 0x0001: {
L_71:
.LINE 324

;  325							V[(opcode & 0x0f00) >> 8] |= V[(opcode & 0x00f0) >> 4];
.LINE 325

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-41),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-41)
	LD	A,(HL)
	OR	A,(IY)
	LD	HL,(IX+-41)
	LD	(HL),A
;  326							break;
.LINE 326

	JR	L_165
;  327						}
;  328						case 0x0002: {
L_72:
.LINE 328

;  329							V[(opcode & 0x0f00) >> 8] &= V[(opcode & 0x00f0) >> 4];
.LINE 329

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-44),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-44)
	LD	A,(HL)
	AND	A,(IY)
	LD	HL,(IX+-44)
	LD	(HL),A
;  330							break;
.LINE 330

	JR	L_165
;  331						}
;  332						case 0x0003: {
L_73:
.LINE 332

;  333							V[(opcode & 0x0f00) >> 8] ^= V[(opcode & 0x00f0) >> 4];
.LINE 333

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-47),HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-47)
	LD	A,(HL)
	XOR	A,(IY)
	LD	HL,(IX+-47)
	LD	(HL),A
;  334							break;
.LINE 334

	JR	L_165
;  335						}
;  336						case 0x0004: {
L_74:
.LINE 336

;  337							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 337

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-32),A
;  338							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 338

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-13),A
;  339							V[0xf] = (V[x] + V[y] > 0xff);
.LINE 339

	LD	A,(IX+-32)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-50),HL
	LD	A,(IX+-13)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-50)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,HL
	LD	HL,255
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L__26
	LD	A,1
	JR	L__27
L__26:
	XOR	A,A
L__27:
	LD	HL,_V+15
	LD	(HL),A
;  340							V[x] += V[y];
.LINE 340

	LD	A,(IX+-13)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-50)
	LD	(IX+-74),HL	; spill
	LD	HL,(IX+-50)
	LD	(IX+-83),HL	; spill
	LD	HL,(IX+-74)	; unspill
	LD	A,(HL)
	ADD	A,(IY)
	LD	HL,(IX+-83)	; unspill
	LD	(HL),A
;  341							V[x] &= 255;
.LINE 341

	LD	HL,(IX+-50)
	LD	A,(HL)
	LD	HL,(IX+-50)
	LD	(HL),A
;  342							break;
.LINE 342

	JR	L_165
;  343						}
;  344						case 0x0005: {
L_75:
.LINE 344

;  345							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 345

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-31),A
;  346							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 346

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-14),A
;  347							V[0xf] = V[x] >= V[y];
.LINE 347

	LD	A,(IX+-31)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-53),HL
	LD	A,(IX+-14)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-53)
	LD	A,(IY)
	CP	A,(HL)
	JR	C,L__29
	LD	A,1
	JR	L__30
L__29:
	XOR	A,A
L__30:
	LD	HL,_V+15
	LD	(HL),A
;  348							V[x] -= V[y];
.LINE 348

	LD	IY,(IX+-53)
	LD	A,(IX+-14)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(IX+-74),HL	; spill
	LD	HL,(IX+-53)
	LD	(IX+-80),HL	; spill
	LD	HL,(IX+-74)	; unspill
	LD	A,(IY)
	SUB	A,(HL)
	LD	HL,(IX+-80)	; unspill
	LD	(HL),A
;  349							break;
.LINE 349

	JR	L_165
;  350						}
;  351						case 0x0006: {
L_76:
.LINE 351

;  352							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 352

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-23),A
;  353							const uint8_t y = (opcode & 0x00f0) >> 4;
;  354							V[0xf] = V[x] & 1;
.LINE 354

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-56),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,_V+15
	LD	(HL),A
;  355							V[x] >>= 1;
.LINE 355

	LD	HL,(IX+-56)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,1
	CALL	__ishrs_b
	LD	IY,(IX+-56)
	LD	(IY),L
;  356							break;
.LINE 356

	JR	L_165
;  357						}
;  358						case 0x0007: {
L_77:
.LINE 358

;  359							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 359

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-24),A
;  360							const uint8_t y = (opcode & 0x00f0) >> 4;
.LINE 360

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-12),A
;  361							V[0xf] = V[y] >= V[x];
.LINE 361

	LD	A,(IX+-24)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-59),HL
	LD	A,(IX+-12)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-59)
	LD	A,(HL)
	CP	A,(IY)
	JR	C,L__32
	LD	A,1
	JR	L__33
L__32:
	XOR	A,A
L__33:
	LD	HL,_V+15
	LD	(HL),A
;  362							V[x] = V[y] - V[x];
.LINE 362

	LD	A,(IX+-12)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-59)
	LD	(IX+-74),HL	; spill
	LD	HL,(IX+-59)
	LD	(IX+-77),HL	; spill
	LD	HL,(IX+-74)	; unspill
	LD	A,(HL)
	SUB	A,(IY)
	LD	HL,(IX+-77)	; unspill
	LD	(HL),A
;  363							break;
.LINE 363

	JR	L_165
;  364						}
;  365						case 0x000E: {
L_78:
.LINE 365

;  366							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 366

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-30),A
;  367							const uint8_t y = (opcode & 0x00f0) >> 4;
;  368							V[0xf] = V[x] >> 7;
.LINE 368

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-62),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,7
	CALL	__ishrs_b
	LD	IY,_V
	LD	(IY+15),L
;  369							V[x] <<= 1;
.LINE 369

	LD	HL,(IX+-62)
	LD	A,(HL)
	ADD	A,A
	LD	HL,(IX+-62)
	LD	(HL),A
;  370							break;
.LINE 370

	JR	L_165
;  371						}
;  372						break;
;  373					}
;  374					break;
;  375				}
;  376				case 0x9000: {
L_80:
.LINE 376

;  377					if(V[(opcode & 0x0f00) >> 8] != V[(opcode & 0x00f0) >> 4])
.LINE 377

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_165
;  378						pc += 2;
.LINE 378

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  379					break;
.LINE 379

	JR	L_165
;  380				}
;  381				case 0xa000: {
L_83:
.LINE 381

;  382					I = (opcode & 0x0fff);
.LINE 382

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  383					break;
.LINE 383

	JR	L_165
;  384				}
;  385				case 0xb000: {
L_84:
.LINE 385

;  386					pc = V[0] + (opcode & 0x0fff);
.LINE 386

	LD	A,(_V)
	LD	C,A
	LD	B,0
	LD	DE,BC
	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  387					break;
.LINE 387

	JR	L_165
;  388				}
;  389				case 0xc000: {
L_85:
.LINE 389

;  390					V[(opcode & 0x0f00) >> 8] = (rand() & 0xff) & (opcode & 0x00FF);
.LINE 390

	LD	A,(_opcode)
	LD	B,A
	LD	(IX+-86),BC
	CALL	_rand
	LD	BC,(IX+-86)
	LD	A,B
	AND	A,L
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  391					break;
.LINE 391

	JR	L_165
;  392				}
;  393				case 0xd000: {
L_86:
.LINE 393

;  394					uint8_t x = V[(opcode & 0x0f00) >> 8];
.LINE 394

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-22),A
;  395					uint8_t y = V[(opcode & 0x00f0) >> 4];
.LINE 395

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-18),A
;  396					uint8_t height = (opcode & 0x000f);
.LINE 396

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-4),A
;  397					
;  398					V[0xf] = 0;
.LINE 398

	LD	HL,_V+15
	LD	(HL),0
;  399					
;  400					if(extendedScreen) {
.LINE 400

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_112
;  401						//Extended screen DXY0
;  402						uint8_t cols = 1;
.LINE 402

	LD	(IX+-5),1
;  403						if(height == 0) {
.LINE 403

	LD	A,(IX+-4)
	OR	A,A
	JR	NZ,L_101
;  404							cols = 2;
.LINE 404

	LD	(IX+-5),2
;  405							height = 16;
.LINE 405

	LD	(IX+-4),16
;  406						}
L_101:
.LINE 406

;  407						for(_y = 0; _y < height; ++_y) {
.LINE 407

	XOR	A,A
	LD	(__y),A
	JR	L_100
L_98:
;  408							pixel = memory[I + (cols*_y)];
.LINE 408

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  409							if(cols == 2) {
.LINE 409

	LD	A,(IX+-5)
	CP	A,2
	JR	NZ,L_97
;  410								pixel <<= 8;
.LINE 410

	LD	HL,(_pixel)
	LD	H,L
	LD	L,0
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  411								pixel |= memory[I + (_y << 1)+1];
.LINE 411

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	BC,(_pixel)
	CALL	__sor
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  412							}
L_97:
.LINE 412

;  413							for(_x = 0; _x < (cols << 3); ++_x) {
.LINE 413

	XOR	A,A
	LD	(__x),A
	JR	L_96
L_94:
;  414								if((pixel & (((cols == 2) ? 0x8000 : 0x80) >> _x)) != 0) {
.LINE 414

	LD	A,(IX+-5)
	CP	A,2
	JR	NZ,L_91
	LD	BC,32768
	LD	(IX+-35),BC
	JR	L_92
L_91:
	LD	BC,128
	LD	(IX+-35),BC
L_92:
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-35)
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_95
;  415									index = (((x + _x) & 0x7f) + (((y + _y) & 0x3f) << 7)) + 2;
.LINE 415

	LD	A,(__x)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-22)
	ADD.SIS	HL,BC
	LD	A,L
	RES	7,A
	LD	C,A
	LD	DE,BC
	LD	A,(__y)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-18)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,63
	LD	C,A
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  416									V[0xf] = scanvas_data[index] & 1;
.LINE 416

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_scanvas_data
	ADD	HL,BC
	LD	(IX+-65),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,_V+15
	LD	(HL),A
;  417									scanvas_data[index] = ~scanvas_data[index];
.LINE 417

	LD	HL,(IX+-65)
	LD	A,(HL)
	CPL	
	LD	HL,(IX+-65)
	LD	(HL),A
;  418								}
;  419							}
L_95:
.LINE 419

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_96:
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JP	M,L_94
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  420						}
L_100:
.LINE 420

	LD	A,(__y)
	CP	A,(IX+-4)
	JR	C,L_98
	JR	L_113
;  421					} else {
L_112:
.LINE 421

;  422						//Normal screen DXYN
;  423						if(height == 0) height = 16;
.LINE 423

	LD	A,(IX+-4)
	OR	A,A
	JR	NZ,L_110
	LD	(IX+-4),16
L_110:
;  424						for(_y = 0; _y < height; ++_y) {
.LINE 424

	XOR	A,A
	LD	(__y),A
	JR	L_109
L_107:
;  425							pixel = memory[I + _y];
.LINE 425

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,HL
	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  426							for(_x = 0; _x < 8; ++_x) {
.LINE 426

	XOR	A,A
	LD	(__x),A
	JR	L_106
L_104:
;  427								if((pixel & (0x80 >> _x)) != 0) {
.LINE 427

	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,128
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_105
;  428									index = (((x + _x) & 0x3f) + (((y + _y) & 0x1f) << 6)) + 2;
.LINE 428

	LD	A,(__x)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-22)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,63
	LD	C,A
	LD	DE,BC
	LD	A,(__y)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-18)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,31
	LD	C,A
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  429									V[0xf] = canvas_data[index] & 1;
.LINE 429

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(IX+-68),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,_V+15
	LD	(HL),A
;  430									canvas_data[index] = ~canvas_data[index];
.LINE 430

	LD	HL,(IX+-68)
	LD	A,(HL)
	CPL	
	LD	HL,(IX+-68)
	LD	(HL),A
;  431								}
;  432							}
L_105:
.LINE 432

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_106:
	LD	A,(__x)
	CP	A,8
	JR	C,L_104
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  433						}
L_109:
.LINE 433

	LD	A,(__y)
	CP	A,(IX+-4)
	JR	C,L_107
;  434					}
L_113:
.LINE 434

;  435					
;  436					drawFlag = true;
.LINE 436

	LD	A,1
	LD	(_drawFlag),A
;  437					
;  438					break;
.LINE 438

	JR	L_165
;  439				}
;  440				case 0xe000: {
L_114:
.LINE 440

;  441					switch(opcode & 0x00ff) {
.LINE 441

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__46:
	DW	2
	DB	158
	DW24	L_115	

	DB	161
	DW24	L_118	

	DW24	L_165	

;  442						case 0x009e: {
L_115:
.LINE 442

;  443							if(keys[V[(opcode & 0x0f00) >> 8]])
.LINE 443

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_165
;  444								pc += 2;
.LINE 444

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  445							break;
.LINE 445

	JR	L_165
;  446						}
;  447						case 0x00a1: {
L_118:
.LINE 447

;  448							if(!keys[V[(opcode & 0x0f00) >> 8]])
.LINE 448

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_165
;  449								pc += 2;
.LINE 449

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  450							break;
.LINE 450

	JR	L_165
;  451						}
;  452					}
;  453					break;
;  454				}
;  455				case 0xf000: {
L_122:
.LINE 455

;  456					switch(opcode & 0x00ff) {
.LINE 456

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__49:
	DW	12
	DB	7
	DW24	L_123	

	DB	10
	DW24	L_124	

	DB	21
	DW24	L_131	

	DB	24
	DW24	L_133	

	DB	30
	DW24	L_134	

	DB	41
	DW24	L_135	

	DB	48
	DW24	L_136	

	DB	51
	DW24	L_137	

	DB	85
	DW24	L_138	

	DB	101
	DW24	L_143	

	DB	117
	DW24	L_148	

	DB	133
	DW24	L_155	

	DW24	L_165	

;  457						case 0x0007: {
L_123:
.LINE 457

;  458							V[(opcode & 0x0f00) >> 8] = delay_timer;
.LINE 458

	LD	A,(_delay_timer)
	LD	D,A
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  459							break;
.LINE 459

	JR	L_165
;  460						}
;  461						case 0x000A: {
L_124:
.LINE 461

;  462							bool key_pressed = false;
.LINE 462

	LD	(IX+-17),0
;  463							pc -= 2;
.LINE 463

	LD	IY,(_pc)
	LEA	BC,IY+-2
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  464							
;  465							for(i = 0; i < 16; ++i) {
.LINE 465

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_128
L_126:
;  466								if(keys[i]) {
.LINE 466

	LD	BC,_keys
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_127
;  467									V[(opcode & 0x0f00) >> 8] = i;
.LINE 467

	LD	D,(IX+-3)
	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(HL),D
;  468									pc += 2;
.LINE 468

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  469									key_pressed = true;
.LINE 469

	LD	(IX+-17),1
;  470									break;
.LINE 470

	JR	L_130
;  471								}
;  472							}
L_127:
.LINE 472

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_128:
	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_126
L_130:
;  473							
;  474							if(!key_pressed)
.LINE 474

	LD	A,(IX+-17)
	OR	A,A
	JR	Z,L_171
;  475								return;
.LINE 475

;  476						}
.LINE 476

;  477						case 0x0015: {
L_131:
.LINE 477

;  478							delay_timer = V[(opcode & 0x0f00) >> 8];
.LINE 478

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  479							break;
.LINE 479

	JR	L_165
;  480						}
;  481						case 0x0018: {
L_133:
.LINE 481

;  482							sound_timer = V[(opcode & 0x0f00) >> 8];
.LINE 482

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  483							break;
.LINE 483

	JR	L_165
;  484						}
;  485						case 0x001E: {
L_134:
.LINE 485

;  486							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 486

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-26),A
;  487							I = (I + V[x]) & 0xffff;
.LINE 487

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	DE,(_I)
	LD	HL,BC
	ADD.SIS	HL,DE
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  488							break;
.LINE 488

	JR	L_165
;  489						}
;  490						case 0x0029: {
L_135:
.LINE 490

;  491							I = (V[(opcode & 0x0f00) >> 8] & 0xf) * 5;
.LINE 491

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	AND	A,15
	LD	C,A
	LD	B,0
	LD.LIS	HL,5
	CALL	__smulu
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  492							break;
.LINE 492

	JR	L_165
;  493						}
;  494						case 0x0030: {
L_136:
.LINE 494

;  495							I = (V[(opcode & 0x0f00) >> 8] & 0xf) * 10 + 80;
.LINE 495

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	AND	A,15
	LD	C,A
	LD	B,0
	LD.LIS	HL,10
	CALL	__smulu
	LD	IY,HL
	LEA	BC,IY+80
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  496							break;
.LINE 496

	JR	L_165
;  497						}
;  498						case 0x0033: {
L_137:
.LINE 498

;  499							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 499

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-27),A
;  500							memory[ I ] =  V[x] / 100;
.LINE 500

	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-71),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,100
	CALL	__idivs
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  501							memory[I+1] = (V[x] / 10) % 10;
.LINE 501

	LD	HL,(IX+-71)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  502							memory[I+2] = V[x] % 10;
.LINE 502

	LD	HL,(IX+-71)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  503							break;
.LINE 503

	JR	L_165
;  504						}
;  505						case 0x0055: {
L_138:
.LINE 505

;  506							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 506

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-28),A
;  507							for(i = 0; i <= x; ++i) {
.LINE 507

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_141
L_139:
;  508								memory[I + i] = V[i];
.LINE 508

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  509							}
L_141:
.LINE 509

	LD	A,(IX+-28)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	P,L_139
;  510							break;
.LINE 510

	JR	L_165
;  511						}
;  512						case 0x0065: {
L_143:
.LINE 512

;  513							const uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 513

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-29),A
;  514							for(i = 0; i <= x; ++i) {
.LINE 514

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_146
L_144:
;  515								V[i] = memory[I + i];
.LINE 515

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  516							}
L_146:
.LINE 516

	LD	A,(IX+-29)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_144
;  517							break;
.LINE 517

	JR	L_165
;  518						}
;  519						case 0x0075: {
L_148:
.LINE 519

;  520							uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 520

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-15),A
;  521							if (x > 7) x = 7;
.LINE 521

	LD	A,7
	CP	A,(IX+-15)
	JR	NC,L_153
	LD	(IX+-15),7
L_153:
;  522							for(i = 0; i <= x; ++i) {
.LINE 522

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_152
L_150:
;  523								SV[i] = V[i];
.LINE 523

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  524							}
L_152:
.LINE 524

	LD	A,(IX+-15)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_150
;  525							break;
.LINE 525

	JR	L_165
;  526						}
;  527						case 0x0085: {
L_155:
.LINE 527

;  528							uint8_t x = (opcode & 0x0f00) >> 8;
.LINE 528

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-16),A
;  529							if (x > 7) x = 7;
.LINE 529

	LD	A,7
	CP	A,(IX+-16)
	JR	NC,L_160
	LD	(IX+-16),7
L_160:
;  530							for(i = 0; i <= x; ++i) {
.LINE 530

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_159
L_157:
;  531								V[i] = SV[i];
.LINE 531

	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  532							}
L_159:
.LINE 532

	LD	A,(IX+-16)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_157
;  533							break;
;  534						}
;  535					}
;  536					break;
;  537				}
;  538				default:
;  539					break;
;  540			}
;  541		}
L_165:
.LINE 541

	LD	A,(_step)
	INC	A
	LD	(_step),A
L_166:
	LD	A,(_step)
	CP	A,(IX+6)
	JR	C,L_164
;  542		if(sound_timer > 0) {
.LINE 542

	LD	BC,(_sound_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_170
;  543			--sound_timer;
.LINE 543

	LD	BC,(_sound_timer)
	DEC	BC
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  544		}
L_170:
.LINE 544

;  545		if(delay_timer > 0) {
.LINE 545

	LD	BC,(_delay_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_171
;  546			--delay_timer;
.LINE 546

	LD	BC,(_delay_timer)
	DEC	BC
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  547		}
;  548	}
L_171:
.LINE 548

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emulateCycle ***************************
;Name                         Addr/Register   Size   Type
;_SV                                 STATIC      8   variable
;_sound_timer                        STATIC      2   variable
;_delay_timer                        STATIC      2   variable
;_keys                               STATIC     16   variable
;_index                              STATIC      2   variable
;__x                                 STATIC      1   variable
;_pixel                              STATIC      2   variable
;__y                                 STATIC      1   variable
;_rand                               IMPORT  -----   function
;_I                                  STATIC      2   variable
;_V                                  STATIC     16   variable
;_sprintf                            IMPORT  -----   function
;_playing                            STATIC      1   variable
;_stack                              STATIC     32   variable
;_sp                                 STATIC      1   variable
;_drawFlag                           STATIC      1   variable
;_memset                             IMPORT  -----   function
;_screen_width                       STATIC      1   variable
;_memcpy                             IMPORT  -----   function
;_screen_height                      STATIC      1   variable
;_canvas_data                        IMPORT   2050   variable
;_scanvas_data                       IMPORT   8194   variable
;_extendedScreen                     STATIC      1   variable
;_opcode                             STATIC      2   variable
;_pc                                 STATIC      2   variable
;_memory                             STATIC   4096   variable
;_step                               STATIC      1   variable
;_setKeys                            IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;temp89                               IX-35      3   variable
;x                                    IX-32      1   variable
;x                                    IX-31      1   variable
;x                                    IX-30      1   variable
;x                                    IX-29      1   variable
;x                                    IX-28      1   variable
;x                                    IX-27      1   variable
;x                                    IX-26      1   variable
;n                                    IX-25      1   variable
;x                                    IX-24      1   variable
;x                                    IX-23      1   variable
;x                                    IX-22      1   variable
;disp                                 IX-21      3   variable
;y                                    IX-18      1   variable
;key_pressed                          IX-17      1   variable
;x                                    IX-16      1   variable
;x                                    IX-15      1   variable
;y                                    IX-14      1   variable
;y                                    IX-13      1   variable
;y                                    IX-12      1   variable
;disp                                 IX-11      3   variable
;disp                                  IX-8      3   variable
;cols                                  IX-5      1   variable
;height                                IX-4      1   variable
;i                                     IX-3      3   variable
;steps                                 IX+6      1   parameter


; Stack Frame Size: 95 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emulateCycle",548,"_emulateCycle"
	SEGMENT STRSECT
L__19:
	DB	"Extended mode off"
	DB	10,0
L__20:
	DB	"Extended mode on"
	DB	10,0
	XREF _scanvas_data:ROM
	XREF _canvas_data:ROM
	XREF _kb_Scan:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _sprintf:ROM
	XREF _ti_GetSize:ROM
	XREF _ti_Read:ROM
	XREF _ti_Open:ROM
	XREF _ti_CloseAll:ROM
	XREF _rand:ROM
	XREF _srand:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __sor:ROM
	XREF __sand:ROM
	XREF __iand:ROM
	XREF __smulu:ROM
	XREF __irems:ROM
	XREF __ishrs:ROM
	XREF __stoiu:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __case8D:ROM
	XREF __case16D:ROM
	XREF __ishrs_b:ROM
	XREF __sshru_b:ROM
	XDEF _emulateCycle
	XDEF _setKeys
	XDEF _loadProgram
	XDEF _initialize
	XDEF _screen_height
	XDEF _screen_width
	XDEF __x
	XDEF __y
	XDEF _index
	XDEF _pixel
	XDEF _step
	XDEF _fontset_ten
	XDEF _fontset
	XDEF _file
	XDEF _controlMap
	XDEF _keypad
	XDEF _game_data
	XDEF _extendedScreen
	XDEF _playing
	XDEF _paused
	XDEF _drawFlag
	XDEF _keys
	XDEF _sp
	XDEF _stack
	XDEF _sound_timer
	XDEF _delay_timer
	XDEF _pc
	XDEF _I
	XDEF _V
	XDEF _SV
	XDEF _memory
	XDEF _opcode
	END
