; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\CHIP8.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME1"
.TYPE 104
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME7"
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME8",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME10"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME10",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME10"
.BEGREC "__stdio_file",1
.DEFINE "slot"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "__stdio_file"
	SEGMENT DATA
_opcode:
	DW	0
.DEFINE "opcode"
.ALIAS "_opcode"
.CLASS 69
.VALUE _opcode
.TYPE 13
.ENDEF
	SEGMENT BSS
_memory:
	DS	4096
.DEFINE "memory"
.ALIAS "_memory"
.CLASS 83
.VALUE _memory
.DIM 4096
.TYPE 108
.ENDEF
_SV:
	DS	8
.DEFINE "SV"
.ALIAS "_SV"
.CLASS 83
.VALUE _SV
.DIM 8
.TYPE 108
.ENDEF
_V:
	DS	16
.DEFINE "V"
.ALIAS "_V"
.CLASS 83
.VALUE _V
.DIM 16
.TYPE 108
.ENDEF
	SEGMENT DATA
_I:
	DW	0
.DEFINE "I"
.ALIAS "_I"
.CLASS 69
.VALUE _I
.TYPE 13
.ENDEF
_pc:
	DW	0
.DEFINE "pc"
.ALIAS "_pc"
.CLASS 69
.VALUE _pc
.TYPE 13
.ENDEF
_delay_timer:
	DW	0
.DEFINE "delay_timer"
.ALIAS "_delay_timer"
.CLASS 69
.VALUE _delay_timer
.TYPE 3
.ENDEF
_sound_timer:
	DW	0
.DEFINE "sound_timer"
.ALIAS "_sound_timer"
.CLASS 69
.VALUE _sound_timer
.TYPE 3
.ENDEF
	SEGMENT BSS
_stack:
	DS	32
.DEFINE "stack"
.ALIAS "_stack"
.CLASS 83
.VALUE _stack
.DIM 16
.TYPE 109
.ENDEF
	SEGMENT DATA
_sp:
	DB	0
.DEFINE "sp"
.ALIAS "_sp"
.CLASS 69
.VALUE _sp
.TYPE 12
.ENDEF
_keys:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
.DEFINE "keys"
.ALIAS "_keys"
.CLASS 69
.VALUE _keys
.DIM 16
.TYPE 108
.ENDEF
_drawFlag:
	DB	0
.DEFINE "drawFlag"
.ALIAS "_drawFlag"
.CLASS 69
.VALUE _drawFlag
.TYPE 12
.ENDEF
_paused:
	DB	0
.DEFINE "paused"
.ALIAS "_paused"
.CLASS 69
.VALUE _paused
.TYPE 12
.ENDEF
_playing:
	DB	0
.DEFINE "playing"
.ALIAS "_playing"
.CLASS 69
.VALUE _playing
.TYPE 12
.ENDEF
_extendedScreen:
	DB	0
.DEFINE "extendedScreen"
.ALIAS "_extendedScreen"
.CLASS 69
.VALUE _extendedScreen
.TYPE 12
.ENDEF
_plane:
	DB	1
.DEFINE "plane"
.ALIAS "_plane"
.CLASS 69
.VALUE _plane
.TYPE 12
.ENDEF
	SEGMENT BSS
_game_data:
	DS	3584
.DEFINE "game_data"
.ALIAS "_game_data"
.CLASS 83
.VALUE _game_data
.DIM 3584
.TYPE 108
.ENDEF
_canvas_data:
	DS	8194
.DEFINE "canvas_data"
.ALIAS "_canvas_data"
.CLASS 83
.VALUE _canvas_data
.DIM 8194
.TYPE 108
.ENDEF
_keypad:
	DS	16
.DEFINE "keypad"
.ALIAS "_keypad"
.CLASS 83
.VALUE _keypad
.DIM 16
.TYPE 108
.ENDEF
_controlMap:
	DS	16
.DEFINE "controlMap"
.ALIAS "_controlMap"
.CLASS 83
.VALUE _controlMap
.DIM 16
.TYPE 108
.ENDEF
_file:
	DS	1
.DEFINE "file"
.ALIAS "_file"
.CLASS 83
.VALUE _file
.TYPE 12
.ENDEF
	SEGMENT DATA
_fontset:
	DB	240
	DB	144
	DB	144
	DB	144
	DB	240
	DB	32
	DB	96
	DB	32
	DB	32
	DB	112
	DB	240
	DB	16
	DB	240
	DB	128
	DB	240
	DB	240
	DB	16
	DB	240
	DB	16
	DB	240
	DB	144
	DB	144
	DB	240
	DB	16
	DB	16
	DB	240
	DB	128
	DB	240
	DB	16
	DB	240
	DB	240
	DB	128
	DB	240
	DB	144
	DB	240
	DB	240
	DB	16
	DB	32
	DB	64
	DB	64
	DB	240
	DB	144
	DB	240
	DB	144
	DB	240
	DB	240
	DB	144
	DB	240
	DB	16
	DB	240
	DB	240
	DB	144
	DB	240
	DB	144
	DB	144
	DB	224
	DB	144
	DB	224
	DB	144
	DB	224
	DB	240
	DB	128
	DB	128
	DB	128
	DB	240
	DB	224
	DB	144
	DB	144
	DB	144
	DB	224
	DB	240
	DB	128
	DB	240
	DB	128
	DB	240
	DB	240
	DB	128
	DB	240
	DB	128
	DB	128
.DEFINE "fontset"
.ALIAS "_fontset"
.CLASS 69
.VALUE _fontset
.DIM 80
.TYPE 108
.ENDEF
_fontset_ten:
	DW	50812
	DW	57038
	DW	63190
	DW	50918
	DW	124
	DW	12304
	DW	12528
	DW	12336
	DW	12336
	DW	252
	DW	52344
	DW	3276
	DW	12312
	DW	52320
	DW	252
	DW	52344
	DW	3084
	DW	3128
	DW	52236
	DW	120
	DW	7180
	DW	27708
	DW	65228
	DW	3084
	DW	30
	DW	49404
	DW	49344
	DW	3320
	DW	52236
	DW	120
	DW	24632
	DW	49344
	DW	52472
	DW	52428
	DW	120
	DW	50942
	DW	1734
	DW	6156
	DW	12336
	DW	48
	DW	52344
	DW	60620
	DW	56440
	DW	52428
	DW	120
	DW	50812
	DW	50886
	DW	3198
	DW	12312
	DW	112
	DW	30768
	DW	52428
	DW	64716
	DW	52428
	DW	204
	DW	26364
	DW	26214
	DW	26236
	DW	26214
	DW	252
	DW	26172
	DW	49350
	DW	49344
	DW	26310
	DW	60
	DW	27896
	DW	26214
	DW	26214
	DW	27750
	DW	248
	DW	25342
	DW	25696
	DW	25724
	DW	25184
	DW	254
	DW	26366
	DW	25698
	DW	25724
	DW	24672
	DW	240
.DEFINE "fontset_ten"
.ALIAS "_fontset_ten"
.CLASS 69
.VALUE _fontset_ten
.DIM 80
.TYPE 109
.ENDEF
	SEGMENT BSS
_step:
	DS	1
.DEFINE "step"
.ALIAS "_step"
.CLASS 83
.VALUE _step
.TYPE 12
.ENDEF
_pixel:
	DS	2*1
.DEFINE "pixel"
.ALIAS "_pixel"
.CLASS 83
.VALUE _pixel
.TYPE 13
.ENDEF
_index:
	DS	2*1
.DEFINE "index"
.ALIAS "_index"
.CLASS 83
.VALUE _index
.TYPE 13
.ENDEF
__y:
	DS	1
.DEFINE "_y"
.ALIAS "__y"
.CLASS 83
.VALUE __y
.TYPE 12
.ENDEF
__x:
	DS	1
.DEFINE "_x"
.ALIAS "__x"
.CLASS 83
.VALUE __x
.TYPE 12
.ENDEF
_screen_width:
	DS	1
.DEFINE "screen_width"
.ALIAS "_screen_width"
.CLASS 83
.VALUE _screen_width
.TYPE 12
.ENDEF
_screen_height:
	DS	1
.DEFINE "screen_height"
.ALIAS "_screen_height"
.CLASS 83
.VALUE _screen_height
.TYPE 12
.ENDEF
_pixel_number:
	DS	1
.DEFINE "pixel_number"
.ALIAS "_pixel_number"
.CLASS 83
.VALUE _pixel_number
.TYPE 12
.ENDEF
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	
;    6	#include <math.h>
;    7	#include <stdio.h>
;    8	#include <stdlib.h>
;    9	#include <string.h>
;   10	
;   11	#include <fileioc.h>
;   12	#include <keypadc.h>
;   13	
;   14	#include "chip8.h"
;   15	#include "sprites_gfx.h"
;   16	
;   17	uint16_t opcode = 0;
;   18	uint8_t memory[0x1000];
;   19	uint8_t SV[8];
;   20	uint8_t V[16];
;   21	uint16_t I = 0;
;   22	uint16_t pc = 0;
;   23	int16_t delay_timer = 0;
;   24	int16_t sound_timer = 0;
;   25	uint16_t stack[16];
;   26	uint8_t sp = 0;
;   27	uint8_t keys[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;   28	bool drawFlag = false;
;   29	
;   30	bool paused = false;
;   31	bool playing = false;
;   32	bool extendedScreen = 0;
;   33	uint8_t plane = 1;
;   34	
;   35	uint8_t game_data[3584];
;   36	uint8_t canvas_data[8194];
;   37	uint8_t keypad[16];
;   38	uint8_t controlMap[16];
;   39	
;   40	ti_var_t file;
;   41	
;   42	unsigned char fontset[80] = {
;   43	    0xF0, 0x90, 0x90, 0x90, 0xF0, //0
;   44	    0x20, 0x60, 0x20, 0x20, 0x70, //1
;   45	    0xF0, 0x10, 0xF0, 0x80, 0xF0, //2
;   46	    0xF0, 0x10, 0xF0, 0x10, 0xF0, //3
;   47	    0x90, 0x90, 0xF0, 0x10, 0x10, //4
;   48	    0xF0, 0x80, 0xF0, 0x10, 0xF0, //5
;   49	    0xF0, 0x80, 0xF0, 0x90, 0xF0, //6
;   50	    0xF0, 0x10, 0x20, 0x40, 0x40, //7
;   51	    0xF0, 0x90, 0xF0, 0x90, 0xF0, //8
;   52	    0xF0, 0x90, 0xF0, 0x10, 0xF0, //9
;   53	    0xF0, 0x90, 0xF0, 0x90, 0x90, //A
;   54	    0xE0, 0x90, 0xE0, 0x90, 0xE0, //B
;   55	    0xF0, 0x80, 0x80, 0x80, 0xF0, //C
;   56	    0xE0, 0x90, 0x90, 0x90, 0xE0, //D
;   57	    0xF0, 0x80, 0xF0, 0x80, 0xF0, //E
;   58	    0xF0, 0x80, 0xF0, 0x80, 0x80  //F
;   59	};
;   60	uint16_t  fontset_ten[80] = {
;   61		0xC67C, 0xDECE, 0xF6D6, 0xC6E6, 0x007C, // 0
;   62		0x3010, 0x30F0, 0x3030, 0x3030, 0x00FC, // 1
;   63		0xCC78, 0x0CCC, 0x3018, 0xCC60, 0x00FC, // 2
;   64		0xCC78, 0x0C0C, 0x0C38, 0xCC0C, 0x0078, // 3
;   65		0x1C0C, 0x6C3C, 0xFECC, 0x0C0C, 0x001E, // 4
;   66		0xC0FC, 0xC0C0, 0x0CF8, 0xCC0C, 0x0078, // 5
;   67		0x6038, 0xC0C0, 0xCCF8, 0xCCCC, 0x0078, // 6
;   68		0xC6FE, 0x06C6, 0x180C, 0x3030, 0x0030, // 7
;   69		0xCC78, 0xECCC, 0xDC78, 0xCCCC, 0x0078, // 8
;   70		0xC67C, 0xC6C6, 0x0C7E, 0x3018, 0x0070, // 9
;   71		0x7830, 0xCCCC, 0xFCCC, 0xCCCC, 0x00CC, // A
;   72		0x66FC, 0x6666, 0x667C, 0x6666, 0x00FC, // B
;   73		0x663C, 0xC0C6, 0xC0C0, 0x66C6, 0x003C, // C
;   74		0x6CF8, 0x6666, 0x6666, 0x6C66, 0x00F8, // D
;   75		0x62FE, 0x6460, 0x647C, 0x6260, 0x00FE, // E
;   76		0x66FE, 0x6462, 0x647C, 0x6060, 0x00F0  // F
;   77	};
;   78	
;   79	uint8_t step;
;   80	uint16_t pixel;
;   81	uint16_t index;
;   82	
;   83	uint8_t _y;
;   84	uint8_t _x;
;   85	
;   86	uint8_t screen_width;
;   87	uint8_t screen_height;
;   88	uint8_t pixel_number;
	SEGMENT CODE
;   89	
;   90	void initialize() {
_initialize:
.DEFINE "_initialize"

.VALUE _initialize

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initialize",90,"_initialize"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   91		
;   92		opcode = I = sp = delay_timer = sound_timer = 0;
.LINE 92

	LD	HL,_sound_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_delay_timer
	LD	(HL),0
	INC	HL
	LD	(HL),0
	XOR	A,A
	LD	(_sp),A
	LD	HL,_I
	LD	(HL),0
	INC	HL
	LD	(HL),0
	LD	HL,_opcode
	LD	(HL),0
	INC	HL
	LD	(HL),0
;   93		pc = 0x200;
.LINE 93

	LD	HL,_pc
	LD	(HL),0
	INC	HL
	LD	(HL),2
;   94		
;   95		extendedScreen = 0;
.LINE 95

	XOR	A,A
	LD	(_extendedScreen),A
;   96		screen_width = 64;
.LINE 96

	LD	A,64
	LD	(_screen_width),A
;   97		screen_height = 32;
.LINE 97

	LD	A,32
	LD	(_screen_height),A
;   98	
;   99		canvas_data[0] = 64;
.LINE 99

	LD	A,64
	LD	(_canvas_data),A
;  100		canvas_data[1] = 32;
.LINE 100

	LD	HL,_canvas_data
	INC	HL
	LD	(HL),32
;  101		memset(canvas_data + 2, 0, 8192);
.LINE 101

	LD	BC,8192
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  102			
;  103		memset(keys, 0, 16);
.LINE 103

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_keys
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  104		memset(stack, 0, 16);
.LINE 104

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_stack
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  105		memset(V, 0, 16);
.LINE 105

	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_V
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  106		memset(SV, 0, 8);
.LINE 106

	LD	BC,8
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_SV
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  107		memset(memory, 0, 4096);
.LINE 107

	LD	BC,4096
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  108		
;  109		memcpy(memory, fontset, 80);
.LINE 109

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset
	PUSH	BC
	LD	BC,_memory
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  110		memcpy(memory + 80, fontset_ten, 80);
.LINE 110

	LD	BC,80
	PUSH	BC
	LD	BC,_fontset_ten
	PUSH	BC
	LD	BC,_memory+80
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  111		
;  112		srand(rtc_Time());
.LINE 112

	LD	BC,(15925316)
	PUSH	BC
	CALL	_srand
	POP	BC
;  113	}
.LINE 113

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initialize ***************************
;Name                         Addr/Register   Size   Type
;_srand                              IMPORT  -----   function
;_fontset_ten                        STATIC    160   variable
;_fontset                            STATIC     80   variable
;_memcpy                             IMPORT  -----   function
;_memory                             STATIC   4096   variable
;_SV                                 STATIC      8   variable
;_V                                  STATIC     16   variable
;_stack                              STATIC     32   variable
;_keys                               STATIC     16   variable
;_memset                             IMPORT  -----   function
;_canvas_data                        STATIC   8194   variable
;_screen_height                      STATIC      1   variable
;_screen_width                       STATIC      1   variable
;_extendedScreen                     STATIC      1   variable
;_pc                                 STATIC      2   variable
;_opcode                             STATIC      2   variable
;_I                                  STATIC      2   variable
;_sp                                 STATIC      1   variable
;_delay_timer                        STATIC      2   variable
;_sound_timer                        STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initialize",113,"_initialize"
;  114	
;  115	void loadProgram(char *fileName) {
_loadProgram:
.DEFINE "_loadProgram"

.VALUE _loadProgram

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "loadProgram",115,"_loadProgram"

.LINE 115

.DEFINE "fileName"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "romSize"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;  116		int i;
;  117		uint16_t romSize;
;  118		
;  119		playing = true;
.LINE 119

	LD	A,1
	LD	(_playing),A
;  120		paused = false;
.LINE 120

	XOR	A,A
	LD	(_paused),A
;  121		
;  122		ti_CloseAll();
.LINE 122

	CALL	_ti_CloseAll
;  123		file = ti_Open(fileName, "r");
.LINE 123

	LD	BC,L__1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(_file),A
;  124		ti_Read(&game_data, ti_GetSize(file), 1, file);
.LINE 124

	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	PUSH	HL
	LD	BC,_game_data
	PUSH	BC
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  125		
;  126		romSize = ti_GetSize(file)-22;
.LINE 126

	LD	A,(_file)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetSize
	POP	BC
	LD	IY,HL
	LEA	HL,IY+-22
	LD	(IX+-5),L
	LD	(IX+-4),H
;  127		
;  128		initialize();
.LINE 128

	CALL	_initialize
;  129		
;  130		if((4096-512) > romSize) {
.LINE 130

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,3584
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_9
;  131			for(i = 0; i < romSize; ++i) {
.LINE 131

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
;  132				memory[i + 512] = (uint8_t)game_data[i+22];
.LINE 132

	LD	IY,(IX+-3)
	LEA	HL,IY+22
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,512
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  133			}
L_3:
.LINE 133

	LD	BC,(IX+-5)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
;  134		}
L_9:
.LINE 134

;  135		for(i = 0; i < 16; i++) {
.LINE 135

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_8
L_6:
;  136			controlMap[i] = (uint8_t)game_data[i+6];
.LINE 136

	LD	IY,(IX+-3)
	LEA	HL,IY+6
	LD	BC,_game_data
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_controlMap
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  137		}
L_8:
.LINE 137

	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_6
;  138	}
.LINE 138

	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadProgram ***************************
;Name                         Addr/Register   Size   Type
;_controlMap                         STATIC     16   variable
;_memory                             STATIC   4096   variable
;_initialize                         IMPORT  -----   function
;_game_data                          STATIC   3584   variable
;_ti_GetSize                         IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_file                               STATIC      1   variable
;_ti_Open                            IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_paused                             STATIC      1   variable
;_playing                            STATIC      1   variable
;romSize                               IX-5      2   variable
;i                                     IX-3      3   variable
;fileName                              IX+6      3   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "loadProgram",138,"_loadProgram"
	SEGMENT STRSECT
L__1:
	DB	"r"
	DB	0
	SEGMENT CODE
;  139	
;  140	void setKeys() {
_setKeys:
.DEFINE "_setKeys"

.VALUE _setKeys

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setKeys",140,"_setKeys"

.LINE 140

.DEFINE "i"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  141		uint8_t i;
;  142		
;  143		keypad[0x0] = kb_Data[4] & kb_DecPnt;
.LINE 143

	LD	A,(16056344)
	AND	A,1
	LD	(_keypad),A
;  144		keypad[0x1] = kb_Data[3] & kb_7;
.LINE 144

	LD	A,(16056342)
	AND	A,8
	LD	HL,_keypad
	INC	HL
	LD	(HL),A
;  145		keypad[0x2] = kb_Data[4] & kb_8;
.LINE 145

	LD	A,(16056344)
	AND	A,8
	LD	IY,_keypad
	LEA	HL,IY+2
	LD	(HL),A
;  146		keypad[0x3] = kb_Data[5] & kb_9;
.LINE 146

	LD	A,(16056346)
	AND	A,8
	LEA	HL,IY+3
	LD	(HL),A
;  147		keypad[0x4] = kb_Data[3] & kb_4;
.LINE 147

	LD	A,(16056342)
	AND	A,4
	LEA	HL,IY+4
	LD	(HL),A
;  148		keypad[0x5] = kb_Data[4] & kb_5;
.LINE 148

	LD	A,(16056344)
	AND	A,4
	LEA	HL,IY+5
	LD	(HL),A
;  149		keypad[0x6] = kb_Data[5] & kb_6;
.LINE 149

	LD	A,(16056346)
	AND	A,4
	LEA	HL,IY+6
	LD	(HL),A
;  150		keypad[0x7] = kb_Data[3] & kb_1;
.LINE 150

	LD	A,(16056342)
	AND	A,2
	LEA	HL,IY+7
	LD	(HL),A
;  151		keypad[0x8] = kb_Data[4] & kb_2;
.LINE 151

	LD	A,(16056344)
	AND	A,2
	LEA	HL,IY+8
	LD	(HL),A
;  152		keypad[0x9] = kb_Data[5] & kb_3;
.LINE 152

	LD	A,(16056346)
	AND	A,2
	LEA	HL,IY+9
	LD	(HL),A
;  153		keypad[0xA] = kb_Data[3] & kb_0;
.LINE 153

	LD	A,(16056342)
	AND	A,1
	LEA	HL,IY+10
	LD	(HL),A
;  154		keypad[0xB] = kb_Data[5] & kb_Chs;
.LINE 154

	LD	A,(16056346)
	AND	A,1
	LEA	HL,IY+11
	LD	(HL),A
;  155		keypad[0xC] = kb_Data[6] & kb_Mul;
.LINE 155

	LD	A,(16056348)
	AND	A,8
	LEA	HL,IY+12
	LD	(HL),A
;  156		keypad[0xD] = kb_Data[6] & kb_Sub;
.LINE 156

	LD	A,(16056348)
	AND	A,4
	LEA	HL,IY+13
	LD	(HL),A
;  157		keypad[0xE] = kb_Data[6] & kb_Add;
.LINE 157

	LD	A,(16056348)
	AND	A,2
	LEA	HL,IY+14
	LD	(HL),A
;  158		keypad[0xF] = kb_Data[6] & kb_Enter;
.LINE 158

	LD	A,(16056348)
	AND	A,1
	LEA	HL,IY+15
	LD	(HL),A
;  159		
;  160		for(i = 0; i < 15; i++) {
.LINE 160

	LD	(IX+-1),0
	JR	L_14
L_12:
;  161			keys[i] = keypad[controlMap[i]];
.LINE 161

	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,_controlMap
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keypad
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	INC	(IX+-1)
;  162		}
L_14:
.LINE 162

	LD	A,(IX+-1)
	CP	A,15
	JR	C,L_12
;  163		
;  164		if(kb_Data[1] & kb_2nd) {
.LINE 164

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_15
	JR	L_20
;  165			while(kb_Data[1] & kb_2nd) {
L_16:
.LINE 165

;  166				kb_Scan();
.LINE 166

	CALL	_kb_Scan
;  167			}
L_15:
.LINE 167

	LD	A,(16056338)
	AND	A,32
	JR	NZ,L_16
;  168			paused = 1;
.LINE 168

	LD	A,1
	LD	(_paused),A
;  169		}
;  170	}
L_20:
.LINE 170

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setKeys ***************************
;Name                         Addr/Register   Size   Type
;_paused                             STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_keys                               STATIC     16   variable
;_controlMap                         STATIC     16   variable
;_keypad                             STATIC     16   variable
;i                                     IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setKeys",170,"_setKeys"
;  171	
;  172	void emulateCycle(uint8_t steps) {
_emulateCycle:
.DEFINE "_emulateCycle"

.VALUE _emulateCycle

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emulateCycle",172,"_emulateCycle"

.LINE 172

.DEFINE "steps"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "cols"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -10

.TYPE 44

.ENDEF

.DEFINE "disp"

.CLASS 65

.VALUE -13

.TYPE 44

.ENDEF

.DEFINE "yd"

.CLASS 65

.VALUE -14

.TYPE 12

.ENDEF

.DEFINE "key_pressed"

.CLASS 65

.VALUE -15

.TYPE 12

.ENDEF

.DEFINE "xd"

.CLASS 65

.VALUE -19

.TYPE 12

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -20

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-80
	LD	SP,HL
;  173		
;  174		kb_Scan();
.LINE 174

	CALL	_kb_Scan
;  175		setKeys();
.LINE 175

	CALL	_setKeys
;  176		
;  177		for(step = 0; step < steps; ++step) {
.LINE 177

	XOR	A,A
	LD	(_step),A
	JR	L_166
L_164:
;  178			int i;
;  179			uint8_t x;
;  180			uint8_t y;
;  181			opcode = (memory[pc] << 8) | memory[pc+1];
.LINE 181

	LD	BC,(_pc)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	H,L
	LD	L,0
	LD	DE,HL
	LD	BC,(_pc)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,DE
	CALL	__sor
	LD	BC,HL
	LD	HL,_opcode
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  182			x = (opcode & 0x0f00) >> 8;
.LINE 182

	LD	HL,(_opcode)
	LD	A,8
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-4),A
;  183			y = (opcode & 0x00f0) >> 4;
.LINE 183

	LD	HL,(_opcode)
	LD	A,4
	CALL	__sshru_b
	LD	BC,HL
	CALL	__stoiu
	LD	A,L
	AND	A,15
	LD	(IX+-5),A
;  184			
;  185			pc += 2;
.LINE 185

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  186			
;  187			switch(opcode & 0xf000) {
.LINE 187

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	BC,61440
	CALL	__iand
	CALL	__case16D
	JP	(HL)
L__10:
	DW	16
	DW	0
	DW24	L_21	

	DW	4096
	DW24	L_48	

	DW	8192
	DW24	L_49	

	DW	12288
	DW24	L_51	

	DW	16384
	DW24	L_54	

	DW	20480
	DW24	L_57	

	DW	24576
	DW24	L_60	

	DW	28672
	DW24	L_61	

	DW	32768
	DW24	L_62	

	DW	36864
	DW24	L_73	

	DW	40960
	DW24	L_76	

	DW	45056
	DW24	L_77	

	DW	49152
	DW24	L_78	

	DW	53248
	DW24	L_79	

	DW	57344
	DW24	L_111	

	DW	61440
	DW24	L_119	

	DW24	L_165	

;  188				case 0x0000: {
L_21:
.LINE 188

;  189					switch(opcode & 0x00f0) {
.LINE 189

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,240
	UEXT	HL
	LD	L,A
	LD	BC,192
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_46
;  190						case 0x00c0: { //SCD
.LINE 190

;  191							uint8_t n = (opcode & 0x000f);
.LINE 191

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-20),A
;  192							uint8_t *disp = &canvas_data[2];
.LINE 192

	LD	IY,_canvas_data
	LEA	IY,IY+2
	LD	(IX+-23),IY
;  193							
;  194							for(i = screen_height-2; i >= 0; i--) {
.LINE 194

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	DEC	HL
	DEC	HL
	LD	(IX+-3),HL
	JR	L_26
L_24:
;  195								memcpy(disp + (i+n)*screen_width, disp + i*screen_width, screen_width);
.LINE 195

	LD	BC,(IX+-23)
	LD	(IX+-18),BC
	LD	(IX+-29),BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-29)
	ADD	HL,BC
	PUSH	HL
	LD	A,(IX+-20)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	DE,HL
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,(IX+-29)
	ADD	HL,BC
	PUSH	HL
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  196								memset(disp + i*screen_width, 0, screen_width);
.LINE 196

	LD	BC,(IX+-18)
	LD	(IX+-23),BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__imuls
	LD	BC,(IX+-18)
	ADD	HL,BC
	PUSH	HL
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
;  197							}
L_26:
.LINE 197

	LD	HL,(IX+-3)
	CALL	__icmpzero
	JP	P,L_24
;  198							
;  199							drawFlag = true; 
.LINE 199

	LD	A,1
	LD	(_drawFlag),A
;  200							
;  201							break;
;  202						}
;  203						break;
;  204					}
L_46:
.LINE 204

;  205					switch(opcode & 0x00ff) {
.LINE 205

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__12:
	DW	7
	DB	224
	DW24	L_28	

	DB	238
	DW24	L_29	

	DB	251
	DW24	L_30	

	DB	252
	DW24	L_36	

	DB	253
	DW24	L_42	

	DB	254
	DW24	L_43	

	DB	255
	DW24	L_44	

	DW24	L_45	

;  206						case 0x00e0:
L_28:
.LINE 206

;  207							memset(canvas_data + 2, 0, pixel_number);
.LINE 207

	LD	A,(_pixel_number)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,_canvas_data+2
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  208							drawFlag = true;
.LINE 208

	LD	A,1
	LD	(_drawFlag),A
;  209							break;
.LINE 209

	JR	L_165
;  210						case 0x00ee:
L_29:
.LINE 210

;  211							pc = stack[(--sp)&0xf];
.LINE 211

	LD	A,(_sp)
	DEC	A
	LD	(_sp),A
	AND	A,15
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	BC,(HL)
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  212							break;
.LINE 212

	JR	L_165
;  213						case 0x00fb: { //SCR
L_30:
.LINE 213

;  214							uint8_t *disp = &canvas_data[2];
.LINE 214

	LD	BC,_canvas_data+2
	LD	(IX+-10),BC
;  215							
;  216							for(i = 0; i < screen_height; i++) {
.LINE 216

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_34
L_32:
;  217								memmove(disp + 4, disp, screen_width - 4);
.LINE 217

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	LD	IY,(IX+-10)
	LEA	BC,IY+4
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  218								memset(disp, 0, 4);
.LINE 218

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  219								disp += screen_width;
.LINE 219

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-10)
	ADD	HL,BC
	LD	(IX+-10),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  220							}
L_34:
.LINE 220

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_32
;  221							break;
.LINE 221

	JR	L_165
;  222						}
;  223						case 0x00fc: { //SCL
L_36:
.LINE 223

;  224							uint8_t *disp = &canvas_data[2];
.LINE 224

	LD	BC,_canvas_data+2
	LD	(IX+-13),BC
;  225							
;  226							for(i = 0; i < screen_height; i++) {
.LINE 226

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_40
L_38:
;  227								memmove(disp, disp + 4, screen_width - 4);
.LINE 227

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	LD	IY,(IX+-13)
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  228								memset(disp + screen_width - 4, 0, 4);
.LINE 228

	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-13)
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+-4
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  229								disp += screen_width;
.LINE 229

	LD	A,(_screen_width)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-13)
	ADD	HL,BC
	LD	(IX+-13),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  230							}
L_40:
.LINE 230

	LD	A,(_screen_height)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_38
;  231							break;
.LINE 231

	JR	L_165
;  232						}
;  233						case 0x00fd:
L_42:
.LINE 233

;  234							playing = 0;
.LINE 234

	XOR	A,A
	LD	(_playing),A
;  235							//exit
;  236							break;
.LINE 236

	JR	L_165
;  237						case 0x00fe:
L_43:
.LINE 237

;  238							extendedScreen = 0;
.LINE 238

	XOR	A,A
	LD	(_extendedScreen),A
;  239							screen_width = 64;
.LINE 239

	LD	A,64
	LD	(_screen_width),A
;  240							screen_height = 32;
.LINE 240

	LD	A,32
	LD	(_screen_height),A
;  241							canvas_data[0] = 64;
.LINE 241

	LD	A,64
	LD	(_canvas_data),A
;  242							canvas_data[1] = 32;
.LINE 242

	LD	HL,_canvas_data
	INC	HL
	LD	(HL),32
;  243							pixel_number = 2048;
.LINE 243

	XOR	A,A
	LD	(_pixel_number),A
;  244							break;
.LINE 244

	JR	L_165
;  245						case 0x00ff:
L_44:
.LINE 245

;  246							extendedScreen = 1;
.LINE 246

	LD	A,1
	LD	(_extendedScreen),A
;  247							screen_width = 128;
.LINE 247

	LD	A,128
	LD	(_screen_width),A
;  248							screen_height = 64;
.LINE 248

	LD	A,64
	LD	(_screen_height),A
;  249							canvas_data[0] = 128;
.LINE 249

	LD	A,128
	LD	(_canvas_data),A
;  250							canvas_data[1] = 64;
.LINE 250

	LD	HL,_canvas_data
	INC	HL
	LD	(HL),64
;  251							pixel_number = 8192;
.LINE 251

	XOR	A,A
	LD	(_pixel_number),A
;  252							break;
.LINE 252

	JR	L_165
;  253						default:
L_45:
.LINE 253

;  254							pc = (pc & 0x0fff);
.LINE 254

	LD	HL,(_pc)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  255							break;
.LINE 255

	JR	L_165
;  256					}
;  257					break;
;  258				}
;  259				case 0x1000: {
L_48:
.LINE 259

;  260					pc = (opcode & 0x0fff);
.LINE 260

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  261					break;
.LINE 261

	JR	L_165
;  262				}
;  263				case 0x2000: {
L_49:
.LINE 263

;  264					stack[sp++] = pc;
.LINE 264

	LD	A,(_sp)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_stack
	ADD	HL,BC
	LD	A,(_pc)
	LD	(HL),A
	INC	HL
	LD	A,(_pc+1)
	LD	(HL),A
	LD	A,(_sp)
	INC	A
	LD	(_sp),A
;  265					pc = (opcode & 0x0fff);
.LINE 265

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  266					break;
.LINE 266

	JR	L_165
;  267				}
;  268				case 0x3000: {
L_51:
.LINE 268

;  269					if(V[x] == (opcode & 0x00ff))
.LINE 269

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_165
;  270						pc += 2;
.LINE 270

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  271					break;
.LINE 271

	JR	L_165
;  272				}
;  273				case 0x4000: {
L_54:
.LINE 273

;  274					if(V[x] != (opcode & 0x00ff))
.LINE 274

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_opcode)
	LD	C,A
	LD	B,0
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	Z,L_165
;  275						pc += 2;
.LINE 275

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  276					break;
.LINE 276

	JR	L_165
;  277				}
;  278				case 0x5000: {
L_57:
.LINE 278

;  279					if(V[x] == V[y])
.LINE 279

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	NZ,L_165
;  280						pc += 2;
.LINE 280

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  281					break;
.LINE 281

	JR	L_165
;  282				}
;  283				case 0x6000: {
L_60:
.LINE 283

;  284					V[x] = (opcode & 0x00ff);
.LINE 284

	LD	A,(_opcode)
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  285					break;
.LINE 285

	JR	L_165
;  286				}
;  287				case 0x7000: {
L_61:
.LINE 287

;  288					V[x] = (V[x] + (opcode & 0x00ff)) & 0xff;
.LINE 288

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-32),HL
	LD	A,(_opcode)
	LD	HL,(IX+-32)
	ADD	A,(HL)
	LD	HL,(IX+-32)
	LD	(HL),A
;  289					break;
.LINE 289

	JR	L_165
;  290				}
;  291				case 0x8000: {
L_62:
.LINE 291

;  292					switch(opcode & 0x000f) {
.LINE 292

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	AND	A,15
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__18:
	DW	9
	DB	0
	DW24	L_63	

	DB	1
	DW24	L_64	

	DB	2
	DW24	L_65	

	DB	3
	DW24	L_66	

	DB	4
	DW24	L_67	

	DB	5
	DW24	L_68	

	DB	6
	DW24	L_69	

	DB	7
	DW24	L_70	

	DB	14
	DW24	L_71	

	DW24	L_165	

;  293						case 0x0000: {
L_63:
.LINE 293

;  294							V[x]  = V[y];
.LINE 294

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
;  295							break;
.LINE 295

	JR	L_165
;  296						}
;  297						case 0x0001: {
L_64:
.LINE 297

;  298							V[x] |= V[y];
.LINE 298

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-35),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-35)
	LD	A,(HL)
	OR	A,(IY)
	LD	HL,(IX+-35)
	LD	(HL),A
;  299							break;
.LINE 299

	JR	L_165
;  300						}
;  301						case 0x0002: {
L_65:
.LINE 301

;  302							V[x] &= V[y];
.LINE 302

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-38),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-38)
	LD	A,(HL)
	AND	A,(IY)
	LD	HL,(IX+-38)
	LD	(HL),A
;  303							break;
.LINE 303

	JR	L_165
;  304						}
;  305						case 0x0003: {
L_66:
.LINE 305

;  306							V[x] ^= V[y];
.LINE 306

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-41),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-41)
	LD	A,(HL)
	XOR	A,(IY)
	LD	HL,(IX+-41)
	LD	(HL),A
;  307							break;
.LINE 307

	JR	L_165
;  308						}
;  309						case 0x0004: {
L_67:
.LINE 309

;  310							V[0xf] = (V[x] + V[y] > 0xff);
.LINE 310

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-44),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-44)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,HL
	LD	HL,255
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L__20
	LD	A,1
	JR	L__21
L__20:
	XOR	A,A
L__21:
	LD	HL,_V+15
	LD	(HL),A
;  311							V[x] += V[y];
.LINE 311

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,(IX+-44)
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-44)
	LD	(IX+-77),HL	; spill
	LD	HL,(IX+-68)	; unspill
	LD	A,(HL)
	ADD	A,(IY)
	LD	HL,(IX+-77)	; unspill
	LD	(HL),A
;  312							V[x] &= 255;
.LINE 312

	LD	HL,(IX+-44)
	LD	A,(HL)
	LD	HL,(IX+-44)
	LD	(HL),A
;  313							break;
.LINE 313

	JR	L_165
;  314						}
;  315						case 0x0005: {
L_68:
.LINE 315

;  316							V[0xf] = V[x] >= V[y];
.LINE 316

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-47),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-47)
	LD	A,(IY)
	CP	A,(HL)
	JR	C,L__23
	LD	A,1
	JR	L__24
L__23:
	XOR	A,A
L__24:
	LD	HL,_V+15
	LD	(HL),A
;  317							V[x] -= V[y];
.LINE 317

	LD	IY,(IX+-47)
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-47)
	LD	(IX+-74),HL	; spill
	LD	HL,(IX+-68)	; unspill
	LD	A,(IY)
	SUB	A,(HL)
	LD	HL,(IX+-74)	; unspill
	LD	(HL),A
;  318							break;
.LINE 318

	JR	L_165
;  319						}
;  320						case 0x0006: {
L_69:
.LINE 320

;  321							V[0xf] = V[x] & 1;
.LINE 321

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-50),HL
	LD	A,(HL)
	AND	A,1
	LD	HL,_V+15
	LD	(HL),A
;  322							V[x] >>= 1;
.LINE 322

	LD	HL,(IX+-50)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,1
	CALL	__ishrs_b
	LD	IY,(IX+-50)
	LD	(IY),L
;  323							break;
.LINE 323

	JR	L_165
;  324						}
;  325						case 0x0007: {
L_70:
.LINE 325

;  326							V[0xf] = V[y] >= V[x];
.LINE 326

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-53),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-53)
	LD	A,(HL)
	CP	A,(IY)
	JR	C,L__26
	LD	A,1
	JR	L__27
L__26:
	XOR	A,A
L__27:
	LD	HL,_V+15
	LD	(HL),A
;  327							V[x] = V[y] - V[x];
.LINE 327

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-53)
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-53)
	LD	(IX+-71),HL	; spill
	LD	HL,(IX+-68)	; unspill
	LD	A,(HL)
	SUB	A,(IY)
	LD	HL,(IX+-71)	; unspill
	LD	(HL),A
;  328							break;
.LINE 328

	JR	L_165
;  329						}
;  330						case 0x000E: {
L_71:
.LINE 330

;  331							V[0xf] = V[x] >> 7;
.LINE 331

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-56),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,7
	CALL	__ishrs_b
	LD	IY,_V
	LD	(IY+15),L
;  332							V[x] <<= 1;
.LINE 332

	LD	HL,(IX+-56)
	LD	A,(HL)
	ADD	A,A
	LD	HL,(IX+-56)
	LD	(HL),A
;  333							break;
.LINE 333

	JR	L_165
;  334						}
;  335						break;
;  336					}
;  337					break;
;  338				}
;  339				case 0x9000: {
L_73:
.LINE 339

;  340					if(V[x] != V[y])
.LINE 340

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_165
;  341						pc += 2;
.LINE 341

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  342					break;
.LINE 342

	JR	L_165
;  343				}
;  344				case 0xa000: {
L_76:
.LINE 344

;  345					I = (opcode & 0x0fff);
.LINE 345

	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  346					break;
.LINE 346

	JR	L_165
;  347				}
;  348				case 0xb000: {
L_77:
.LINE 348

;  349					pc = V[0] + (opcode & 0x0fff);
.LINE 349

	LD	A,(_V)
	LD	C,A
	LD	B,0
	LD	DE,BC
	LD	HL,(_opcode)
	LD.LIS	BC,4095
	CALL	__sand
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  350					break;
.LINE 350

	JR	L_165
;  351				}
;  352				case 0xc000: {
L_78:
.LINE 352

;  353					V[x] = (rand() & 0xff) & (opcode & 0x00FF);
.LINE 353

	LD	A,(_opcode)
	LD	B,A
	LD	(IX+-80),BC
	CALL	_rand
	LD	BC,(IX+-80)
	LD	A,B
	AND	A,L
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  354					break;
.LINE 354

	JR	L_165
;  355				}
;  356				case 0xd000: {
L_79:
.LINE 356

;  357					uint8_t xd = V[x];
.LINE 357

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-19),A
;  358					uint8_t yd = V[y];
.LINE 358

	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-14),A
;  359					uint8_t height = (opcode & 0x000f);
.LINE 359

	LD	A,(_opcode)
	AND	A,15
	LD	(IX+-6),A
;  360					
;  361					V[0xf] = 0;
.LINE 361

	LD	HL,_V+15
	LD	(HL),0
;  362					
;  363					if(extendedScreen) {
.LINE 363

	LD	A,(_extendedScreen)
	OR	A,A
	JR	Z,L_109
;  364						//Extended screen DXY0
;  365						uint8_t cols = 1;
.LINE 365

	LD	(IX+-7),1
;  366						if(height == 0) {
.LINE 366

	LD	A,(IX+-6)
	OR	A,A
	JR	NZ,L_96
;  367							cols = 2;
.LINE 367

	LD	(IX+-7),2
;  368							height = 16;
.LINE 368

	LD	(IX+-6),16
;  369						}
L_96:
.LINE 369

;  370						for(_y = 0; _y < height; ++_y) {
.LINE 370

	XOR	A,A
	LD	(__y),A
	JR	L_95
L_93:
;  371							pixel = memory[I + (cols*_y)];
.LINE 371

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  372							if(cols == 2) {
.LINE 372

	LD	A,(IX+-7)
	CP	A,2
	JR	NZ,L_92
;  373								pixel <<= 8;
.LINE 373

	LD	HL,(_pixel)
	LD	H,L
	LD	L,0
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  374								pixel |= memory[I + (_y << 1)+1];
.LINE 374

	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	HL,BC
	LD	BC,(_pixel)
	CALL	__sor
	LD	BC,HL
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  375							}
L_92:
.LINE 375

;  376							for(_x = 0; _x < (cols << 3); ++_x) {
.LINE 376

	XOR	A,A
	LD	(__x),A
	JR	L_91
L_89:
;  377								if((pixel & (((cols == 2) ? 0x8000 : 0x80) >> _x)) != 0) {
.LINE 377

	LD	A,(IX+-7)
	CP	A,2
	JR	NZ,L_84
	LD	BC,32768
	LD	(IX+-26),BC
	JR	L_85
L_84:
	LD	BC,128
	LD	(IX+-26),BC
L_85:
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-26)
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_90
;  378									index = (((xd + _x) & 0x7f) + (((yd + _y) & 0x3f) << 7)) + 2;
.LINE 378

	LD	A,(__x)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-19)
	ADD.SIS	HL,BC
	LD	A,L
	RES	7,A
	LD	C,A
	LD	DE,BC
	LD	A,(__y)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-14)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,63
	LD	C,A
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  379									V[0xf] |= canvas_data[index] & 1;
.LINE 379

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-59),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-59)
	OR	A,(HL)
	LD	HL,(IX+-59)
	LD	(HL),A
;  380									if (canvas_data[index])
.LINE 380

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_87
;  381										canvas_data[index] = 0;
.LINE 381

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(HL),0
;  382									else
.LINE 382

	JR	L_90
L_87:
;  383										canvas_data[index] = 1;
.LINE 383

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(HL),1
;  384								}
;  385							}
L_90:
.LINE 385

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_91:
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	A,(__x)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JP	M,L_89
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  386						}
L_95:
.LINE 386

	LD	A,(__y)
	CP	A,(IX+-6)
	JR	C,L_93
	JR	L_110
;  387					} else {
L_109:
.LINE 387

;  388						//Normal screen DXYN
;  389						if(height == 0) height = 16;
.LINE 389

	LD	A,(IX+-6)
	OR	A,A
	JR	NZ,L_107
	LD	(IX+-6),16
L_107:
;  390						for(_y = 0; _y < height; ++_y) {
.LINE 390

	XOR	A,A
	LD	(__y),A
	JR	L_106
L_104:
;  391							pixel = memory[I + _y];
.LINE 391

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,HL
	LD	A,(__y)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_pixel
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  392							for(_x = 0; _x < 8; ++_x) {
.LINE 392

	XOR	A,A
	LD	(__x),A
	JR	L_103
L_101:
;  393								if((pixel & (0x80 >> _x)) != 0) {
.LINE 393

	LD	A,(__x)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,128
	CALL	__ishrs
	LD	BC,(_pixel)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_102
;  394									index = (((xd + _x) & 0x3f) + (((yd + _y) & 0x1f) << 6)) + 2;
.LINE 394

	LD	A,(__x)
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	C,(IX+-19)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,63
	LD	C,A
	LD	DE,BC
	LD	A,(__y)
	LD	C,A
	LD	HL,BC
	LD	C,(IX+-14)
	ADD.SIS	HL,BC
	LD	A,L
	AND	A,31
	LD	C,A
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	INC	HL
	INC	HL
	LD	BC,HL
	LD	HL,_index
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  395									V[0xf] |= canvas_data[index] & 1;
.LINE 395

	LD	IY,_V
	LEA	IY,IY+15
	LD	(IX+-62),IY
	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	A,(HL)
	AND	A,1
	LD	HL,(IX+-62)
	OR	A,(HL)
	LD	HL,(IX+-62)
	LD	(HL),A
;  396									if (canvas_data[index])
.LINE 396

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_99
;  397										canvas_data[index] = 0;
.LINE 397

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(HL),0
;  398									else
.LINE 398

	JR	L_102
L_99:
;  399										canvas_data[index] = 1;
.LINE 399

	LD	BC,(_index)
	CALL	__stoiu
	LD	BC,_canvas_data
	ADD	HL,BC
	LD	(HL),1
;  400								}
;  401							}
L_102:
.LINE 401

	LD	A,(__x)
	INC	A
	LD	(__x),A
L_103:
	LD	A,(__x)
	CP	A,8
	JR	C,L_101
	LD	A,(__y)
	INC	A
	LD	(__y),A
;  402						}
L_106:
.LINE 402

	LD	A,(__y)
	CP	A,(IX+-6)
	JR	C,L_104
;  403					}
L_110:
.LINE 403

;  404					
;  405					drawFlag = true;
.LINE 405

	LD	A,1
	LD	(_drawFlag),A
;  406					
;  407					break;
.LINE 407

	JR	L_165
;  408				}
;  409				case 0xe000: {
L_111:
.LINE 409

;  410					switch(opcode & 0x00ff) {
.LINE 410

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__42:
	DW	2
	DB	158
	DW24	L_112	

	DB	161
	DW24	L_115	

	DW24	L_165	

;  411						case 0x009e: {
L_112:
.LINE 411

;  412							if(keys[V[x]])
.LINE 412

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_165
;  413								pc += 2;
.LINE 413

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  414							break;
.LINE 414

	JR	L_165
;  415						}
;  416						case 0x00a1: {
L_115:
.LINE 416

;  417							if(!keys[V[x]])
.LINE 417

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,_keys
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_165
;  418								pc += 2;
.LINE 418

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  419							break;
.LINE 419

	JR	L_165
;  420						}
;  421					}
;  422					break;
;  423				}
;  424				case 0xf000: {
L_119:
.LINE 424

;  425					switch(opcode & 0x00ff) {
.LINE 425

	LD	BC,(_opcode)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__45:
	DW	12
	DB	7
	DW24	L_120	

	DB	10
	DW24	L_121	

	DB	21
	DW24	L_128	

	DB	24
	DW24	L_130	

	DB	30
	DW24	L_131	

	DB	41
	DW24	L_135	

	DB	48
	DW24	L_136	

	DB	51
	DW24	L_137	

	DB	85
	DW24	L_138	

	DB	101
	DW24	L_143	

	DB	117
	DW24	L_148	

	DB	133
	DW24	L_155	

	DW24	L_165	

;  426						case 0x0007: {
L_120:
.LINE 426

;  427							V[x] = delay_timer;
.LINE 427

	LD	A,(_delay_timer)
	LD	B,A
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  428							break;
.LINE 428

	JR	L_165
;  429						}
;  430						case 0x000A: {
L_121:
.LINE 430

;  431							bool key_pressed = false;
.LINE 431

	LD	(IX+-15),0
;  432							pc -= 2;
.LINE 432

	LD	IY,(_pc)
	LEA	BC,IY+-2
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  433							
;  434							for(i = 0; i < 16; ++i) {
.LINE 434

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_125
L_123:
;  435								if(keys[i]) {
.LINE 435

	LD	BC,_keys
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_124
;  436									V[x] = i;
.LINE 436

	LD	B,(IX+-3)
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,_V
	ADD	HL,DE
	LD	(HL),B
;  437									pc += 2;
.LINE 437

	LD	BC,(_pc)
	INC	BC
	INC	BC
	LD	HL,_pc
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  438									key_pressed = true;
.LINE 438

	LD	(IX+-15),1
;  439									break;
.LINE 439

	JR	L_127
;  440								}
;  441							}
L_124:
.LINE 441

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_125:
	LD	BC,16
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_123
L_127:
;  442							
;  443							if(!key_pressed)
.LINE 443

	LD	A,(IX+-15)
	OR	A,A
	JR	Z,L_171
;  444								return;
.LINE 444

;  445						}
.LINE 445

;  446						case 0x0015: {
L_128:
.LINE 446

;  447							delay_timer = V[x];
.LINE 447

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  448							break;
.LINE 448

	JR	L_165
;  449						}
;  450						case 0x0018: {
L_130:
.LINE 450

;  451							sound_timer = V[x];
.LINE 451

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),0
;  452							break;
.LINE 452

	JR	L_165
;  453						}
;  454						case 0x001E: {
L_131:
.LINE 454

;  455							if(I + V[x] > 0xff) V[0xf] = 1;
.LINE 455

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	BC,(_I)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,HL
	LD	HL,255
	OR	A,A
	SBC	HL,BC
	JP	P,L_133
	LD	HL,_V+15
	LD	(HL),1
;  456							else V[0xf] = 0;
.LINE 456

	JR	L_134
L_133:
	LD	HL,_V+15
	LD	(HL),0
L_134:
;  457							I = (I + V[x]) & 0xffff;
.LINE 457

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	LD	DE,(_I)
	LD	HL,BC
	ADD.SIS	HL,DE
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  458							break;
.LINE 458

	JR	L_165
;  459						}
;  460						case 0x0029: {
L_135:
.LINE 460

;  461							I = (V[x] & 0xf) * 5;
.LINE 461

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	AND	A,15
	LD	C,A
	LD	B,0
	LD.LIS	HL,5
	CALL	__smulu
	LD	BC,HL
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  462							break;
.LINE 462

	JR	L_165
;  463						}
;  464						case 0x0030: {
L_136:
.LINE 464

;  465							I = (V[x] & 0xf) * 10 + 80;
.LINE 465

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	A,(HL)
	AND	A,15
	LD	C,A
	LD	B,0
	LD.LIS	HL,10
	CALL	__smulu
	LD	IY,HL
	LEA	BC,IY+80
	LD	HL,_I
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  466							break;
.LINE 466

	JR	L_165
;  467						}
;  468						case 0x0033: {
L_137:
.LINE 468

;  469							memory[ I ] = V[x] / 100;
.LINE 469

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,_V
	ADD	HL,BC
	LD	(IX+-65),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,100
	CALL	__idivs
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  470							memory[I+1] = (V[x] / 10) % 10;
.LINE 470

	LD	HL,(IX+-65)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  471							memory[I+2] = V[x] % 10;
.LINE 471

	LD	HL,(IX+-65)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__irems
	LD	A,L
	LD	BC,(_I)
	CALL	__stoiu
	INC	HL
	INC	HL
	LD	BC,_memory
	ADD	HL,BC
	LD	(HL),A
;  472							break;
.LINE 472

	JR	L_165
;  473						}
;  474						case 0x0055: {
L_138:
.LINE 474

;  475							for(i = 0; i <= x; ++i) {
.LINE 475

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_141
L_139:
;  476								memory[I + i] = V[i];
.LINE 476

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  477							}
L_141:
.LINE 477

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_139
;  478							break;
.LINE 478

	JR	L_165
;  479						}
;  480						case 0x0065: {
L_143:
.LINE 480

;  481							for(i = 0; i <= x; ++i) {
.LINE 481

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_146
L_144:
;  482								V[i] = memory[I + i];
.LINE 482

	LD	BC,(_I)
	CALL	__stoiu
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	BC,_memory
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  483							}
L_146:
.LINE 483

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_144
;  484							break;
.LINE 484

	JR	L_165
;  485						}
;  486						case 0x0075: {
L_148:
.LINE 486

;  487							if (x > 7) x = 7;
.LINE 487

	LD	A,7
	CP	A,(IX+-4)
	JR	NC,L_153
	LD	(IX+-4),7
L_153:
;  488							for(i = 0; i <= x; ++i) {
.LINE 488

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_152
L_150:
;  489								SV[i] = V[i];
.LINE 489

	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  490							}
L_152:
.LINE 490

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_150
;  491							break;
.LINE 491

	JR	L_165
;  492						}
;  493						case 0x0085: {
L_155:
.LINE 493

;  494							if (x > 7) x = 7;
.LINE 494

	LD	A,7
	CP	A,(IX+-4)
	JR	NC,L_160
	LD	(IX+-4),7
L_160:
;  495							for(i = 0; i <= x; ++i) {
.LINE 495

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_159
L_157:
;  496								V[i] = SV[i];
.LINE 496

	LD	BC,_SV
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,_V
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  497							}
L_159:
.LINE 497

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_157
;  498							break;
;  499						}
;  500					}
;  501					break;
;  502				}
;  503				default:
;  504					break;
;  505			}
;  506		}
L_165:
.LINE 506

	LD	A,(_step)
	INC	A
	LD	(_step),A
L_166:
	LD	A,(_step)
	CP	A,(IX+6)
	JR	C,L_164
;  507		if(sound_timer > 0) {
.LINE 507

	LD	BC,(_sound_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_170
;  508			--sound_timer;
.LINE 508

	LD	BC,(_sound_timer)
	DEC	BC
	LD	HL,_sound_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  509		}
L_170:
.LINE 509

;  510		if(delay_timer > 0) {
.LINE 510

	LD	BC,(_delay_timer)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_171
;  511			--delay_timer;
.LINE 511

	LD	BC,(_delay_timer)
	DEC	BC
	LD	HL,_delay_timer
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  512		}
;  513	}
L_171:
.LINE 513

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emulateCycle ***************************
;Name                         Addr/Register   Size   Type
;_SV                                 STATIC      8   variable
;_sound_timer                        STATIC      2   variable
;_delay_timer                        STATIC      2   variable
;_keys                               STATIC     16   variable
;_index                              STATIC      2   variable
;__x                                 STATIC      1   variable
;_pixel                              STATIC      2   variable
;__y                                 STATIC      1   variable
;_rand                               IMPORT  -----   function
;_I                                  STATIC      2   variable
;_V                                  STATIC     16   variable
;_extendedScreen                     STATIC      1   variable
;_playing                            STATIC      1   variable
;_memmove                            IMPORT  -----   function
;_stack                              STATIC     32   variable
;_sp                                 STATIC      1   variable
;_pixel_number                       STATIC      1   variable
;_drawFlag                           STATIC      1   variable
;_memset                             IMPORT  -----   function
;_screen_width                       STATIC      1   variable
;_memcpy                             IMPORT  -----   function
;_screen_height                      STATIC      1   variable
;_canvas_data                        STATIC   8194   variable
;_opcode                             STATIC      2   variable
;_pc                                 STATIC      2   variable
;_memory                             STATIC   4096   variable
;_step                               STATIC      1   variable
;_setKeys                            IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;temp82                               IX-26      3   variable
;G_0                                  IX-23      3   variable
;n                                    IX-20      1   variable
;xd                                   IX-19      1   variable
;G_1                                  IX-18      3   variable
;key_pressed                          IX-15      1   variable
;yd                                   IX-14      1   variable
;disp                                 IX-13      3   variable
;disp                                 IX-10      3   variable
;cols                                  IX-7      1   variable
;height                                IX-6      1   variable
;y                                     IX-5      1   variable
;x                                     IX-4      1   variable
;i                                     IX-3      3   variable
;steps                                 IX+6      1   parameter


; Stack Frame Size: 89 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emulateCycle",513,"_emulateCycle"
	XREF _kb_Scan:ROM
	XREF _memmove:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _ti_GetSize:ROM
	XREF _ti_Read:ROM
	XREF _ti_Open:ROM
	XREF _ti_CloseAll:ROM
	XREF _rand:ROM
	XREF _srand:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __sor:ROM
	XREF __sand:ROM
	XREF __iand:ROM
	XREF __smulu:ROM
	XREF __irems:ROM
	XREF __ishrs:ROM
	XREF __stoiu:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __case8D:ROM
	XREF __case16D:ROM
	XREF __ishrs_b:ROM
	XREF __sshru_b:ROM
	XDEF _emulateCycle
	XDEF _setKeys
	XDEF _loadProgram
	XDEF _initialize
	XDEF _pixel_number
	XDEF _screen_height
	XDEF _screen_width
	XDEF __x
	XDEF __y
	XDEF _index
	XDEF _pixel
	XDEF _step
	XDEF _fontset_ten
	XDEF _fontset
	XDEF _file
	XDEF _controlMap
	XDEF _keypad
	XDEF _canvas_data
	XDEF _game_data
	XDEF _plane
	XDEF _extendedScreen
	XDEF _playing
	XDEF _paused
	XDEF _drawFlag
	XDEF _keys
	XDEF _sp
	XDEF _stack
	XDEF _sound_timer
	XDEF _delay_timer
	XDEF _pc
	XDEF _I
	XDEF _V
	XDEF _SV
	XDEF _memory
	XDEF _opcode
	END
